---
title: 在小組環境中 Code First 移轉-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: b3c4c35d636caf4ddd251dd78e026587abc57d42
ms.sourcegitcommit: 708b18520321c587b2046ad2ea9fa7c48aeebfe5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/09/2019
ms.locfileid: "72182605"
---
# <a name="code-first-migrations-in-team-environments"></a>在小組環境中 Code First 移轉
> [!NOTE]
> 本文假設您知道如何在基本案例中使用 Code First 移轉。 如果您沒有這麼做，則必須先閱讀[Code First 移轉](~/ef6/modeling/code-first/migrations/index.md)，才能繼續進行。

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a>拿咖啡，您必須閱讀這整篇文章

當兩位開發人員在其本機程式碼基底中產生了遷移時，小組環境中的問題大部分都是圍繞合併遷移。 雖然解決這些問題的步驟非常簡單，但卻需要您全面瞭解遷移的運作方式。 請不要直接跳到結尾-請花時間閱讀整篇文章，以確保您成功。

## <a name="some-general-guidelines"></a>一些一般方針

在我們深入探討如何管理多個開發人員所產生的合併遷移之前，以下是設定成功的一些一般指導方針。

### <a name="each-team-member-should-have-a-local-development-database"></a>每個小組成員都應該有本機開發資料庫

遷移會使用 **\_\_MigrationsHistory**資料表來儲存已套用至資料庫的遷移。 如果您有多個開發人員在嘗試以相同的資料庫為目標時產生不同的遷移（因而共用 **\_\_MigrationsHistory**資料表），則遷移會變得非常困惑。

當然，如果您的小組成員不會產生遷移，則不會有任何問題讓他們共用中央開發資料庫。

### <a name="avoid-automatic-migrations"></a>避免自動遷移

重點是，自動遷移一開始在小組環境中看起來很不錯，但事實上，它們並不可行。 如果您想要知道原因，請繼續閱讀–如果沒有，您可以跳到下一節。

自動遷移可讓您更新資料庫架構，使其符合目前的模型，而不需要產生程式碼檔案（以程式碼為基礎的遷移）。 如果您從未使用過，自動遷移會在小組環境中正常運作，而不會產生任何以程式碼為基礎的遷移。 問題在於自動遷移會受到限制，而且不會處理許多作業–屬性/資料行重新命名、將資料移至另一個資料表等等。若要處理這些案例，您最後會產生以程式碼為基礎的遷移（以及編輯 scaffold 程式碼），其混合在自動遷移所處理的變更之間。 當兩位開發人員簽入遷移時，這會使其接近不可能合併變更。

## <a name="screencasts"></a>螢幕錄製影片

如果您想要觀賞螢幕錄製影片，而不是閱讀本文，下列兩段影片涵蓋的內容與本文相同。

### <a name="video-one-migrations---under-the-hood"></a>影片一：「在幕後進行遷移」

[此螢幕錄製影片](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood)涵蓋遷移如何追蹤和使用模型的相關資訊，以偵測模型的變更。

### <a name="video-two-migrations---team-environments"></a>影片二：「遷移-小組環境」

以上一段影片的概念為基礎，[此螢幕錄製影片](https://channel9.msdn.com/blogs/ef/migrations-team-environments)涵蓋了小組環境中所發生的問題，以及如何解決這些問題。

## <a name="understanding-how-migrations-works"></a>瞭解遷移的運作方式

在小組環境中成功使用遷移的關鍵，是瞭解遷移如何追蹤和使用模型相關資訊來偵測模型變更的基本概念。

### <a name="the-first-migration"></a>第一次遷移

當您新增第一次遷移至專案時，您會在套件管理員主控台中執行類似于「**新增-遷移**」的作業。 此命令執行的高階步驟如下圖所示。

![第一次遷移](~/ef6/media/firstmigration.png)

目前的模型是從您的程式碼（1）計算而來。 然後模型會計算所需的資料庫物件（2）–因為這是第一次的遷移，所以模型差異只會使用空的模型進行比較。 必要的變更會傳遞給程式碼產生器，以建立必要的遷移程式碼（3），然後將它新增至您的 Visual Studio 解決方案（4）。

除了主要程式碼檔案中儲存的實際遷移程式碼，遷移也會產生一些額外的程式碼後置檔案。 這些檔案是由遷移所使用的中繼資料，而且不是您應該編輯的內容。 其中一個檔案是資源檔（.resx），其中包含產生遷移時的模型快照集。 您會在下一個步驟中看到其使用方式。

此時，您可能會執行**更新資料庫**，將變更套用至資料庫，然後再執行應用程式的其他部分。

### <a name="subsequent-migrations"></a>後續的遷移

稍後您會返回並對您的模型進行一些變更–在我們的範例中，我們會將**Url**屬性新增至**Blog**。 接著，您會發出一個命令，例如 [**新增-遷移 AddUrl** ]，以 scaffold 遷移以套用對應的資料庫變更。 此命令執行的高階步驟如下圖所示。

![第二個遷移](~/ef6/media/secondmigration.png)

就像最後一次一樣，目前的模型是從程式碼（1）計算而來。 不過，這次有現有的遷移，因此會從最新的遷移中抓取上一個模型（2）。 這兩個模型會空以尋找必要的資料庫變更（3），然後程式會如先前完成。

這個相同的程式會用於您新增至專案的任何進一步的遷移。

### <a name="why-bother-with-the-model-snapshot"></a>為什麼要使用模型快照集？

您可能想知道 EF 使用模型快照集 bothers 的原因，而不只是查看資料庫。 若是如此，請繼續閱讀。 如果您不感興趣，則可以略過本節。

EF 會保留模型快照集的原因有很多：

-   它可讓您的資料庫與 EF 模型漂移。 這些變更可以直接在資料庫中進行，或者您可以變更您的遷移中的 scaffold 程式碼，以進行變更。 以下是練習中的幾個範例：
    -   您想要將插入和更新的資料行加入至您的一或多個資料表，但不想在 EF 模型中包含這些資料行。 如果遷移已查看資料庫，則每次您 scaffold 遷移時，會持續嘗試卸載這些資料行。 使用模型快照集時，EF 只會偵測模型的合法變更。
    -   您想要變更用於更新的預存程式主體，以包含一些記錄。 如果遷移從資料庫查看此預存程式，它會持續嘗試並將它重設回 EF 預期的定義。 藉由使用模型快照集，只有在您變更 EF 模型中程式的圖形時，EF 才會 scaffold 程式碼來改變預存程式。
    -   這些相同的原則適用于加入額外的索引，包括資料庫中的額外資料表、將 EF 對應至位於資料表上的資料庫檢視等等。
-   EF 模型所包含的不僅僅是資料庫的圖形。 讓整個模型能夠進行遷移，以查看模型中屬性和類別的相關資訊，以及它們如何對應到資料行和資料表。 這項資訊可讓您在 scaffold 的程式碼中更聰明地進行遷移。 例如，如果您將屬性對應的資料行名稱變更為「遷移」，可以看到它是相同的屬性（如果只有資料庫架構，就無法完成這項作業），藉此偵測重新命名。 

## <a name="what-causes-issues-in-team-environments"></a>造成小組環境問題的原因

當您是使用應用程式的單一開發人員時，上一節所涵蓋的工作流程很棒。 如果您是唯一對模型進行變更的人員，它也可以在小組環境中順利運作。 在此案例中，您可以進行模型變更、產生遷移，並將它們提交至您的原始檔控制。 其他開發人員可以同步您所做的變更，並執行**更新資料庫**，以套用架構變更。

當您有多個開發人員對 EF 模型進行變更，並同時提交至原始檔控制時，就會發生問題。 EF 缺少的是將本機遷移與其他開發人員在上次同步處理後提交至原始檔控制的遷移合併在一起的第一類方法。

## <a name="an-example-of-a-merge-conflict"></a>合併衝突的範例

首先，我們來看一下這類合併衝突的具體範例。 我們會繼續進行我們先前探討的範例。 做為起點，假設原始開發人員已簽入上一節的變更。 我們會在對程式碼基底進行變更時，追蹤兩位開發人員。

我們將追蹤 EF 模型，並透過一些變更來進行遷移。 針對起點，這兩個開發人員都已同步處理至原始檔控制存放庫，如下圖所示。

![起始點](~/ef6/media/startingpoint.png)

Developer \#1 和 developer \#2 現在會在其本機程式碼基底中對 EF 模型進行一些變更。 Developer \#1 會將**評**等屬性加入至**Blog** ，並產生**AddRating**遷移以將變更套用至資料庫。 開發人員 \#2 會將**讀取器**屬性新增至**Blog** ，並產生對應的**AddReaders**遷移。 這兩個開發人員都會執行**更新資料庫**，將變更套用至其本機資料庫，然後繼續開發應用程式。

> [!NOTE]
> 遷移的前面會加上時間戳記，因此我們的圖形代表 Developer \#2 的 AddReaders 遷移會在開發人員 \#1 的 AddRating 遷移之後出現。 不論開發人員 \#1 或 \#2 產生遷移，第一次都不會與小組中工作的問題，或是合併它們的程式（我們將在下一節中討論）。

![本機變更](~/ef6/media/localchanges.png)

這是開發人員 \#1 的幸運日子，因為他們會先提交變更。 因為在同步處理其存放庫之後，沒有其他人簽入，所以他們可以直接提交變更，而不需要執行任何合併。

![提交](~/ef6/media/submit.png)

現在正是開發人員 \#2 提交的時候了。 他們不太幸運。 因為其他人已在同步處理之後提交變更，所以他們必須提取變更並進行合併。 原始檔控制系統可能會自動合併程式碼層級的變更，因為它們非常簡單。 在同步處理之後，開發人員 \#2 本機存放庫的狀態如下圖所示。 

![拉](~/ef6/media/pull.png)

在這個階段，開發人員 \#2 可以執行**更新資料庫**，這會偵測新的**AddRating**遷移（尚未套用至開發人員 \#2 的資料庫）並加以套用。 現在，[**評**等] 資料行會加入至 [ **blog** ] 資料表，且資料庫會與模型同步。

不過有幾個問題：

1.  雖然**Update-Database**會套用**AddRating**遷移，但它也會引發警告：*無法更新資料庫以符合目前的模型，因為有暫止的變更，而且自動遷移已停用*。
    問題是，儲存在最後一次遷移（**AddReader**）中的模型快照集遺漏了**Blog**上的**評**等屬性（因為它不是模型在產生遷移時的一部分）。 Code First 偵測到最後一次遷移中的模型不符合目前的模型，並引發警告。
2.  執行應用程式會產生 InvalidOperationException，指出「*支援 ' BloggingCoNtext ' 內容的模型在建立資料庫之後已經變更。請考慮使用 Code First 移轉來更新資料庫 ...* 」
    同樣地，問題是，儲存在最後一個遷移中的模型快照集不符合目前的模型。
3.  最後，我們預期執行「**新增-遷移**」現在會產生「空的」遷移（因為不會有任何變更要套用至資料庫）。 但是，由於遷移會將目前的模型與上一次遷移的模型（缺少**評**等屬性）進行比較，因此實際上會 scaffold 另一個**AddColumn**呼叫來新增至 [**評**等] 資料行。 當然，此遷移會在**更新資料庫**期間失敗，因為**評**等資料行已經存在。

## <a name="resolving-the-merge-conflict"></a>解決合併衝突

好消息是，手動處理合併並不難，但前提是您已瞭解遷移的運作方式。 如果您已跳過此區段的前面 。 抱歉，您必須先回頭閱讀本文的其餘部分！

有兩個選項，最簡單的方法是產生空白的遷移，其目前的模型為快照集。 第二個選項是更新最後一個遷移中的快照集，使其具有正確的模型快照集。 第二個選項比較困難，而且無法在每個案例中使用，但也很簡潔，因為它不需要新增額外的遷移。

### <a name="option-1-add-a-blank-merge-migration"></a>選項1：新增空白的「合併」遷移

在此選項中，我們只會產生空白的遷移，以確保最新的遷移已儲存正確的模型快照集。

無論是誰產生最後一次遷移，都可以使用此選項。 在範例中，我們已遵循開發人員 \#2 會負責進行合併，而它們會產生最後的遷移。 但是，如果開發人員 \#1 產生了最後的遷移，就可以使用這些相同的步驟。 如果牽涉到多個遷移，這些步驟也適用–我們剛剛看過兩個，讓它保持簡單。

下列程式可用於這種方法，從您發現需要從原始檔控制同步處理的時間開始。

1.  請確定您的本機程式碼基底中任何暫止的模型變更已寫入到遷移。 此步驟可確保您在產生空白遷移時，不會遺漏任何合法的變更。
2.  與原始檔控制同步。
3.  執行 [**更新-資料庫**] 以套用其他開發人員已簽入的任何新遷移。
    **_注意：_** *如果您未收到來自 Update-Database 命令的任何警告，則不會有其他開發人員的新遷移，也不需要執行任何進一步的合併。*
4.  執行「**新增-遷移」 &lt;挑選\_\_名稱&gt; – IgnoreChanges** （例如，**新增-遷移 Merge – IgnoreChanges**）。 這會使用所有中繼資料（包括目前模型的快照）來產生遷移，但會忽略在最後一次遷移時，將目前的模型與快照集進行比較時所偵測到的任何變更（這表示您會取得空白的**向上**和**向下**方法）。
5.  繼續開發，或提交至原始檔控制（當然，在執行您的單元測試之後）。

以下是使用這種方法之後，Developer \#2 的本機程式碼基底的狀態。

![合併式遷移](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a>選項2：更新上次遷移中的模型快照集

此選項與選項1非常類似，但會移除額外的空白遷移，因為我們在其方案中想要有額外程式碼檔案的人臉。

**只有當最新的遷移只存在於您的本機程式碼基底，而且尚未提交至原始檔控制（例如，如果最後一個遷移是由執行合併的使用者所產生）時，這個方法才可行**。 編輯其他開發人員可能已套用至其開發資料庫的遷移中繼資料（或更糟的是，套用至生產資料庫）可能會導致非預期的副作用。 在此過程中，我們將復原本機資料庫中的最後一次遷移，並使用更新的中繼資料重新套用它。

雖然最後一次的遷移只需要在本機程式碼基底中，但繼續進行的遷移數目或順序沒有任何限制。 有多個不同的開發人員可以進行多個遷移，而且也適用相同的步驟–我們剛剛看過兩個，讓它保持簡單。

下列程式可用於這種方法，從您發現需要從原始檔控制同步處理的時間開始。

1.  請確定您的本機程式碼基底中任何暫止的模型變更已寫入到遷移。 此步驟可確保您在產生空白遷移時，不會遺漏任何合法的變更。
2.  與原始檔控制同步。
3.  執行 [**更新-資料庫**] 以套用其他開發人員已簽入的任何新遷移。
    **_注意：_** *如果您未收到來自 Update-Database 命令的任何警告，則不會有其他開發人員的新遷移，也不需要執行任何進一步的合併。*
4.  執行**TargetMigration &lt;second\_上一次\_遷移&gt;** （在此範例中，這會是**Update-Database – TargetMigration AddRating**）。 如此一來，資料庫就會回到第二個上一次遷移的狀態–有效地「取消套用」最後一次從資料庫進行的遷移。
    **_注意：_** 您*必須執行此步驟，才能安全地編輯遷移的中繼資料，因為中繼資料也會儲存在資料庫的 \_\_MigrationsHistoryTable 中。這就是為什麼只有在您的本機程式碼基底中進行最後一次遷移時，才應該使用此選項。如果其他資料庫已套用最後一項部署，您也必須將其復原並重新套用最後一次遷移，以更新中繼資料。* 
5.  執行「**新增-遷移 &lt;完整\_名稱\_包括\_最後\_遷移\_的\_時間戳記&gt;** （在此範例中，我們會將其視為**新增-遷移 201311062215252\_AddReaders**）。
    **_注意：_** *您必須包含時間戳記，讓遷移知道您想要編輯現有的遷移，而不是建立新的。*
    這會更新上次遷移的中繼資料，以符合目前的模型。 當命令完成時，您會收到下列警告，但這正是您想要的結果。 「*只有適用于遷移 ' 201311062215252\_AddReaders ' 的設計工具程式碼已重新 scaffold。若要重新 scaffold 整個遷移，請使用-Force 參數。* 」
6.  執行**更新-資料庫**，以更新的中繼資料重新套用最新的遷移。
7.  繼續開發，或提交至原始檔控制（當然，在執行您的單元測試之後）。

以下是使用這種方法之後，Developer \#2 的本機程式碼基底的狀態。

![更新的中繼資料](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a>摘要

在小組環境中使用 Code First 移轉時，會面臨一些挑戰。 不過，對於遷移運作方式的基本瞭解，以及解決合併衝突的簡單方法，都能讓您輕鬆地克服這些挑戰。

基本問題是儲存在最新的遷移中的中繼資料不正確。 這會導致 Code First 不正確地偵測到目前的模型和資料庫架構不相符，也不會在下一次遷移時 scaffold 不正確的程式碼。 藉由使用正確的模型產生空白的遷移，或在最新的遷移中更新中繼資料，即可克服這種情況。
