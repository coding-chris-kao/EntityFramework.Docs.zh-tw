---
title: 小組環境中的 Code First 移轉-EF6
description: Entity Framework 6 中的 Team 環境 Code First 移轉
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
uid: ef6/modeling/code-first/migrations/teams
ms.openlocfilehash: ec382ecb0b7c99e57447ee50119fc3699fe1f324
ms.sourcegitcommit: 7c3939504bb9da3f46bea3443638b808c04227c2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/09/2020
ms.locfileid: "89617044"
---
# <a name="code-first-migrations-in-team-environments"></a>小組環境中的 Code First 移轉
> [!NOTE]
> 本文假設您知道如何在基本案例中使用 Code First 移轉。 如果您沒有這麼做，就必須先閱讀 [Code First 移轉](xref:ef6/modeling/code-first/migrations/index) ，再繼續進行操作。

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a>拿咖啡，您需要閱讀這篇文章

當兩位開發人員在其本機程式碼基底中產生了遷移時，team 環境中的問題大多是在合併遷移時所致。 雖然解決這些問題的步驟很簡單，但卻需要您清楚瞭解遷移的運作方式。 不要直接跳到結尾，請花時間閱讀整篇文章，以確保您的成功。

## <a name="some-general-guidelines"></a>一些一般指導方針

在我們深入瞭解如何管理多個開發人員所產生的合併遷移之前，以下是一些設定成功的一般指導方針。

### <a name="each-team-member-should-have-a-local-development-database"></a>每個小組成員都應該有本機開發資料庫

遷移會使用** \_ \_ >migrationshistory**資料表來儲存已套用至資料庫的遷移。 如果您有多個開發人員在嘗試以相同的資料庫為目標時，產生不同的遷移 (並且共用** \_ \_ >migrationshistory**資料表，) 遷移會令人困惑。

當然，如果您有不會產生遷移的小組成員，則不會有共用中央開發資料庫的問題。

### <a name="avoid-automatic-migrations"></a>避免自動遷移

最重要的是，自動遷移一開始在小組環境中看起來很不錯，但事實上它們並不適用。 如果您想要知道原因，請繼續閱讀–如果沒有，您可以跳到下一節。

自動遷移可讓您更新資料庫架構，以符合目前的模型，而不需要產生程式碼檔 (以程式碼為基礎的遷移) 。 如果您只是使用它們，而且永遠不會產生任何以程式碼為基礎的遷移，則在小組環境中自動遷移會非常順利。 問題在於，自動遷移會受到限制，且不會處理一些作業–屬性/資料行重新命名、將資料移到另一個資料表等。為了處理這些案例，您最後會產生以程式碼為基礎的遷移 (和編輯 scaffold 程式碼) ，而這些變更會在自動遷移所處理的變更之間混合。 這使得當兩位開發人員簽入遷移時，不可能合併變更。

## <a name="screencasts"></a>螢幕錄製影片

如果您想要觀看螢幕錄製影片，而不是閱讀本文，下列兩段影片涵蓋與本文相同的內容。

### <a name="video-one-migrations---under-the-hood"></a>影片1：「正在進行的遷移-幕後」

[此螢幕錄製影片](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) 涵蓋了遷移如何追蹤和使用模型的相關資訊，以偵測模型變更。

### <a name="video-two-migrations---team-environments"></a>影片二：「遷移-團隊環境」

以上一段影片的概念為基礎， [此螢幕錄製影片](https://channel9.msdn.com/blogs/ef/migrations-team-environments) 涵蓋了在小組環境中發生的問題，以及如何解決這些問題。

## <a name="understanding-how-migrations-works"></a>瞭解遷移的運作方式

在小組環境中成功使用遷移的關鍵是瞭解遷移如何追蹤和使用模型相關資訊來偵測模型變更的基本概念。

### <a name="the-first-migration"></a>第一次遷移

當您新增第一次遷移至專案時，您會先在封裝管理員主控台中執行類似「 **新增-遷移** 」的專案。 此命令所執行的高階步驟如下圖所示。

![第一次遷移](~/ef6/media/firstmigration.png)

目前的模型是從您的程式碼 (1) 計算而來。 然後，模型會計算所需的資料庫物件 (2) ，因為這是第一次遷移模型不同的是，它只會使用空白的模型進行比較。 必要的變更會傳遞至程式碼產生器，以建立所需的遷移程式碼 (3) 然後新增至 Visual Studio 解決方案 (4) 。

除了儲存在主要程式碼檔案中的實際遷移程式碼，遷移也會產生一些額外的程式碼後端檔案。 這些檔案是由遷移所使用的中繼資料，並不是您應該編輯的內容。 其中一個檔案是 ( .resx) 的資源檔，其中包含在產生遷移時模型的快照集。 在下一個步驟中，您將會看到其使用方式。

此時您可能會執行 **更新資料庫** ，以將變更套用至資料庫，然後執行應用程式的其他區域。

### <a name="subsequent-migrations"></a>後續的遷移

稍後您會回頭對模型進行一些變更–在我們的範例中，我們會將 **Url** 屬性新增至 **Blog**。 然後，您會發出一個命令，例如「 **新增-遷移 AddUrl** 來 scaffold 遷移，以套用對應的資料庫變更。 此命令所執行的高階步驟如下圖所示。

![第二個遷移](~/ef6/media/secondmigration.png)

和最後一次一樣，目前的模型是從程式碼 (1) 計算而來。 不過，這次有現有的遷移，所以會從最新的遷移 (2) 抓取先前的模型。 這兩個模型的差異化是找出 (3) 所需的資料庫變更，然後程式就會像之前一樣完成。

此相同程式用於您新增至專案的任何進一步的遷移。

### <a name="why-bother-with-the-model-snapshot"></a>為何要使用模型快照集？

您可能想知道為什麼 EF bothers 使用模型快照集的原因，而不只是查看資料庫。 如果是，請繼續閱讀。 如果您不感興趣，則可以略過本節。

EF 會保留模型快照集的原因有很多：

-   它可讓您的資料庫與 EF 模型漂移。 您可以直接在資料庫中進行這些變更，也可以變更您的遷移中的 scaffold 程式碼來進行變更。 以下是一些練習的範例：
    -   您想要將已插入和更新的資料行新增至一或多個資料表，但不想在 EF 模型中包含這些資料行。 如果遷移已查看資料庫，則每次您 scaffold 遷移時都會持續嘗試卸載這些資料行。 使用模型快照集時，EF 只會偵測到模型的合法變更。
    -   您想要變更用於更新之預存程式的主體，以包含一些記錄。 如果是從資料庫中查看這個預存程式，則會持續嘗試並將它重設回 EF 所預期的定義。 藉由使用模型快照集，當您在 EF 模型中變更程式的圖形時，EF 只會 scaffold 程式碼來改變預存程式。
    -   這些相同的原則適用于新增額外的索引，包括您資料庫中的額外資料表、將 EF 對應到位於資料表等的資料庫檢視。
-   EF 模型所包含的不只是資料庫的圖形。 擁有整個模型可讓遷移查看您模型中屬性和類別的相關資訊，以及它們如何對應到資料行和資料表。 這項資訊可讓您在 scaffold 的程式碼中更聰明地進行遷移。 例如，如果您將屬性所對應的資料行名稱變更為 [遷移]，就可以藉由看到 [重新命名]，方法是查看它是否為相同的屬性，如果您只有資料庫架構，就不能完成此操作。 

## <a name="what-causes-issues-in-team-environments"></a>造成 team 環境問題的原因

當您是在應用程式上工作的單一開發人員時，上一節所涵蓋的工作流程效果良好。 如果您是對模型進行變更的唯一人員，也可以在小組環境中順利運作。 在此案例中，您可以進行模型變更、產生遷移，並將其提交至您的原始檔控制。 其他開發人員可以同步您的變更，並執行 **更新資料庫** 以套用架構變更。

當您有多位開發人員對 EF 模型進行變更，並同時提交至原始檔控制時，就會開始發生問題。 EF 缺乏的第一種方法是將您的本機遷移與其他開發人員在您上次同步處理後已提交至原始檔控制的遷移合併。

## <a name="an-example-of-a-merge-conflict"></a>合併衝突的範例

首先讓我們看看這類合併衝突的具體範例。 我們將繼續進行我們稍早所探討的範例。 作為起點，讓我們假設原始開發人員已簽入上一節的變更。 我們會在對程式碼基底進行變更時，追蹤兩位開發人員。

我們將透過一些變更來追蹤 EF 模型和遷移。 針對起點，這兩個開發人員都已同步處理至原始檔控制存放庫，如下圖所示。

![起點](~/ef6/media/startingpoint.png)

Developer \# 1 和 developer \# 2 現在會在其本機程式碼基底中對 EF 模型進行一些變更。 Developer \# 1 會將 **評** 等屬性新增至 **Blog** ，並產生 **AddRating** 遷移來將變更套用到資料庫。 Developer \# 2 會將 **讀取器** 屬性新增至 **Blog** –並產生對應的 **AddReaders** 遷移。 這兩個開發人員都會執行 **更新資料庫**，以將變更套用至其本機資料庫，然後繼續開發應用程式。

> [!NOTE]
> 遷移的開頭會加上時間戳記，因此我們的圖形代表從 \# 開發人員 1 AddRating 遷移之後，開發人員2的 AddReaders 遷移 \# 。 無論開發人員 \# 1 或 \# 2 是否先產生遷移，都不會與小組中工作的問題產生任何差異，或是合併這些問題的程式，我們將在下一節中討論。

![本機變更](~/ef6/media/localchanges.png)

這是開發人員1的幸運日子， \# 因為他們必須先提交變更。 因為在同步處理存放庫之後，沒有其他人簽入，所以可以直接提交變更，而不需要執行任何合併。

![提交變更](~/ef6/media/submit.png)

現在可以開始提交開發人員 \# 2。 這些都沒那麼幸運。 由於其他人已在同步處理後提交變更，因此需要提取變更併合並。 原始檔控制系統可能會自動合併程式碼層級的變更，因為這些變更很簡單。 在同步處理之後，Developer \# 2 本機儲存機制的狀態如下圖所示。 

![從原始檔控制提取](~/ef6/media/pull.png)

在這個階段，Developer \# 2 可以執行 **更新資料庫** ，以偵測尚未套用至 Developer 2 資料庫) 的新 **AddRating** 遷移 (\# ，並加以套用。 現在 **評** 等資料行會加入至 **blog** 資料表，且資料庫會與模型同步。

但有幾個問題：

1.  雖然 **更新資料庫** 會套用 **AddRating** 遷移，但它也會引發警告： *因為有暫止的變更且已停用自動遷移，所以無法更新資料庫以符合目前的模型 ...*
    問題在於最後一個遷移 (**AddReader**) 中所儲存的模型快照集遺漏了**Blog** (的**評**等屬性，因為它不是在產生) 時模型的一部分。 Code First 偵測到最後一個遷移中的模型不符合目前的模型，並引發警告。
2.  執行應用程式會導致 InvalidOperationException，指出「*支援 ' BloggingCoNtext ' 內容的模型在建立資料庫之後已經變更。請考慮使用 Code First 移轉更新資料庫 ...* 」
    同樣地，問題是最後一個遷移所儲存的模型快照集不符合目前的模型。
3.  最後，由於沒有任何變更要套用至資料庫) ，因此我們預期現在會執行「 **新增遷移** 」來產生空白的遷移 (。 但是，由於遷移會將目前的模型與最後一個遷移中的模型進行比較 (但缺少 **評** 等屬性) 它會實際 scaffold 另一個 **AddColumn** 呼叫，以新增至 [ **評** 等] 資料行。 當然，這項遷移會在 **更新資料庫** 期間失敗，因為 **評** 等資料行已經存在。

## <a name="resolving-the-merge-conflict"></a>解決合併衝突

好消息是，如果您已瞭解遷移的運作方式，就不太難手動處理合併。 如果您跳過這個區段， 很抱歉，您必須先回頭閱讀本文的其餘部分！

有兩個選項，最簡單的方法是產生空白的遷移，以將目前的模型做為快照集。 第二個選項是在上一次遷移時更新快照集，以取得正確的模型快照集。 第二個選項比較困難，而且無法在每個案例中使用，但它也很簡潔，因為它不需要新增額外的遷移。

### <a name="option-1-add-a-blank-merge-migration"></a>選項1：新增空白的「合併」遷移

在此選項中，我們只會產生空白遷移，以確保最新的遷移會儲存正確的模型快照集。

您可以使用此選項，無論是誰產生上一次的遷移。 在此範例中，我們已遵循開發人員 \# 2 來處理合併，並在產生最後的遷移。 但是，如果開發人員 \# 1 產生最後的遷移，則可以使用這些相同的步驟。 如果牽涉到多個遷移，則也適用這些步驟–我們只是查看兩個，以保持簡易。

下列程式可用於這種方法，從您發現需要從原始檔控制同步處理的時間開始。

1.  確定您的本機程式碼基底中任何暫止的模型變更已寫入至遷移。 此步驟可確保您在產生空白遷移的時候，不會錯過任何合法的變更。
2.  與原始檔控制同步。
3.  執行 **更新-資料庫** 以套用其他開發人員已簽入的任何新的遷移。
    **_注意：_** *如果您沒有從 Update-Database 命令得到任何警告，則不會從其他開發人員進行任何新的遷移，也不需要執行任何進一步的合併。*
4.  執行 **新增-遷移 &lt; 挑選 \_ \_ 名稱 &gt; – IgnoreChanges** (例如， **新增-遷移 Merge – IgnoreChanges**) 。 這會產生一個包含所有中繼資料的遷移 (包括目前模型的快照集) 但是在比較目前的模型與最後一個遷移中的快照集時，將會忽略它所偵測到的任何變更 (這表示您會) 取得空白的 **向上** 和 **向下** 方法。
5.  執行 **更新-資料庫** ，以使用更新的中繼資料重新套用最新的遷移。
6.  執行課程) 的單元測試之後，繼續開發或提交至原始檔控制 (。

以下是 \# 使用這種方法之後，開發人員2的本機程式碼基底的狀態。

![合併式遷移](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a>選項2：在上一次遷移時更新模型快照集

此選項與選項1非常類似，但會移除額外的空白遷移–因為讓我們看看它，他想要在解決方案中有額外的程式碼檔案。

**只有在最新的遷移只存在於您的本機程式碼基底，而且尚未提交至原始檔控制 (（例如，如果執行合併) 的使用者所產生的最後一個遷移）時，此方法才可行 **。 編輯其他開發人員可能已套用至其開發資料庫的遷移中繼資料（甚至更糟的是套用至實際執行的資料庫），可能會導致非預期的副作用。 在此過程中，我們將會復原本機資料庫中的最後一個遷移，並以更新的中繼資料重新套用。

雖然最後一次的遷移必須是在本機程式碼基底中，否則繼續進行的遷移數目或順序沒有任何限制。 您可以從多個不同的開發人員進行多個遷移，並套用相同的步驟-我們剛剛看過兩個，以保持簡單。

下列程式可用於這種方法，從您發現需要從原始檔控制同步處理的時間開始。

1.  確定您的本機程式碼基底中任何暫止的模型變更已寫入至遷移。 此步驟可確保您在產生空白遷移的時候，不會錯過任何合法的變更。
2.  與原始檔控制同步。
3.  執行 **更新-資料庫** 以套用其他開發人員已簽入的任何新的遷移。
    **_注意：_** *如果您沒有從 Update-Database 命令得到任何警告，則不會從其他開發人員進行任何新的遷移，也不需要執行任何進一步的合併。*
4.  執行**更新-資料庫-TargetMigration &lt; 第二 \_ 次的 \_ 遷移 &gt; ** (在我們接下來的範例中，我們將會**更新資料庫– TargetMigration AddRating**) 。 這會將資料庫復原到第二個遷移的狀態：有效地「取消套用」資料庫的最後一次遷移。
    **_注意：_** 您*必須執行此步驟，才能安全地編輯遷移的中繼資料，因為中繼資料也會儲存在 \_ \_ 資料庫的 MigrationsHistoryTable 中。這就是為什麼只有在您的本機程式碼基底中進行最後一次遷移時，才應該使用此選項。如果其他資料庫已套用最後的遷移，您也必須將它們回復並重新套用最後的遷移，以更新中繼資料。* 
5.  執行**新增-遷移的 &lt; 完整 \_ 名稱， \_ 包括 \_ \_ \_ 上次 \_ 遷移的時間戳記** &gt; (在我們接下來的範例中，這會是類似**新增-遷移 201311062215252 \_ AddReaders**) 的內容。
    **_注意：_** *您必須包含時間戳記，讓遷移知道您想要編輯現有的遷移，而不是新的。*
    這會更新上次遷移的中繼資料，以符合目前的模型。 當命令完成時，您會收到下列警告，但這正是您想要的結果。 「*只重新 scaffold 遷移 ' 201311062215252 AddReaders ' 的設計工具程式碼 \_ 。若要重新 scaffold 整個遷移，請使用-Force 參數。* 」
6.  執行 **更新-資料庫** ，以使用更新的中繼資料重新套用最新的遷移。
7.  執行課程) 的單元測試之後，繼續開發或提交至原始檔控制 (。

以下是 \# 使用這種方法之後，開發人員2的本機程式碼基底的狀態。

![更新的中繼資料](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a>摘要

在小組環境中使用 Code First 移轉時，會有一些挑戰。 不過，對於遷移的運作方式有基本的瞭解，以及解決合併衝突的一些簡單方法，可讓您輕鬆克服這些挑戰。

基本問題是儲存在最新的遷移中的中繼資料不正確。 這會導致 Code First 錯誤地偵測到目前的模型和資料庫架構不相符，並在下一個遷移中 scaffold 不正確的程式碼。 這種情況的解決方法是使用正確的模型來產生空白的遷移，或在最新的遷移中更新中繼資料。
