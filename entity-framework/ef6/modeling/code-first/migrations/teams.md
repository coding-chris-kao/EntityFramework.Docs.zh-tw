---
title: 小組環境中的 Code First 移轉-EF6
description: Entity Framework 6 中的 Team 環境 Code First 移轉
author: divega
ms.date: 10/23/2016
uid: ef6/modeling/code-first/migrations/teams
ms.openlocfilehash: c3f12788f2aba85f54dc062bdb6a7919be47b56d
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/14/2020
ms.locfileid: "90072222"
---
# <a name="code-first-migrations-in-team-environments"></a><span data-ttu-id="621ef-103">小組環境中的 Code First 移轉</span><span class="sxs-lookup"><span data-stu-id="621ef-103">Code First Migrations in Team Environments</span></span>
> [!NOTE]
> <span data-ttu-id="621ef-104">本文假設您知道如何在基本案例中使用 Code First 移轉。</span><span class="sxs-lookup"><span data-stu-id="621ef-104">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="621ef-105">如果您沒有這麼做，就必須先閱讀 [Code First 移轉](xref:ef6/modeling/code-first/migrations/index) ，再繼續進行操作。</span><span class="sxs-lookup"><span data-stu-id="621ef-105">If you don’t, then you’ll need to read [Code First Migrations](xref:ef6/modeling/code-first/migrations/index) before continuing.</span></span>

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a><span data-ttu-id="621ef-106">拿咖啡，您需要閱讀這篇文章</span><span class="sxs-lookup"><span data-stu-id="621ef-106">Grab a coffee, you need to read this whole article</span></span>

<span data-ttu-id="621ef-107">當兩位開發人員在其本機程式碼基底中產生了遷移時，team 環境中的問題大多是在合併遷移時所致。</span><span class="sxs-lookup"><span data-stu-id="621ef-107">The issues in team environments are mostly around merging migrations when two developers have generated migrations in their local code base.</span></span> <span data-ttu-id="621ef-108">雖然解決這些問題的步驟很簡單，但卻需要您清楚瞭解遷移的運作方式。</span><span class="sxs-lookup"><span data-stu-id="621ef-108">While the steps to solve these are pretty simple, they require you to have a solid understanding of how migrations works.</span></span> <span data-ttu-id="621ef-109">不要直接跳到結尾，請花時間閱讀整篇文章，以確保您的成功。</span><span class="sxs-lookup"><span data-stu-id="621ef-109">Please don’t just skip ahead to the end – take the time to read the whole article to ensure you are successful.</span></span>

## <a name="some-general-guidelines"></a><span data-ttu-id="621ef-110">一些一般指導方針</span><span class="sxs-lookup"><span data-stu-id="621ef-110">Some general guidelines</span></span>

<span data-ttu-id="621ef-111">在我們深入瞭解如何管理多個開發人員所產生的合併遷移之前，以下是一些設定成功的一般指導方針。</span><span class="sxs-lookup"><span data-stu-id="621ef-111">Before we dig into how to manage merging migrations generated by multiple developers, here are some general guidelines to set you up for success.</span></span>

### <a name="each-team-member-should-have-a-local-development-database"></a><span data-ttu-id="621ef-112">每個小組成員都應該有本機開發資料庫</span><span class="sxs-lookup"><span data-stu-id="621ef-112">Each team member should have a local development database</span></span>

<span data-ttu-id="621ef-113">遷移會使用\*\* \_ \_ >migrationshistory\*\*資料表來儲存已套用至資料庫的遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-113">Migrations uses the **\_\_MigrationsHistory** table to store what migrations have been applied to the database.</span></span> <span data-ttu-id="621ef-114">如果您有多個開發人員在嘗試以相同的資料庫為目標時，產生不同的遷移 (並且共用\*\* \_ \_ >migrationshistory\*\*資料表，) 遷移會令人困惑。</span><span class="sxs-lookup"><span data-stu-id="621ef-114">If you have multiple developers generating different migrations while trying to target the same database (and thus share a **\_\_MigrationsHistory** table) migrations is going to get very confused.</span></span>

<span data-ttu-id="621ef-115">當然，如果您有不會產生遷移的小組成員，則不會有共用中央開發資料庫的問題。</span><span class="sxs-lookup"><span data-stu-id="621ef-115">Of course, if you have team members that aren’t generating migrations, there is no problem having them share a central development database.</span></span>

### <a name="avoid-automatic-migrations"></a><span data-ttu-id="621ef-116">避免自動遷移</span><span class="sxs-lookup"><span data-stu-id="621ef-116">Avoid automatic migrations</span></span>

<span data-ttu-id="621ef-117">最重要的是，自動遷移一開始在小組環境中看起來很不錯，但事實上它們並不適用。</span><span class="sxs-lookup"><span data-stu-id="621ef-117">The bottom line is that automatic migrations initially look good in team environments, but in reality they just don’t work.</span></span> <span data-ttu-id="621ef-118">如果您想要知道原因，請繼續閱讀–如果沒有，您可以跳到下一節。</span><span class="sxs-lookup"><span data-stu-id="621ef-118">If you want to know why, keep reading – if not, then you can skip to the next section.</span></span>

<span data-ttu-id="621ef-119">自動遷移可讓您更新資料庫架構，以符合目前的模型，而不需要產生程式碼檔 (以程式碼為基礎的遷移) 。</span><span class="sxs-lookup"><span data-stu-id="621ef-119">Automatic migrations allows you to have your database schema updated to match the current model without the need to generate code files (code-based migrations).</span></span> <span data-ttu-id="621ef-120">如果您只是使用它們，而且永遠不會產生任何以程式碼為基礎的遷移，則在小組環境中自動遷移會非常順利。</span><span class="sxs-lookup"><span data-stu-id="621ef-120">Automatic migrations would work very well in a team environment if you only ever used them and never generated any code-based migrations.</span></span> <span data-ttu-id="621ef-121">問題在於，自動遷移會受到限制，且不會處理一些作業–屬性/資料行重新命名、將資料移到另一個資料表等。為了處理這些案例，您最後會產生以程式碼為基礎的遷移 (和編輯 scaffold 程式碼) ，而這些變更會在自動遷移所處理的變更之間混合。</span><span class="sxs-lookup"><span data-stu-id="621ef-121">The problem is that automatic migrations are limited and don’t handle a number of operations – property/column renames, moving data to another table, etc. To handle these scenarios you end up generating code-based migrations (and editing the scaffolded code) that are mixed in between changes that are handled by automatic migrations.</span></span> <span data-ttu-id="621ef-122">這使得當兩位開發人員簽入遷移時，不可能合併變更。</span><span class="sxs-lookup"><span data-stu-id="621ef-122">This makes it near on impossible to merge changes when two developers check in migrations.</span></span>

## <a name="screencasts"></a><span data-ttu-id="621ef-123">螢幕錄製影片</span><span class="sxs-lookup"><span data-stu-id="621ef-123">Screencasts</span></span>

<span data-ttu-id="621ef-124">如果您想要觀看螢幕錄製影片，而不是閱讀本文，下列兩段影片涵蓋與本文相同的內容。</span><span class="sxs-lookup"><span data-stu-id="621ef-124">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="621ef-125">影片1：「正在進行的遷移-幕後」</span><span class="sxs-lookup"><span data-stu-id="621ef-125">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="621ef-126">[此螢幕錄製影片](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) 涵蓋了遷移如何追蹤和使用模型的相關資訊，以偵測模型變更。</span><span class="sxs-lookup"><span data-stu-id="621ef-126">[This screencast](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---team-environments"></a><span data-ttu-id="621ef-127">影片二：「遷移-團隊環境」</span><span class="sxs-lookup"><span data-stu-id="621ef-127">Video Two: "Migrations - Team Environments"</span></span>

<span data-ttu-id="621ef-128">以上一段影片的概念為基礎， [此螢幕錄製影片](https://channel9.msdn.com/blogs/ef/migrations-team-environments) 涵蓋了在小組環境中發生的問題，以及如何解決這些問題。</span><span class="sxs-lookup"><span data-stu-id="621ef-128">Building on the concepts from the previous video, [this screencast](https://channel9.msdn.com/blogs/ef/migrations-team-environments) covers the issues that arise in a team environment and how to solve them.</span></span>

## <a name="understanding-how-migrations-works"></a><span data-ttu-id="621ef-129">瞭解遷移的運作方式</span><span class="sxs-lookup"><span data-stu-id="621ef-129">Understanding how migrations works</span></span>

<span data-ttu-id="621ef-130">在小組環境中成功使用遷移的關鍵是瞭解遷移如何追蹤和使用模型相關資訊來偵測模型變更的基本概念。</span><span class="sxs-lookup"><span data-stu-id="621ef-130">The key to successfully using migrations in a team environment is a basic understanding how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="the-first-migration"></a><span data-ttu-id="621ef-131">第一次遷移</span><span class="sxs-lookup"><span data-stu-id="621ef-131">The first migration</span></span>

<span data-ttu-id="621ef-132">當您新增第一次遷移至專案時，您會先在封裝管理員主控台中執行類似「 **新增-遷移** 」的專案。</span><span class="sxs-lookup"><span data-stu-id="621ef-132">When you add the first migration to your project, you run something like **Add-Migration First** in Package Manager Console.</span></span> <span data-ttu-id="621ef-133">此命令所執行的高階步驟如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="621ef-133">The high level steps that this command performs are pictured below.</span></span>

![第一次遷移](~/ef6/media/firstmigration.png)

<span data-ttu-id="621ef-135">目前的模型是從您的程式碼 (1) 計算而來。</span><span class="sxs-lookup"><span data-stu-id="621ef-135">The current model is calculated from your code (1).</span></span> <span data-ttu-id="621ef-136">然後，模型會計算所需的資料庫物件 (2) ，因為這是第一次遷移模型不同的是，它只會使用空白的模型進行比較。</span><span class="sxs-lookup"><span data-stu-id="621ef-136">The required database objects are then calculated by the model differ (2) – since this is the first migration the model differ just uses an empty model for the comparison.</span></span> <span data-ttu-id="621ef-137">必要的變更會傳遞至程式碼產生器，以建立所需的遷移程式碼 (3) 然後新增至 Visual Studio 解決方案 (4) 。</span><span class="sxs-lookup"><span data-stu-id="621ef-137">The required changes are passed to the code generator to build the required migration code (3) which is then added to your Visual Studio solution (4).</span></span>

<span data-ttu-id="621ef-138">除了儲存在主要程式碼檔案中的實際遷移程式碼，遷移也會產生一些額外的程式碼後端檔案。</span><span class="sxs-lookup"><span data-stu-id="621ef-138">In addition to the actual migration code that is stored in the main code file, migrations also generates some additional code-behind files.</span></span> <span data-ttu-id="621ef-139">這些檔案是由遷移所使用的中繼資料，並不是您應該編輯的內容。</span><span class="sxs-lookup"><span data-stu-id="621ef-139">These files are metadata that is used by migrations and are not something you should edit.</span></span> <span data-ttu-id="621ef-140">其中一個檔案是 ( .resx) 的資源檔，其中包含在產生遷移時模型的快照集。</span><span class="sxs-lookup"><span data-stu-id="621ef-140">One of these files is a resource file (.resx) that contains a snapshot of the model at the time the migration was generated.</span></span> <span data-ttu-id="621ef-141">在下一個步驟中，您將會看到其使用方式。</span><span class="sxs-lookup"><span data-stu-id="621ef-141">You’ll see how this is used in the next step.</span></span>

<span data-ttu-id="621ef-142">此時您可能會執行 **更新資料庫** ，以將變更套用至資料庫，然後執行應用程式的其他區域。</span><span class="sxs-lookup"><span data-stu-id="621ef-142">At this point you would probably run **Update-Database** to apply your changes to the database, and then go about implementing other areas of your application.</span></span>

### <a name="subsequent-migrations"></a><span data-ttu-id="621ef-143">後續的遷移</span><span class="sxs-lookup"><span data-stu-id="621ef-143">Subsequent migrations</span></span>

<span data-ttu-id="621ef-144">稍後您會回頭對模型進行一些變更–在我們的範例中，我們會將 **Url** 屬性新增至 **Blog**。</span><span class="sxs-lookup"><span data-stu-id="621ef-144">Later you come back and make some changes to your model – in our example we’ll add a **Url** property to **Blog**.</span></span> <span data-ttu-id="621ef-145">然後，您會發出一個命令，例如「 **新增-遷移 AddUrl** 來 scaffold 遷移，以套用對應的資料庫變更。</span><span class="sxs-lookup"><span data-stu-id="621ef-145">You would then issue a command such as **Add-Migration AddUrl** to scaffold a migration to apply the corresponding database changes.</span></span> <span data-ttu-id="621ef-146">此命令所執行的高階步驟如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="621ef-146">The high level steps that this command performs are pictured below.</span></span>

![第二個遷移](~/ef6/media/secondmigration.png)

<span data-ttu-id="621ef-148">和最後一次一樣，目前的模型是從程式碼 (1) 計算而來。</span><span class="sxs-lookup"><span data-stu-id="621ef-148">Just like last time, the current model is calculated from code (1).</span></span> <span data-ttu-id="621ef-149">不過，這次有現有的遷移，所以會從最新的遷移 (2) 抓取先前的模型。</span><span class="sxs-lookup"><span data-stu-id="621ef-149">However, this time there are existing migrations so the previous model is retrieved from the latest migration (2).</span></span> <span data-ttu-id="621ef-150">這兩個模型的差異化是找出 (3) 所需的資料庫變更，然後程式就會像之前一樣完成。</span><span class="sxs-lookup"><span data-stu-id="621ef-150">These two models are diffed to find the required database changes (3) and then the process completes as before.</span></span>

<span data-ttu-id="621ef-151">此相同程式用於您新增至專案的任何進一步的遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-151">This same process is used for any further migrations that you add to the project.</span></span>

### <a name="why-bother-with-the-model-snapshot"></a><span data-ttu-id="621ef-152">為何要使用模型快照集？</span><span class="sxs-lookup"><span data-stu-id="621ef-152">Why bother with the model snapshot?</span></span>

<span data-ttu-id="621ef-153">您可能想知道為什麼 EF bothers 使用模型快照集的原因，而不只是查看資料庫。</span><span class="sxs-lookup"><span data-stu-id="621ef-153">You may be wondering why EF bothers with the model snapshot – why not just look at the database.</span></span> <span data-ttu-id="621ef-154">如果是，請繼續閱讀。</span><span class="sxs-lookup"><span data-stu-id="621ef-154">If so, read on.</span></span> <span data-ttu-id="621ef-155">如果您不感興趣，則可以略過本節。</span><span class="sxs-lookup"><span data-stu-id="621ef-155">If you’re not interested then you can skip this section.</span></span>

<span data-ttu-id="621ef-156">EF 會保留模型快照集的原因有很多：</span><span class="sxs-lookup"><span data-stu-id="621ef-156">There are a number of reasons EF keeps the model snapshot around:</span></span>

-   <span data-ttu-id="621ef-157">它可讓您的資料庫與 EF 模型漂移。</span><span class="sxs-lookup"><span data-stu-id="621ef-157">It allows your database to drift from the EF model.</span></span> <span data-ttu-id="621ef-158">您可以直接在資料庫中進行這些變更，也可以變更您的遷移中的 scaffold 程式碼來進行變更。</span><span class="sxs-lookup"><span data-stu-id="621ef-158">These changes can be made directly in the database, or you can change the scaffolded code in your migrations to make the changes.</span></span> <span data-ttu-id="621ef-159">以下是一些練習的範例：</span><span class="sxs-lookup"><span data-stu-id="621ef-159">Here are a couple of examples of this in practice:</span></span>
    -   <span data-ttu-id="621ef-160">您想要將已插入和更新的資料行新增至一或多個資料表，但不想在 EF 模型中包含這些資料行。</span><span class="sxs-lookup"><span data-stu-id="621ef-160">You want to add an Inserted and Updated to column to one or more of your tables but you don’t want to include these columns in the EF model.</span></span> <span data-ttu-id="621ef-161">如果遷移已查看資料庫，則每次您 scaffold 遷移時都會持續嘗試卸載這些資料行。</span><span class="sxs-lookup"><span data-stu-id="621ef-161">If migrations looked at the database it would continually try to drop these columns every time you scaffolded a migration.</span></span> <span data-ttu-id="621ef-162">使用模型快照集時，EF 只會偵測到模型的合法變更。</span><span class="sxs-lookup"><span data-stu-id="621ef-162">Using the model snapshot, EF will only ever detect legitimate changes to the model.</span></span>
    -   <span data-ttu-id="621ef-163">您想要變更用於更新之預存程式的主體，以包含一些記錄。</span><span class="sxs-lookup"><span data-stu-id="621ef-163">You want to change the body of a stored procedure used for updates to include some logging.</span></span> <span data-ttu-id="621ef-164">如果是從資料庫中查看這個預存程式，則會持續嘗試並將它重設回 EF 所預期的定義。</span><span class="sxs-lookup"><span data-stu-id="621ef-164">If migrations looked at this stored procedure from the database it would continually try and reset it back to the definition that EF expects.</span></span> <span data-ttu-id="621ef-165">藉由使用模型快照集，當您在 EF 模型中變更程式的圖形時，EF 只會 scaffold 程式碼來改變預存程式。</span><span class="sxs-lookup"><span data-stu-id="621ef-165">By using the model snapshot, EF will only ever scaffold code to alter the stored procedure when you change the shape of the procedure in the EF model.</span></span>
    -   <span data-ttu-id="621ef-166">這些相同的原則適用于新增額外的索引，包括您資料庫中的額外資料表、將 EF 對應到位於資料表等的資料庫檢視。</span><span class="sxs-lookup"><span data-stu-id="621ef-166">These same principles apply to adding extra indexes, including extra tables in your database, mapping EF to a database view that sits over a table, etc.</span></span>
-   <span data-ttu-id="621ef-167">EF 模型所包含的不只是資料庫的圖形。</span><span class="sxs-lookup"><span data-stu-id="621ef-167">The EF model contains more than just the shape of the database.</span></span> <span data-ttu-id="621ef-168">擁有整個模型可讓遷移查看您模型中屬性和類別的相關資訊，以及它們如何對應到資料行和資料表。</span><span class="sxs-lookup"><span data-stu-id="621ef-168">Having the entire model allows migrations to look at information about the properties and classes in your model and how they map to the columns and tables.</span></span> <span data-ttu-id="621ef-169">這項資訊可讓您在 scaffold 的程式碼中更聰明地進行遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-169">This information allows migrations to be more intelligent in the code that it scaffolds.</span></span> <span data-ttu-id="621ef-170">例如，如果您將屬性所對應的資料行名稱變更為 [遷移]，就可以藉由看到 [重新命名]，方法是查看它是否為相同的屬性，如果您只有資料庫架構，就不能完成此操作。</span><span class="sxs-lookup"><span data-stu-id="621ef-170">For example, if you change the name of the column that a property maps to migrations can detect the rename by seeing that it’s the same property – something that can’t be done if you only have the database schema.</span></span> 

## <a name="what-causes-issues-in-team-environments"></a><span data-ttu-id="621ef-171">造成 team 環境問題的原因</span><span class="sxs-lookup"><span data-stu-id="621ef-171">What causes issues in team environments</span></span>

<span data-ttu-id="621ef-172">當您是在應用程式上工作的單一開發人員時，上一節所涵蓋的工作流程效果良好。</span><span class="sxs-lookup"><span data-stu-id="621ef-172">The workflow covered in the previous section works great when you are a single developer working on an application.</span></span> <span data-ttu-id="621ef-173">如果您是對模型進行變更的唯一人員，也可以在小組環境中順利運作。</span><span class="sxs-lookup"><span data-stu-id="621ef-173">It also works well in a team environment if you are the only person making changes to the model.</span></span> <span data-ttu-id="621ef-174">在此案例中，您可以進行模型變更、產生遷移，並將其提交至您的原始檔控制。</span><span class="sxs-lookup"><span data-stu-id="621ef-174">In this scenario you can make model changes, generate migrations and submit them to your source control.</span></span> <span data-ttu-id="621ef-175">其他開發人員可以同步您的變更，並執行 **更新資料庫** 以套用架構變更。</span><span class="sxs-lookup"><span data-stu-id="621ef-175">Other developers can sync your changes and run **Update-Database** to have the schema changes applied.</span></span>

<span data-ttu-id="621ef-176">當您有多位開發人員對 EF 模型進行變更，並同時提交至原始檔控制時，就會開始發生問題。</span><span class="sxs-lookup"><span data-stu-id="621ef-176">Issues start to arise when you have multiple developers making changes to the EF model and submitting to source control at the same time.</span></span> <span data-ttu-id="621ef-177">EF 缺乏的第一種方法是將您的本機遷移與其他開發人員在您上次同步處理後已提交至原始檔控制的遷移合併。</span><span class="sxs-lookup"><span data-stu-id="621ef-177">What EF lacks is a first class way to merge your local migrations with migrations that another developer has submitted to source control since you last synced.</span></span>

## <a name="an-example-of-a-merge-conflict"></a><span data-ttu-id="621ef-178">合併衝突的範例</span><span class="sxs-lookup"><span data-stu-id="621ef-178">An example of a merge conflict</span></span>

<span data-ttu-id="621ef-179">首先讓我們看看這類合併衝突的具體範例。</span><span class="sxs-lookup"><span data-stu-id="621ef-179">First let’s look at a concrete example of such a merge conflict.</span></span> <span data-ttu-id="621ef-180">我們將繼續進行我們稍早所探討的範例。</span><span class="sxs-lookup"><span data-stu-id="621ef-180">We’ll continue on with the example we looked at earlier.</span></span> <span data-ttu-id="621ef-181">作為起點，讓我們假設原始開發人員已簽入上一節的變更。</span><span class="sxs-lookup"><span data-stu-id="621ef-181">As a starting point let’s assume the changes from the previous section were checked in by the original developer.</span></span> <span data-ttu-id="621ef-182">我們會在對程式碼基底進行變更時，追蹤兩位開發人員。</span><span class="sxs-lookup"><span data-stu-id="621ef-182">We’ll track two developers as they make changes to code base.</span></span>

<span data-ttu-id="621ef-183">我們將透過一些變更來追蹤 EF 模型和遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-183">We’ll track the EF model and the migrations thru a number of changes.</span></span> <span data-ttu-id="621ef-184">針對起點，這兩個開發人員都已同步處理至原始檔控制存放庫，如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="621ef-184">For a starting point, both developers have synced to the source control repository, as depicted in the following graphic.</span></span>

![起點](~/ef6/media/startingpoint.png)

<span data-ttu-id="621ef-186">Developer \# 1 和 developer \# 2 現在會在其本機程式碼基底中對 EF 模型進行一些變更。</span><span class="sxs-lookup"><span data-stu-id="621ef-186">Developer \#1 and developer \#2 now makes some changes to the EF model in their local code base.</span></span> <span data-ttu-id="621ef-187">Developer \# 1 會將 **評** 等屬性新增至 **Blog** ，並產生 **AddRating** 遷移來將變更套用到資料庫。</span><span class="sxs-lookup"><span data-stu-id="621ef-187">Developer \#1 adds a **Rating** property to **Blog** – and generates an **AddRating** migration to apply the changes to the database.</span></span> <span data-ttu-id="621ef-188">Developer \# 2 會將 **讀取器** 屬性新增至 **Blog** –並產生對應的 **AddReaders** 遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-188">Developer \#2 adds a **Readers** property to **Blog** – and generates the corresponding **AddReaders** migration.</span></span> <span data-ttu-id="621ef-189">這兩個開發人員都會執行 **更新資料庫**，以將變更套用至其本機資料庫，然後繼續開發應用程式。</span><span class="sxs-lookup"><span data-stu-id="621ef-189">Both developers run **Update-Database**, to apply the changes to their local databases, and then continue developing the application.</span></span>

> [!NOTE]
> <span data-ttu-id="621ef-190">遷移的開頭會加上時間戳記，因此我們的圖形代表從 \# 開發人員 1 AddRating 遷移之後，開發人員2的 AddReaders 遷移 \# 。</span><span class="sxs-lookup"><span data-stu-id="621ef-190">Migrations are prefixed with a timestamp, so our graphic represents that the AddReaders migration from Developer \#2 comes after the AddRating migration from Developer \#1.</span></span> <span data-ttu-id="621ef-191">無論開發人員 \# 1 或 \# 2 是否先產生遷移，都不會與小組中工作的問題產生任何差異，或是合併這些問題的程式，我們將在下一節中討論。</span><span class="sxs-lookup"><span data-stu-id="621ef-191">Whether developer \#1 or \#2 generated the migration first makes no difference to the issues of working in a team, or the process for merging them that we’ll look at in the next section.</span></span>

![本機變更](~/ef6/media/localchanges.png)

<span data-ttu-id="621ef-193">這是開發人員1的幸運日子， \# 因為他們必須先提交變更。</span><span class="sxs-lookup"><span data-stu-id="621ef-193">It’s a lucky day for Developer \#1 as they happen to submit their changes first.</span></span> <span data-ttu-id="621ef-194">因為在同步處理存放庫之後，沒有其他人簽入，所以可以直接提交變更，而不需要執行任何合併。</span><span class="sxs-lookup"><span data-stu-id="621ef-194">Because no one else has checked in since they synced their repository, they can just submit their changes without performing any merging.</span></span>

![提交變更](~/ef6/media/submit.png)

<span data-ttu-id="621ef-196">現在可以開始提交開發人員 \# 2。</span><span class="sxs-lookup"><span data-stu-id="621ef-196">Now it’s time for Developer \#2 to submit.</span></span> <span data-ttu-id="621ef-197">這些都沒那麼幸運。</span><span class="sxs-lookup"><span data-stu-id="621ef-197">They aren’t so lucky.</span></span> <span data-ttu-id="621ef-198">由於其他人已在同步處理後提交變更，因此需要提取變更併合並。</span><span class="sxs-lookup"><span data-stu-id="621ef-198">Because someone else has submitted changes since they synced, they will need to pull down the changes and merge.</span></span> <span data-ttu-id="621ef-199">原始檔控制系統可能會自動合併程式碼層級的變更，因為這些變更很簡單。</span><span class="sxs-lookup"><span data-stu-id="621ef-199">The source control system will likely be able to automatically merge the changes at the code level since they are very simple.</span></span> <span data-ttu-id="621ef-200">在同步處理之後，Developer \# 2 本機儲存機制的狀態如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="621ef-200">The state of Developer \#2’s local repository after syncing is depicted in the following graphic.</span></span> 

![從原始檔控制提取](~/ef6/media/pull.png)

<span data-ttu-id="621ef-202">在這個階段，Developer \# 2 可以執行 **更新資料庫** ，以偵測尚未套用至 Developer 2 資料庫) 的新 **AddRating** 遷移 (\# ，並加以套用。</span><span class="sxs-lookup"><span data-stu-id="621ef-202">At this stage Developer \#2 can run **Update-Database** which will detect the new **AddRating** migration (which hasn’t been applied to Developer \#2’s database) and apply it.</span></span> <span data-ttu-id="621ef-203">現在 **評** 等資料行會加入至 **blog** 資料表，且資料庫會與模型同步。</span><span class="sxs-lookup"><span data-stu-id="621ef-203">Now the **Rating** column is added to the **Blogs** table and the database is in sync with the model.</span></span>

<span data-ttu-id="621ef-204">但有幾個問題：</span><span class="sxs-lookup"><span data-stu-id="621ef-204">There are a couple of problems though:</span></span>

1.  <span data-ttu-id="621ef-205">雖然 **更新資料庫** 會套用 **AddRating** 遷移，但它也會引發警告： *因為有暫止的變更且已停用自動遷移，所以無法更新資料庫以符合目前的模型 ...*</span><span class="sxs-lookup"><span data-stu-id="621ef-205">Although **Update-Database** will apply the **AddRating** migration it will also raise a warning: *Unable to update database to match the current model because there are pending changes and automatic migration is disabled…*</span></span>
    <span data-ttu-id="621ef-206">問題在於最後一個遷移 (**AddReader**) 中所儲存的模型快照集遺漏了**Blog** (的**評**等屬性，因為它不是在產生) 時模型的一部分。</span><span class="sxs-lookup"><span data-stu-id="621ef-206">The problem is that the model snapshot stored in the last migration (**AddReader**) is missing the **Rating** property on **Blog** (since it wasn’t part of the model when the migration was generated).</span></span> <span data-ttu-id="621ef-207">Code First 偵測到最後一個遷移中的模型不符合目前的模型，並引發警告。</span><span class="sxs-lookup"><span data-stu-id="621ef-207">Code First detects that the model in the last migration doesn’t match the current model and raises the warning.</span></span>
2.  <span data-ttu-id="621ef-208">執行應用程式會導致 InvalidOperationException，指出「*支援 ' BloggingCoNtext ' 內容的模型在建立資料庫之後已經變更。請考慮使用 Code First 移轉更新資料庫 ...* 」</span><span class="sxs-lookup"><span data-stu-id="621ef-208">Running the application would result in an InvalidOperationException stating that “*The model backing the 'BloggingContext' context has changed since the database was created. Consider using Code First Migrations to update the database…”*</span></span>
    <span data-ttu-id="621ef-209">同樣地，問題是最後一個遷移所儲存的模型快照集不符合目前的模型。</span><span class="sxs-lookup"><span data-stu-id="621ef-209">Again, the problem is the model snapshot stored in the last migration doesn’t match the current model.</span></span>
3.  <span data-ttu-id="621ef-210">最後，由於沒有任何變更要套用至資料庫) ，因此我們預期現在會執行「 **新增遷移** 」來產生空白的遷移 (。</span><span class="sxs-lookup"><span data-stu-id="621ef-210">Finally, we would expect running **Add-Migration** now would generate an empty migration (since there are no changes to apply to the database).</span></span> <span data-ttu-id="621ef-211">但是，由於遷移會將目前的模型與最後一個遷移中的模型進行比較 (但缺少 **評** 等屬性) 它會實際 scaffold 另一個 **AddColumn** 呼叫，以新增至 [ **評** 等] 資料行。</span><span class="sxs-lookup"><span data-stu-id="621ef-211">But because migrations compares the current model to the one from the last migration (which is missing the **Rating** property) it will actually scaffold another **AddColumn** call to add in the **Rating** column.</span></span> <span data-ttu-id="621ef-212">當然，這項遷移會在 **更新資料庫** 期間失敗，因為 **評** 等資料行已經存在。</span><span class="sxs-lookup"><span data-stu-id="621ef-212">Of course, this migration would fail during **Update-Database** because the **Rating** column already exists.</span></span>

## <a name="resolving-the-merge-conflict"></a><span data-ttu-id="621ef-213">解決合併衝突</span><span class="sxs-lookup"><span data-stu-id="621ef-213">Resolving the merge conflict</span></span>

<span data-ttu-id="621ef-214">好消息是，如果您已瞭解遷移的運作方式，就不太難手動處理合併。</span><span class="sxs-lookup"><span data-stu-id="621ef-214">The good news is that it’s not too hard to deal with the merge manually – provided you have an understanding of how migrations works.</span></span> <span data-ttu-id="621ef-215">如果您跳過這個區段，</span><span class="sxs-lookup"><span data-stu-id="621ef-215">So if you’ve skipped ahead to this section…</span></span> <span data-ttu-id="621ef-216">很抱歉，您必須先回頭閱讀本文的其餘部分！</span><span class="sxs-lookup"><span data-stu-id="621ef-216">sorry, you need to go back and read the rest of the article first!</span></span>

<span data-ttu-id="621ef-217">有兩個選項，最簡單的方法是產生空白的遷移，以將目前的模型做為快照集。</span><span class="sxs-lookup"><span data-stu-id="621ef-217">There are two options, the easiest is to generate a blank migration that has the correct current model as a snapshot.</span></span> <span data-ttu-id="621ef-218">第二個選項是在上一次遷移時更新快照集，以取得正確的模型快照集。</span><span class="sxs-lookup"><span data-stu-id="621ef-218">The second option is to update the snapshot in the last migration to have the correct model snapshot.</span></span> <span data-ttu-id="621ef-219">第二個選項比較困難，而且無法在每個案例中使用，但它也很簡潔，因為它不需要新增額外的遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-219">The second option is a little harder and can’t be used in every scenario, but it’s also cleaner because it doesn’t involve adding an extra migration.</span></span>

### <a name="option-1-add-a-blank-merge-migration"></a><span data-ttu-id="621ef-220">選項1：新增空白的「合併」遷移</span><span class="sxs-lookup"><span data-stu-id="621ef-220">Option 1: Add a blank ‘merge’ migration</span></span>

<span data-ttu-id="621ef-221">在此選項中，我們只會產生空白遷移，以確保最新的遷移會儲存正確的模型快照集。</span><span class="sxs-lookup"><span data-stu-id="621ef-221">In this option we generate a blank migration solely for the purpose of making sure the latest migration has the correct model snapshot stored in it.</span></span>

<span data-ttu-id="621ef-222">您可以使用此選項，無論是誰產生上一次的遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-222">This option can be used regardless of who generated the last migration.</span></span> <span data-ttu-id="621ef-223">在此範例中，我們已遵循開發人員 \# 2 來處理合併，並在產生最後的遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-223">In the example we’ve been following Developer \#2 is taking care of the merge and they happened to generate the last migration.</span></span> <span data-ttu-id="621ef-224">但是，如果開發人員 \# 1 產生最後的遷移，則可以使用這些相同的步驟。</span><span class="sxs-lookup"><span data-stu-id="621ef-224">But these same steps can be used if Developer \#1 generated the last migration.</span></span> <span data-ttu-id="621ef-225">如果牽涉到多個遷移，則也適用這些步驟–我們只是查看兩個，以保持簡易。</span><span class="sxs-lookup"><span data-stu-id="621ef-225">The steps also apply if there are multiple migrations involved – we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="621ef-226">下列程式可用於這種方法，從您發現需要從原始檔控制同步處理的時間開始。</span><span class="sxs-lookup"><span data-stu-id="621ef-226">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="621ef-227">確定您的本機程式碼基底中任何暫止的模型變更已寫入至遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-227">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="621ef-228">此步驟可確保您在產生空白遷移的時候，不會錯過任何合法的變更。</span><span class="sxs-lookup"><span data-stu-id="621ef-228">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="621ef-229">與原始檔控制同步。</span><span class="sxs-lookup"><span data-stu-id="621ef-229">Sync with source control.</span></span>
3.  <span data-ttu-id="621ef-230">執行 **更新-資料庫** 以套用其他開發人員已簽入的任何新的遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-230">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="621ef-231">**_注意：_** *如果您沒有從 Update-Database 命令得到任何警告，則不會從其他開發人員進行任何新的遷移，也不需要執行任何進一步的合併。*</span><span class="sxs-lookup"><span data-stu-id="621ef-231">**_Note:_** *if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="621ef-232">執行 **新增-遷移 &lt; 挑選 \_ \_ 名稱 &gt; – IgnoreChanges** (例如， **新增-遷移 Merge – IgnoreChanges**) 。</span><span class="sxs-lookup"><span data-stu-id="621ef-232">Run **Add-Migration &lt;pick\_a\_name&gt; –IgnoreChanges** (for example, **Add-Migration Merge –IgnoreChanges**).</span></span> <span data-ttu-id="621ef-233">這會產生一個包含所有中繼資料的遷移 (包括目前模型的快照集) 但是在比較目前的模型與最後一個遷移中的快照集時，將會忽略它所偵測到的任何變更 (這表示您會) 取得空白的 **向上** 和 **向下** 方法。</span><span class="sxs-lookup"><span data-stu-id="621ef-233">This generates a migration with all the metadata (including a snapshot of the current model) but will ignore any changes it detects when comparing the current model to the snapshot in the last migrations (meaning you get a blank **Up** and **Down** method).</span></span>
5.  <span data-ttu-id="621ef-234">執行 **更新-資料庫** ，以使用更新的中繼資料重新套用最新的遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-234">Run **Update-Database** to re-apply the latest migration with the updated metadata.</span></span>
6.  <span data-ttu-id="621ef-235">執行課程) 的單元測試之後，繼續開發或提交至原始檔控制 (。</span><span class="sxs-lookup"><span data-stu-id="621ef-235">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="621ef-236">以下是 \# 使用這種方法之後，開發人員2的本機程式碼基底的狀態。</span><span class="sxs-lookup"><span data-stu-id="621ef-236">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![合併式遷移](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a><span data-ttu-id="621ef-238">選項2：在上一次遷移時更新模型快照集</span><span class="sxs-lookup"><span data-stu-id="621ef-238">Option 2: Update the model snapshot in the last migration</span></span>

<span data-ttu-id="621ef-239">此選項與選項1非常類似，但會移除額外的空白遷移–因為讓我們看看它，他想要在解決方案中有額外的程式碼檔案。</span><span class="sxs-lookup"><span data-stu-id="621ef-239">This option is very similar to option 1 but removes the extra blank migration – because let’s face it, who wants extra code files in their solution.</span></span>

<span data-ttu-id="621ef-240">\*\*只有在最新的遷移只存在於您的本機程式碼基底，而且尚未提交至原始檔控制 (（例如，如果執行合併) 的使用者所產生的最後一個遷移）時，此方法才可行 \*\*。</span><span class="sxs-lookup"><span data-stu-id="621ef-240">**This approach is only feasible if the latest migration exists only in your local code base and has not yet been submitted to source control (for example, if the last migration was generated by the user doing the merge)**.</span></span> <span data-ttu-id="621ef-241">編輯其他開發人員可能已套用至其開發資料庫的遷移中繼資料（甚至更糟的是套用至實際執行的資料庫），可能會導致非預期的副作用。</span><span class="sxs-lookup"><span data-stu-id="621ef-241">Editing the metadata of migrations that other developers may have already applied to their development database – or even worse applied to a production database – can result in unexpected side effects.</span></span> <span data-ttu-id="621ef-242">在此過程中，我們將會復原本機資料庫中的最後一個遷移，並以更新的中繼資料重新套用。</span><span class="sxs-lookup"><span data-stu-id="621ef-242">During the process we’re going to roll back the last migration in our local database and re-apply it with updated metadata.</span></span>

<span data-ttu-id="621ef-243">雖然最後一次的遷移必須是在本機程式碼基底中，否則繼續進行的遷移數目或順序沒有任何限制。</span><span class="sxs-lookup"><span data-stu-id="621ef-243">While the last migration needs to just be in the local code base there are no restrictions to the number or order of migrations that proceed it.</span></span> <span data-ttu-id="621ef-244">您可以從多個不同的開發人員進行多個遷移，並套用相同的步驟-我們剛剛看過兩個，以保持簡單。</span><span class="sxs-lookup"><span data-stu-id="621ef-244">There can be multiple migrations from multiple different developers and the same steps apply– we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="621ef-245">下列程式可用於這種方法，從您發現需要從原始檔控制同步處理的時間開始。</span><span class="sxs-lookup"><span data-stu-id="621ef-245">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="621ef-246">確定您的本機程式碼基底中任何暫止的模型變更已寫入至遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-246">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="621ef-247">此步驟可確保您在產生空白遷移的時候，不會錯過任何合法的變更。</span><span class="sxs-lookup"><span data-stu-id="621ef-247">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="621ef-248">與原始檔控制同步。</span><span class="sxs-lookup"><span data-stu-id="621ef-248">Sync with the source control.</span></span>
3.  <span data-ttu-id="621ef-249">執行 **更新-資料庫** 以套用其他開發人員已簽入的任何新的遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-249">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="621ef-250">**_注意：_** *如果您沒有從 Update-Database 命令得到任何警告，則不會從其他開發人員進行任何新的遷移，也不需要執行任何進一步的合併。*</span><span class="sxs-lookup"><span data-stu-id="621ef-250">**_Note:_** *if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="621ef-251">執行**更新-資料庫-TargetMigration &lt; 第二 \_ 次的 \_ 遷移 &gt; \*\* (在我們接下來的範例中，我們將會**更新資料庫– TargetMigration AddRating\*\*) 。</span><span class="sxs-lookup"><span data-stu-id="621ef-251">Run **Update-Database –TargetMigration &lt;second\_last\_migration&gt;** (in the example we’ve been following this would be **Update-Database –TargetMigration AddRating**).</span></span> <span data-ttu-id="621ef-252">這會將資料庫復原到第二個遷移的狀態：有效地「取消套用」資料庫的最後一次遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-252">This rolls the database back to the state of the second last migration – effectively ‘un-applying’ the last migration from the database.</span></span>
    <span data-ttu-id="621ef-253">**_注意：_** 您*必須執行此步驟，才能安全地編輯遷移的中繼資料，因為中繼資料也會儲存在 \_ \_ 資料庫的 MigrationsHistoryTable 中。這就是為什麼只有在您的本機程式碼基底中進行最後一次遷移時，才應該使用此選項。如果其他資料庫已套用最後的遷移，您也必須將它們回復並重新套用最後的遷移，以更新中繼資料。*</span><span class="sxs-lookup"><span data-stu-id="621ef-253">**_Note:_** *This step is required to make it safe to edit the metadata of the migration since the metadata is also stored in the \_\_MigrationsHistoryTable of the database. This is why you should only use this option if the last migration is only in your local code base. If other databases had the last migration applied you would also have to roll them back and re-apply the last migration to update the metadata.*</span></span> 
5.  <span data-ttu-id="621ef-254">執行**新增-遷移的 &lt; 完整 \_ 名稱， \_ 包括 \_ \_ \_ 上次 \_ 遷移的時間戳記** &gt; (在我們接下來的範例中，這會是類似**新增-遷移 201311062215252 \_ AddReaders**) 的內容。</span><span class="sxs-lookup"><span data-stu-id="621ef-254">Run **Add-Migration &lt;full\_name\_including\_timestamp\_of\_last\_migration**&gt; (in the example we’ve been following this would be something like **Add-Migration 201311062215252\_AddReaders**).</span></span>
    <span data-ttu-id="621ef-255">**_注意：_** *您必須包含時間戳記，讓遷移知道您想要編輯現有的遷移，而不是新的。*</span><span class="sxs-lookup"><span data-stu-id="621ef-255">**_Note:_** *You need to include the timestamp so that migrations knows you want to edit the existing migration rather than scaffolding a new one.*</span></span>
    <span data-ttu-id="621ef-256">這會更新上次遷移的中繼資料，以符合目前的模型。</span><span class="sxs-lookup"><span data-stu-id="621ef-256">This will update the metadata for the last migration to match the current model.</span></span> <span data-ttu-id="621ef-257">當命令完成時，您會收到下列警告，但這正是您想要的結果。</span><span class="sxs-lookup"><span data-stu-id="621ef-257">You’ll get the following warning when the command completes, but that’s exactly what you want.</span></span> <span data-ttu-id="621ef-258">「*只重新 scaffold 遷移 ' 201311062215252 AddReaders ' 的設計工具程式碼 \_ 。若要重新 scaffold 整個遷移，請使用-Force 參數。* 」</span><span class="sxs-lookup"><span data-stu-id="621ef-258">“*Only the Designer Code for migration '201311062215252\_AddReaders' was re-scaffolded. To re-scaffold the entire migration, use the -Force parameter.”*</span></span>
6.  <span data-ttu-id="621ef-259">執行 **更新-資料庫** ，以使用更新的中繼資料重新套用最新的遷移。</span><span class="sxs-lookup"><span data-stu-id="621ef-259">Run **Update-Database** to re-apply the latest migration with the updated metadata.</span></span>
7.  <span data-ttu-id="621ef-260">執行課程) 的單元測試之後，繼續開發或提交至原始檔控制 (。</span><span class="sxs-lookup"><span data-stu-id="621ef-260">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="621ef-261">以下是 \# 使用這種方法之後，開發人員2的本機程式碼基底的狀態。</span><span class="sxs-lookup"><span data-stu-id="621ef-261">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![更新的中繼資料](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a><span data-ttu-id="621ef-263">摘要</span><span class="sxs-lookup"><span data-stu-id="621ef-263">Summary</span></span>

<span data-ttu-id="621ef-264">在小組環境中使用 Code First 移轉時，會有一些挑戰。</span><span class="sxs-lookup"><span data-stu-id="621ef-264">There are some challenges when using Code First Migrations in a team environment.</span></span> <span data-ttu-id="621ef-265">不過，對於遷移的運作方式有基本的瞭解，以及解決合併衝突的一些簡單方法，可讓您輕鬆克服這些挑戰。</span><span class="sxs-lookup"><span data-stu-id="621ef-265">However, a basic understanding of how migrations works and some simple approaches for resolving merge conflicts make it easy to overcome these challenges.</span></span>

<span data-ttu-id="621ef-266">基本問題是儲存在最新的遷移中的中繼資料不正確。</span><span class="sxs-lookup"><span data-stu-id="621ef-266">The fundamental issue is incorrect metadata stored in the latest migration.</span></span> <span data-ttu-id="621ef-267">這會導致 Code First 錯誤地偵測到目前的模型和資料庫架構不相符，並在下一個遷移中 scaffold 不正確的程式碼。</span><span class="sxs-lookup"><span data-stu-id="621ef-267">This causes Code First to incorrectly detect that the current model and database schema don’t match and to scaffold incorrect code in the next migration.</span></span> <span data-ttu-id="621ef-268">這種情況的解決方法是使用正確的模型來產生空白的遷移，或在最新的遷移中更新中繼資料。</span><span class="sxs-lookup"><span data-stu-id="621ef-268">This situation can be overcome by generating a blank migration with the correct model, or updating the metadata in the latest migration.</span></span>
