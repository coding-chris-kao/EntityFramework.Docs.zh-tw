---
title: Code First 移轉現有的資料庫-EF6
description: Code First 移轉 Entity Framework 6 中的現有資料庫
author: divega
ms.date: 10/23/2016
uid: ef6/modeling/code-first/migrations/existing-database
ms.openlocfilehash: 5dd38f3fb9a59805a9b23b7da5e770995866f715
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/14/2020
ms.locfileid: "90072105"
---
# <a name="code-first-migrations-with-an-existing-database"></a><span data-ttu-id="96fea-103">Code First 移轉現有的資料庫</span><span class="sxs-lookup"><span data-stu-id="96fea-103">Code First Migrations with an existing database</span></span>
> [!NOTE]
> <span data-ttu-id="96fea-104">**Ef 4.3 僅限** ，本頁面所討論的功能、api 等已于 Entity Framework 4.1 中引進。</span><span class="sxs-lookup"><span data-stu-id="96fea-104">**EF4.3 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 4.1.</span></span> <span data-ttu-id="96fea-105">如果您使用的是較早版本，則不適用部分或全部的資訊。</span><span class="sxs-lookup"><span data-stu-id="96fea-105">If you are using an earlier version, some or all of the information does not apply.</span></span>

<span data-ttu-id="96fea-106">本文涵蓋如何使用 Code First 移轉搭配現有的資料庫，而不是由 Entity Framework 所建立。</span><span class="sxs-lookup"><span data-stu-id="96fea-106">This article covers using Code First Migrations with an existing database, one that wasn’t created by Entity Framework.</span></span>

> [!NOTE]
> <span data-ttu-id="96fea-107">本文假設您知道如何在基本案例中使用 Code First 移轉。</span><span class="sxs-lookup"><span data-stu-id="96fea-107">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="96fea-108">如果您沒有這麼做，就必須先閱讀 [Code First 移轉](xref:ef6/modeling/code-first/migrations/index) ，再繼續進行操作。</span><span class="sxs-lookup"><span data-stu-id="96fea-108">If you don’t, then you’ll need to read [Code First Migrations](xref:ef6/modeling/code-first/migrations/index) before continuing.</span></span>

## <a name="screencasts"></a><span data-ttu-id="96fea-109">螢幕錄製影片</span><span class="sxs-lookup"><span data-stu-id="96fea-109">Screencasts</span></span>

<span data-ttu-id="96fea-110">如果您想要觀看螢幕錄製影片，而不是閱讀本文，下列兩段影片涵蓋與本文相同的內容。</span><span class="sxs-lookup"><span data-stu-id="96fea-110">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="96fea-111">影片1：「正在進行的遷移-幕後」</span><span class="sxs-lookup"><span data-stu-id="96fea-111">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="96fea-112">[此螢幕錄製影片](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) 涵蓋了遷移如何追蹤和使用模型的相關資訊，以偵測模型變更。</span><span class="sxs-lookup"><span data-stu-id="96fea-112">[This screencast](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---existing-databases"></a><span data-ttu-id="96fea-113">影片二：「遷移-現有的資料庫」</span><span class="sxs-lookup"><span data-stu-id="96fea-113">Video Two: "Migrations - Existing Databases"</span></span>

<span data-ttu-id="96fea-114">以上一段影片的概念為基礎， [此螢幕錄製影片](https://channel9.msdn.com/blogs/ef/migrations-existing-databases) 涵蓋如何啟用和使用現有資料庫的遷移。</span><span class="sxs-lookup"><span data-stu-id="96fea-114">Building on the concepts from the previous video, [this screencast](https://channel9.msdn.com/blogs/ef/migrations-existing-databases) covers how to enable and use migrations with an existing database.</span></span>

## <a name="step-1-create-a-model"></a><span data-ttu-id="96fea-115">步驟1：建立模型</span><span class="sxs-lookup"><span data-stu-id="96fea-115">Step 1: Create a model</span></span>

<span data-ttu-id="96fea-116">您的第一個步驟將是建立以現有資料庫為目標的 Code First 模型。</span><span class="sxs-lookup"><span data-stu-id="96fea-116">Your first step will be to create a Code First model that targets your existing database.</span></span> <span data-ttu-id="96fea-117">[現有資料庫的 Code First](xref:ef6/modeling/code-first/workflows/existing-database)主題提供有關如何進行此作業的詳細指引。</span><span class="sxs-lookup"><span data-stu-id="96fea-117">The [Code First to an Existing Database](xref:ef6/modeling/code-first/workflows/existing-database) topic provides detailed guidance on how to do this.</span></span>

>[!NOTE]
> <span data-ttu-id="96fea-118">在對需要變更資料庫架構的模型進行任何變更之前，請務必遵循本主題中的其餘步驟。</span><span class="sxs-lookup"><span data-stu-id="96fea-118">It is important to follow the rest of the steps in this topic before making any changes to your model that would require changes to the database schema.</span></span> <span data-ttu-id="96fea-119">下列步驟需要將模型與資料庫架構同步。</span><span class="sxs-lookup"><span data-stu-id="96fea-119">The following steps require the model to be in-sync with the database schema.</span></span>

## <a name="step-2-enable-migrations"></a><span data-ttu-id="96fea-120">步驟2：啟用遷移</span><span class="sxs-lookup"><span data-stu-id="96fea-120">Step 2: Enable Migrations</span></span>

<span data-ttu-id="96fea-121">下一步是啟用遷移。</span><span class="sxs-lookup"><span data-stu-id="96fea-121">The next step is to enable migrations.</span></span> <span data-ttu-id="96fea-122">若要這麼做，您可以在封裝管理員主控台中執行 [ **啟用-遷移** ] 命令。</span><span class="sxs-lookup"><span data-stu-id="96fea-122">You can do this by running the **Enable-Migrations** command in Package Manager Console.</span></span>

<span data-ttu-id="96fea-123">此命令會在您的解決方案中建立名為「遷移」的資料夾，並在其中放置稱為「設定」的單一類別。</span><span class="sxs-lookup"><span data-stu-id="96fea-123">This command will create a folder in your solution called Migrations, and put a single class inside it called Configuration.</span></span> <span data-ttu-id="96fea-124">設定類別可讓您設定應用程式的遷移，您可以在 [Code First 移轉](xref:ef6/modeling/code-first/migrations/index) 主題中找到更多相關資訊。</span><span class="sxs-lookup"><span data-stu-id="96fea-124">The Configuration class is where you configure migrations for your application, you can find out more about it in the [Code First Migrations](xref:ef6/modeling/code-first/migrations/index) topic.</span></span>

## <a name="step-3-add-an-initial-migration"></a><span data-ttu-id="96fea-125">步驟3：新增初始遷移</span><span class="sxs-lookup"><span data-stu-id="96fea-125">Step 3: Add an initial migration</span></span>

<span data-ttu-id="96fea-126">一旦建立並套用至本機資料庫的遷移，您可能也會想要將這些變更套用至其他資料庫。</span><span class="sxs-lookup"><span data-stu-id="96fea-126">Once migrations have been created and applied to the local database you may also want to apply these changes to other databases.</span></span> <span data-ttu-id="96fea-127">例如，您的本機資料庫可能是測試資料庫，而且您最終可能會想要將變更套用至實際執行的資料庫及/或其他開發人員測試資料庫。</span><span class="sxs-lookup"><span data-stu-id="96fea-127">For example, your local database may be a test database and you may ultimately want to also apply the changes to a production database and/or other developers test databases.</span></span> <span data-ttu-id="96fea-128">此步驟有兩個選項，而您應挑選的選項取決於是否有任何其他資料庫的架構是空的，還是目前與本機資料庫的架構相符。</span><span class="sxs-lookup"><span data-stu-id="96fea-128">There are two options for this step and the one you should pick depends whether or not the schema of any other databases is empty or currently matches the schema of the local database.</span></span>

-   <span data-ttu-id="96fea-129">**選項1：使用現有的架構做為起點。**</span><span class="sxs-lookup"><span data-stu-id="96fea-129">**Option One: Use existing schema as starting point.**</span></span> <span data-ttu-id="96fea-130">當未來將套用遷移的其他資料庫時，您應該使用此方法，其架構與您的本機資料庫相同。</span><span class="sxs-lookup"><span data-stu-id="96fea-130">You should use this approach when other databases that migrations will be applied to in the future will have the same schema as your local database currently has.</span></span> <span data-ttu-id="96fea-131">例如，如果您的本機測試資料庫目前與生產資料庫的 v1 相符，您就可以使用此專案，稍後您將會套用這些遷移，以將生產資料庫更新為 v2。</span><span class="sxs-lookup"><span data-stu-id="96fea-131">For example, you might use this if your local test database currently matches v1 of your production database and you will later apply these migrations to update your production database to v2.</span></span>
-   <span data-ttu-id="96fea-132">**選項二：使用空白資料庫作為起點。**</span><span class="sxs-lookup"><span data-stu-id="96fea-132">**Option Two: Use empty database as starting point.**</span></span> <span data-ttu-id="96fea-133">當未來將套用遷移的其他資料庫為空白 (或尚未存在) 時，您應該使用此方法。</span><span class="sxs-lookup"><span data-stu-id="96fea-133">You should use this approach when other databases that migrations will be applied to in the future are empty (or do not exist yet).</span></span> <span data-ttu-id="96fea-134">例如，如果您使用測試資料庫開始開發應用程式，但不使用遷移，而您稍後想要從頭開始建立生產資料庫，則可以使用此設定。</span><span class="sxs-lookup"><span data-stu-id="96fea-134">For example, you might use this if you started developing your application using a test database but without using migrations and you will later want to create a production database from scratch.</span></span>

### <a name="option-one-use-existing-schema-as-a-starting-point"></a><span data-ttu-id="96fea-135">選項1：使用現有的架構做為起點</span><span class="sxs-lookup"><span data-stu-id="96fea-135">Option One: Use existing schema as a starting point</span></span>

<span data-ttu-id="96fea-136">Code First 移轉使用儲存在最近一次遷移中的模型快照集來偵測模型的變更， (您可以在 [Team 環境]) 的 [Code First 移轉中](xref:ef6/modeling/code-first/migrations/teams) 找到此項的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="96fea-136">Code First Migrations uses a snapshot of the model stored in the most recent migration to detect changes to the model (you can find detailed information about this in [Code First Migrations in Team Environments](xref:ef6/modeling/code-first/migrations/teams)).</span></span> <span data-ttu-id="96fea-137">因為我們會假設資料庫已經有目前模型的架構，所以我們會產生空的 (不會) 遷移，並將目前的模型設定為快照集。</span><span class="sxs-lookup"><span data-stu-id="96fea-137">Since we are going to assume that databases already have the schema of the current model, we will generate an empty (no-op) migration that has the current model as a snapshot.</span></span>

1.  <span data-ttu-id="96fea-138">在封裝管理員主控台中，執行 [ **新增-遷移 InitialCreate – IgnoreChanges** ] 命令。</span><span class="sxs-lookup"><span data-stu-id="96fea-138">Run the **Add-Migration InitialCreate –IgnoreChanges** command in Package Manager Console.</span></span> <span data-ttu-id="96fea-139">這會以目前的模型做為快照集來建立空白的遷移。</span><span class="sxs-lookup"><span data-stu-id="96fea-139">This creates an empty migration with the current model as a snapshot.</span></span>
2.  <span data-ttu-id="96fea-140">在封裝管理員主控台中執行 **更新資料庫** 命令。</span><span class="sxs-lookup"><span data-stu-id="96fea-140">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="96fea-141">這會將 InitialCreate 遷移套用至資料庫。</span><span class="sxs-lookup"><span data-stu-id="96fea-141">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="96fea-142">由於實際的遷移不包含任何變更，因此只會在 >migrationshistory 資料表中新增一個資料列，表示已套用 \_ \_ 此遷移。</span><span class="sxs-lookup"><span data-stu-id="96fea-142">Since the actual migration doesn’t contain any changes, it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>

### <a name="option-two-use-empty-database-as-a-starting-point"></a><span data-ttu-id="96fea-143">選項二：使用空白資料庫做為起點</span><span class="sxs-lookup"><span data-stu-id="96fea-143">Option Two: Use empty database as a starting point</span></span>

<span data-ttu-id="96fea-144">在此案例中，我們需要遷移以從頭開始建立整個資料庫，包括已存在於本機資料庫中的資料表。</span><span class="sxs-lookup"><span data-stu-id="96fea-144">In this scenario we need Migrations to be able to create the entire database from scratch – including the tables that are already present in our local database.</span></span> <span data-ttu-id="96fea-145">我們即將產生 InitialCreate 遷移，其中包含建立現有架構的邏輯。</span><span class="sxs-lookup"><span data-stu-id="96fea-145">We’re going to generate an InitialCreate migration that includes logic to create the existing schema.</span></span> <span data-ttu-id="96fea-146">接著，我們會讓現有的資料庫看起來已套用此遷移。</span><span class="sxs-lookup"><span data-stu-id="96fea-146">We’ll then make our existing database look like this migration has already been applied.</span></span>

1.  <span data-ttu-id="96fea-147">在封裝管理員主控台中執行 [ **新增-遷移 InitialCreate** ] 命令。</span><span class="sxs-lookup"><span data-stu-id="96fea-147">Run the **Add-Migration InitialCreate** command in Package Manager Console.</span></span> <span data-ttu-id="96fea-148">這會建立遷移以建立現有的架構。</span><span class="sxs-lookup"><span data-stu-id="96fea-148">This creates a migration to create the existing schema.</span></span>
2.  <span data-ttu-id="96fea-149">將新建立之遷移的 Up 方法中的所有程式碼標記為批註。</span><span class="sxs-lookup"><span data-stu-id="96fea-149">Comment out all code in the Up method of the newly created migration.</span></span> <span data-ttu-id="96fea-150">這可讓我們「套用」至本機資料庫的遷移，而不需要重新建立已存在的所有資料表等等。</span><span class="sxs-lookup"><span data-stu-id="96fea-150">This will allow us to ‘apply’ the migration to the local database without trying to recreate all the tables etc. that already exist.</span></span>
3.  <span data-ttu-id="96fea-151">在封裝管理員主控台中執行 **更新資料庫** 命令。</span><span class="sxs-lookup"><span data-stu-id="96fea-151">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="96fea-152">這會將 InitialCreate 遷移套用至資料庫。</span><span class="sxs-lookup"><span data-stu-id="96fea-152">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="96fea-153">因為實際的遷移不包含任何變更 (因為我們暫時將它們批註) ，所以只會在 >migrationshistory 資料表中新增一個資料列，指出已套用 \_ \_ 此遷移。</span><span class="sxs-lookup"><span data-stu-id="96fea-153">Since the actual migration doesn’t contain any changes (because we temporarily commented them out), it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>
4.  <span data-ttu-id="96fea-154">將 Up 方法中的程式碼取消批註。</span><span class="sxs-lookup"><span data-stu-id="96fea-154">Un-comment the code in the Up method.</span></span> <span data-ttu-id="96fea-155">這表示，當此遷移套用至未來的資料庫時，將會由遷移來建立已存在於本機資料庫中的架構。</span><span class="sxs-lookup"><span data-stu-id="96fea-155">This means that when this migration is applied to future databases, the schema that already existed in the local database will be created by migrations.</span></span>

## <a name="things-to-be-aware-of"></a><span data-ttu-id="96fea-156">注意事項</span><span class="sxs-lookup"><span data-stu-id="96fea-156">Things to be aware of</span></span>

<span data-ttu-id="96fea-157">針對現有的資料庫使用遷移時，您需要注意幾件事。</span><span class="sxs-lookup"><span data-stu-id="96fea-157">There are a few things you need to be aware of when using Migrations against an existing database.</span></span>

### <a name="defaultcalculated-names-may-not-match-existing-schema"></a><span data-ttu-id="96fea-158">預設/計算的名稱可能不符合現有的架構</span><span class="sxs-lookup"><span data-stu-id="96fea-158">Default/calculated names may not match existing schema</span></span>

<span data-ttu-id="96fea-159">在 scaffold 遷移時，遷移會明確指定資料行和資料表的名稱。</span><span class="sxs-lookup"><span data-stu-id="96fea-159">Migrations explicitly specifies names for columns and tables when it scaffolds a migrations.</span></span> <span data-ttu-id="96fea-160">不過，其他資料庫物件則是在套用遷移時，會計算預設名稱的其他資料庫物件。</span><span class="sxs-lookup"><span data-stu-id="96fea-160">However, there are other database objects that Migrations calculates a default name for when applying the migrations.</span></span> <span data-ttu-id="96fea-161">這包括索引和 foreign key 條件約束。</span><span class="sxs-lookup"><span data-stu-id="96fea-161">This includes indexes and foreign key constraints.</span></span> <span data-ttu-id="96fea-162">以現有的架構為目標時，這些計算的名稱可能不符合資料庫中實際存在的名稱。</span><span class="sxs-lookup"><span data-stu-id="96fea-162">When targeting an existing schema, these calculated names may not match what actually exists in your database.</span></span>

<span data-ttu-id="96fea-163">以下是一些您需要注意的範例：</span><span class="sxs-lookup"><span data-stu-id="96fea-163">Here are some examples of when you need to be aware of this:</span></span>

<span data-ttu-id="96fea-164">**如果您在步驟3中使用了 [選項1：使用現有的架構做為起始點]：**</span><span class="sxs-lookup"><span data-stu-id="96fea-164">**If you used ‘Option One: Use existing schema as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="96fea-165">如果模型中的未來變更需要變更或卸載以不同方式命名的其中一個資料庫物件，您將需要修改 scaffold 遷移來指定正確的名稱。</span><span class="sxs-lookup"><span data-stu-id="96fea-165">If future changes in your model require changing or dropping one of the database objects that is named differently, you will need to modify the scaffolded migration to specify the correct name.</span></span> <span data-ttu-id="96fea-166">遷移 Api 有選擇性的 Name 參數，可讓您這樣做。</span><span class="sxs-lookup"><span data-stu-id="96fea-166">The Migrations APIs have an optional Name parameter that allows you to do this.</span></span>
    <span data-ttu-id="96fea-167">例如，您現有的架構可能會有一個具有 BlogId 外鍵資料行的 Post 資料表，且該資料行具有名為 IndexFk BlogId 的索引 \_ 。</span><span class="sxs-lookup"><span data-stu-id="96fea-167">For example, your existing schema may have a Post table with a BlogId foreign key column that has an index named IndexFk\_BlogId.</span></span> <span data-ttu-id="96fea-168">不過，根據預設，遷移會預期此索引必須命名為 IX \_ BlogId。</span><span class="sxs-lookup"><span data-stu-id="96fea-168">However, by default Migrations would expect this index to be named IX\_BlogId.</span></span> <span data-ttu-id="96fea-169">如果您對模型所做的變更會導致卸載此索引，則必須修改 scaffold DropIndex 呼叫以指定 IndexFk \_ BlogId 名稱。</span><span class="sxs-lookup"><span data-stu-id="96fea-169">If you make a change to your model that results in dropping this index, you will need to modify the scaffolded DropIndex call to specify the IndexFk\_BlogId name.</span></span>

<span data-ttu-id="96fea-170">**如果您在步驟3中使用了「選項二：使用空白資料庫作為起點」：**</span><span class="sxs-lookup"><span data-stu-id="96fea-170">**If you used ‘Option Two: Use empty database as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="96fea-171">如果您嘗試執行初始遷移的向下方法 (也就是，針對本機資料庫還原至空的資料庫) 可能會失敗，因為遷移將會嘗試使用不正確的名稱來卸載索引和 foreign key 條件約束。</span><span class="sxs-lookup"><span data-stu-id="96fea-171">Trying to run the Down method of the initial migration (that is, reverting to an empty database) against your local database may fail because Migrations will try to drop indexes and foreign key constraints using the incorrect names.</span></span> <span data-ttu-id="96fea-172">這只會影響您的本機資料庫，因為系統會使用初始遷移的 Up 方法從頭建立其他資料庫。</span><span class="sxs-lookup"><span data-stu-id="96fea-172">This will only affect your local database since other databases will be created from scratch using the Up method of the initial migration.</span></span>
    <span data-ttu-id="96fea-173">如果您想要將現有的本機資料庫降級為空白狀態，您可以藉由卸載資料庫或卸載所有資料表，以手動方式輕鬆地進行。</span><span class="sxs-lookup"><span data-stu-id="96fea-173">If you want to downgrade your existing local database to an empty state it is easiest to do this manually, either by dropping the database or dropping all the tables.</span></span> <span data-ttu-id="96fea-174">在這個初始降級之後，將會使用預設名稱重新建立所有的資料庫物件，因此這個問題不會再次出現。</span><span class="sxs-lookup"><span data-stu-id="96fea-174">After this initial downgrade all database objects will be recreated with the default names, so this issue will not present itself again.</span></span>
-   <span data-ttu-id="96fea-175">如果模型中的未來變更需要變更或卸載以不同方式命名的其中一個資料庫物件，這將無法針對您現有的本機資料庫運作，因為這些名稱不會符合預設值。</span><span class="sxs-lookup"><span data-stu-id="96fea-175">If future changes in your model require changing or dropping one of the database objects that is named differently, this will not work against your existing local database – since the names won’t match the defaults.</span></span> <span data-ttu-id="96fea-176">不過，它會針對「從頭建立」所建立的資料庫運作，因為它們會使用遷移所選擇的預設名稱。</span><span class="sxs-lookup"><span data-stu-id="96fea-176">However, it will work against databases that were created ‘from scratch’ since they will have used the default names chosen by Migrations.</span></span>
    <span data-ttu-id="96fea-177">您可以在本機現有的資料庫上手動進行這些變更，或考慮讓遷移從頭重新建立資料庫，就像在其他電腦上一樣。</span><span class="sxs-lookup"><span data-stu-id="96fea-177">You could either make these changes manually on your local existing database, or consider having Migrations recreate your database from scratch – as it will on other machines.</span></span>
-   <span data-ttu-id="96fea-178">使用初始遷移的 Up 方法所建立的資料庫，可能會與本機資料庫稍有不同，因為會使用計算出的索引和 foreign key 條件約束的預設名稱。</span><span class="sxs-lookup"><span data-stu-id="96fea-178">Databases created using the Up method of your initial migration may differ slightly from the local database since the calculated default names for indexes and foreign key constraints will be used.</span></span> <span data-ttu-id="96fea-179">您最後也可能會有額外的索引，因為在預設情況下，遷移會在外鍵資料行上建立索引，因此在您的原始本機資料庫中可能不會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="96fea-179">You may also end up with extra indexes as Migrations will create indexes on foreign key columns by default – this may not have been the case in your original local database.</span></span>

### <a name="not-all-database-objects-are-represented-in-the-model"></a><span data-ttu-id="96fea-180">並非所有資料庫物件都在模型中表示</span><span class="sxs-lookup"><span data-stu-id="96fea-180">Not all database objects are represented in the model</span></span>

<span data-ttu-id="96fea-181">不是模型一部分的資料庫物件不會由遷移處理。</span><span class="sxs-lookup"><span data-stu-id="96fea-181">Database objects that are not part of your model will not be handled by Migrations.</span></span> <span data-ttu-id="96fea-182">這可能包括視圖、預存程式、許可權、不是模型一部分的資料表、額外的索引等。</span><span class="sxs-lookup"><span data-stu-id="96fea-182">This can include views, stored procedures, permissions, tables that are not part of your model, additional indexes, etc.</span></span>

<span data-ttu-id="96fea-183">以下是一些您需要注意的範例：</span><span class="sxs-lookup"><span data-stu-id="96fea-183">Here are some examples of when you need to be aware of this:</span></span>

-   <span data-ttu-id="96fea-184">無論您在 [步驟 3] 中選擇的選項為何，如果您模型中的未來變更需要變更或卸載這些額外的物件，則遷移將不知道要進行這些變更。</span><span class="sxs-lookup"><span data-stu-id="96fea-184">Regardless of the option you chose in ‘Step 3’, if future changes in your model require changing or dropping these additional objects Migrations will not know to make these changes.</span></span> <span data-ttu-id="96fea-185">例如，如果您卸載的資料行有額外的索引，則遷移將不知道要卸載索引。</span><span class="sxs-lookup"><span data-stu-id="96fea-185">For example, if you drop a column that has an additional index on it, Migrations will not know to drop the index.</span></span> <span data-ttu-id="96fea-186">您必須手動將其新增至 scaffold 遷移。</span><span class="sxs-lookup"><span data-stu-id="96fea-186">You will need to manually add this to the scaffolded Migration.</span></span>
-   <span data-ttu-id="96fea-187">如果您使用 [選項二：使用空白資料庫做為起點]，這些額外的物件將不會由您初始遷移的 Up 方法建立。</span><span class="sxs-lookup"><span data-stu-id="96fea-187">If you used ‘Option Two: Use empty database as a starting point’, these additional objects will not be created by the Up method of your initial migration.</span></span>
    <span data-ttu-id="96fea-188">您可以視需要修改向上和向下的方法，以處理這些額外的物件。</span><span class="sxs-lookup"><span data-stu-id="96fea-188">You can modify the Up and Down methods to take care of these additional objects if you wish.</span></span> <span data-ttu-id="96fea-189">對於遷移 API 中原本不支援的物件（例如 views），您可以使用 [Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) 方法來執行原始 sql 來建立/卸載它們。</span><span class="sxs-lookup"><span data-stu-id="96fea-189">For objects that are not natively supported in the Migrations API – such as views – you can use the [Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) method to run raw SQL to create/drop them.</span></span>
