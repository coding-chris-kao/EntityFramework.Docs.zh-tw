---
title: 自我追蹤實體 - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 5e60f5be-7bbb-4bf8-835e-0ac808d6c84a
ms.openlocfilehash: 3bb9759d89fbd0c10b911625aa7d0afd7747de14
ms.sourcegitcommit: 9b562663679854c37c05fca13d93e180213fb4aa
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/07/2020
ms.locfileid: "78413353"
---
# <a name="self-tracking-entities"></a>自我追蹤實體

> [!IMPORTANT]
> 我們不再建議使用自我追蹤實體範本。 繼續提供該範本只是為了支援現有應用程式。 如果您的應用程式需要使用已中斷連線的實體圖形，請考慮使用 [Trackable Entities](https://trackableentities.github.io/) (可追蹤的實體) 之類的其他替代項目，這是一項類似於自我追蹤實體的技術，可由社群更積極地進行開發或使用低層級變更追蹤 API 來撰寫自訂程式碼。

在 Entity Framework 架構應用程式中，內容負責追蹤物件中的變更。 接著，您會使用 SaveChanges 方法將變更保存到資料庫。 使用多層式架構 (N-Tier) 應用程式時，實體物件通常會中斷與內容的連線，因此您必須決定如何追蹤變更，以及如何將這些變更回報至內容。 自我追蹤實體 (STE)　可協助您追蹤任何層中的變更，然後將這些變更重新執行到要儲存的內容。  

只有當內容無法在物件圖形進行變更的層上使用時，才應該使用 STE。 如果內容可供使用，則不需要使用 STE，因為內容將負責追蹤變更。  

這個範本項目會產生兩個 .tt (文字範本) 檔案：  

- **\<模型名稱\>.tt** 檔案會產生實體類型和 Helper 類別，而這個類別包含自我追蹤實體所使用的變更追蹤邏輯，以及允許針對自我追蹤實體設定狀態的擴充方法。  
- **\<模型名稱\>.Context.tt** 檔案會產生衍生的內容，以及包含 **ObjectContext** 和 **ObjectSet** 類別之 **ApplyChanges** 方法的擴充類別。 這些方法會檢查自我追蹤實體圖形中所含的變更追蹤資訊，以便推斷要在資料庫中儲存變更所需執行的作業組。  

## <a name="get-started"></a>開始使用  

若要開始使用，請前往[自我追蹤實體逐步解說](walkthrough.md)頁面。  

## <a name="functional-considerations-when-working-with-self-tracking-entities"></a>使用自我追蹤實體時的功能考量  
> [!IMPORTANT]
> 我們不再建議使用自我追蹤實體範本。 繼續提供該範本只是為了支援現有應用程式。 如果您的應用程式需要使用已中斷連線的實體圖形，請考慮使用 [Trackable Entities](https://trackableentities.github.io/) (可追蹤的實體) 之類的其他替代項目，這是一項類似於自我追蹤實體的技術，可由社群更積極地進行開發或使用低層級變更追蹤 API 來撰寫自訂程式碼。

使用自我追蹤實體時，請考慮下列事項：  

- 請確定您的用戶端專案具有包含實體類型之組件的參考。 如果您只將服務參考加入至用戶端專案，用戶端專案將會使用 WCF Proxy 型別，而非實際的自我追蹤實體類型。 這表示您將無法取得自動化通知功能，以便在用戶端上管理實體的追蹤。 如果您故意不要加入實體類型，就必須在用戶端上手動設定變更追蹤資訊，讓變更傳送回服務。  
- 服務作業的呼叫應該沒有狀態，並且建立物件內容的新執行個體。 我們也建議您在 **using** 區塊中建立物件內容。  
- 當您將已在用戶端上修改的圖形傳送至服務，然後想要繼續在用戶端上使用相同的圖形時，就必須手動逐一查看圖形，並且針對每個物件呼叫 **AcceptChanges** 方法，以便重設變更追蹤器。  

    > 如果圖形中的物件包含屬性，而這些屬性含有資料庫產生的值 (例如識別或並行值)，Entity Framework 就會在呼叫 **SaveChanges** 方法之後，將這些屬性的值取代為資料庫產生的值。 您可以實作服務作業，以便將已儲存的物件或物件的產生屬性值清單傳回給用戶端。 然後，用戶端就必須將物件執行個體或物件屬性值取代成服務作業所傳回的物件或屬性值。  
- 合併來自多個服務要求的圖形時，可能會在產生的圖形中導入具有重複索引鍵值的物件。 Entity Framework 不會在您呼叫 **ApplyChanges** 方法時移除具有重複索引鍵的物件，但是會改為擲回例外狀況。 若要避免圖形具有重複的索引鍵值，請遵循下列部落格中描述的其中一種模式：[自我追蹤實體：ApplyChanges 和重複的實體](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409) \(英文\)。  
- 當您設定外部索引鍵屬性來變更物件之間的關聯性時，參考導覽屬性會設定為 null，而且不會同步處理至用戶端上的適當主體實體。 當圖形附加至物件內容後 (例如，在您呼叫 **ApplyChanges** 方法之後)，外部索引鍵屬性和導覽屬性就會進行同步處理。  

    > 如果您已經在外部索引鍵關聯性上指定了串聯刪除，但是參考導覽屬性卻沒有與適當的主體物件同步處理，此時就可能會發生問題。 如果您刪除主體，此刪除作業將不會傳播至相依的物件。 如果您已經指定了串聯刪除，請使用導覽屬性來變更關聯性，而非設定外部索引鍵屬性。  
- 系統不會啟用自我追蹤實體來執行消極式載入。  
- 自我追蹤實體不支援 ASP.NET 狀態管理物件的二進位序列化和序列化。 不過，您可以自訂範本，以便加入二進位序列化支援。 如需詳細資訊，請參閱[使用二進位序列化和 ViewState 搭配自我追蹤實體](https://go.microsoft.com/fwlink/?LinkId=199208)。  

## <a name="security-considerations"></a>安全性考量  

下列是使用自我追蹤實體時應該列入考慮的安全性考量：  

- 服務不應該信任來自不信任用戶端或通過不信任通道的擷取或更新資料要求。 您必須驗證用戶端：應該使用安全通道或訊息封套。 您必須驗證用戶端的更新或擷取資料要求，以便確保它們符合給定案例的預期和合法變更。  
- 請避免使用機密資訊做為實體索引鍵 (例如身分證號碼)。 這樣做可降低不小心將自我追蹤實體圖形中之機密資訊序列化至未完全信任之用戶端的可能性。 使用獨立關聯時，與正在序列化之實體相關的實體的原始索引鍵也可能會傳送至用戶端。  
- 若要避免將包含敏感性資料的例外狀況訊息傳播至用戶層，您應該在例外狀況處理程式碼中包裝伺服器層的 **ApplyChanges** 和 **SaveChanges** 呼叫。  
