---
title: 自我追蹤實體 - EF6
description: Entity Framework 6 中的自我追蹤實體
author: divega
ms.date: 10/23/2016
uid: ef6/fundamentals/disconnected-entities/self-tracking-entities/index
ms.openlocfilehash: 9d5985a3f66b58a74536a1a56486bfc37c3f9f4d
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/14/2020
ms.locfileid: "90070584"
---
# <a name="self-tracking-entities"></a><span data-ttu-id="37cf6-103">自我追蹤實體</span><span class="sxs-lookup"><span data-stu-id="37cf6-103">Self-tracking entities</span></span>

> [!IMPORTANT]
> <span data-ttu-id="37cf6-104">我們不再建議使用自我追蹤實體範本。</span><span class="sxs-lookup"><span data-stu-id="37cf6-104">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="37cf6-105">繼續提供該範本只是為了支援現有應用程式。</span><span class="sxs-lookup"><span data-stu-id="37cf6-105">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="37cf6-106">如果您的應用程式需要使用已中斷連線的實體圖形，請考慮使用 [Trackable Entities](https://trackableentities.github.io/) (可追蹤的實體) 之類的其他替代項目，這是一項類似於自我追蹤實體的技術，可由社群更積極地進行開發或使用低層級變更追蹤 API 來撰寫自訂程式碼。</span><span class="sxs-lookup"><span data-stu-id="37cf6-106">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](https://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="37cf6-107">在 Entity Framework 架構應用程式中，內容負責追蹤物件中的變更。</span><span class="sxs-lookup"><span data-stu-id="37cf6-107">In an Entity Framework-based application, a context is responsible for tracking changes in your objects.</span></span> <span data-ttu-id="37cf6-108">接著，您會使用 SaveChanges 方法將變更保存到資料庫。</span><span class="sxs-lookup"><span data-stu-id="37cf6-108">You then use the SaveChanges method to persist the changes to the database.</span></span> <span data-ttu-id="37cf6-109">使用多層式架構 (N-Tier) 應用程式時，實體物件通常會中斷與內容的連線，因此您必須決定如何追蹤變更，以及如何將這些變更回報至內容。</span><span class="sxs-lookup"><span data-stu-id="37cf6-109">When working with N-Tier applications, the entity objects are usually disconnected from the context and you must decide how to track changes and report those changes back to the context.</span></span> <span data-ttu-id="37cf6-110">自我追蹤實體 (STE)　可協助您追蹤任何層中的變更，然後將這些變更重新執行到要儲存的內容。</span><span class="sxs-lookup"><span data-stu-id="37cf6-110">Self-Tracking Entities (STEs) can help you track changes in any tier and then replay these changes into a context to be saved.</span></span>  

<span data-ttu-id="37cf6-111">只有當內容無法在物件圖形進行變更的層上使用時，才應該使用 STE。</span><span class="sxs-lookup"><span data-stu-id="37cf6-111">Use STEs only if the context is not available on a tier where the changes to the object graph are made.</span></span> <span data-ttu-id="37cf6-112">如果內容可供使用，則不需要使用 STE，因為內容將負責追蹤變更。</span><span class="sxs-lookup"><span data-stu-id="37cf6-112">If the context is available, there is no need to use STEs because the context will take care of tracking changes.</span></span>  

<span data-ttu-id="37cf6-113">這個範本項目會產生兩個 .tt (文字範本) 檔案：</span><span class="sxs-lookup"><span data-stu-id="37cf6-113">This template item generates two .tt (text template) files:</span></span>  

- <span data-ttu-id="37cf6-114">**\<model name\>.tt**檔案會產生實體類型與協助程式類別，而此類別包含自我追蹤實體所使用的變更追蹤邏輯，以及允許針對自我追蹤實體設定狀態的擴充方法。</span><span class="sxs-lookup"><span data-stu-id="37cf6-114">The **\<model name\>.tt** file generates the entity types and a helper class that contains the change-tracking logic that is used by self-tracking entities and the extension methods that allow setting state on self-tracking entities.</span></span>  
- <span data-ttu-id="37cf6-115">**\<model name\>.Context.tt** 檔案會產生衍生的內容，以及包含 **ObjectContext** 與 **ObjectSet** 類別之 **ApplyChanges** 方法的擴充類別。</span><span class="sxs-lookup"><span data-stu-id="37cf6-115">The **\<model name\>.Context.tt** file generates a derived context and an extension class that contains **ApplyChanges** methods for the **ObjectContext** and **ObjectSet** classes.</span></span> <span data-ttu-id="37cf6-116">這些方法會檢查自我追蹤實體圖形中所含的變更追蹤資訊，以便推斷要在資料庫中儲存變更所需執行的作業組。</span><span class="sxs-lookup"><span data-stu-id="37cf6-116">These methods examine the change-tracking information that is contained in the graph of self-tracking entities to infer the set of operations that must be performed to save the changes in the database.</span></span>  

## <a name="get-started"></a><span data-ttu-id="37cf6-117">開始使用</span><span class="sxs-lookup"><span data-stu-id="37cf6-117">Get Started</span></span>  

<span data-ttu-id="37cf6-118">若要開始使用，請前往[自我追蹤實體逐步解說](xref:ef6/fundamentals/disconnected-entities/self-tracking-entities/walkthrough)頁面。</span><span class="sxs-lookup"><span data-stu-id="37cf6-118">To get started, visit the [Self-Tracking Entities Walkthrough](xref:ef6/fundamentals/disconnected-entities/self-tracking-entities/walkthrough) page.</span></span>  

## <a name="functional-considerations-when-working-with-self-tracking-entities"></a><span data-ttu-id="37cf6-119">使用自我追蹤實體時的功能考量</span><span class="sxs-lookup"><span data-stu-id="37cf6-119">Functional Considerations When Working with Self-Tracking Entities</span></span>  
> [!IMPORTANT]
> <span data-ttu-id="37cf6-120">我們不再建議使用自我追蹤實體範本。</span><span class="sxs-lookup"><span data-stu-id="37cf6-120">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="37cf6-121">繼續提供該範本只是為了支援現有應用程式。</span><span class="sxs-lookup"><span data-stu-id="37cf6-121">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="37cf6-122">如果您的應用程式需要使用已中斷連線的實體圖形，請考慮使用 [Trackable Entities](https://trackableentities.github.io/) (可追蹤的實體) 之類的其他替代項目，這是一項類似於自我追蹤實體的技術，可由社群更積極地進行開發或使用低層級變更追蹤 API 來撰寫自訂程式碼。</span><span class="sxs-lookup"><span data-stu-id="37cf6-122">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](https://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="37cf6-123">使用自我追蹤實體時，請考慮下列事項：</span><span class="sxs-lookup"><span data-stu-id="37cf6-123">Consider the following when working with self-tracking entities:</span></span>  

- <span data-ttu-id="37cf6-124">請確定您的用戶端專案具有包含實體類型之組件的參考。</span><span class="sxs-lookup"><span data-stu-id="37cf6-124">Make sure that your client project has a reference to the assembly containing the entity types.</span></span> <span data-ttu-id="37cf6-125">如果您只將服務參考加入至用戶端專案，用戶端專案將會使用 WCF Proxy 型別，而非實際的自我追蹤實體類型。</span><span class="sxs-lookup"><span data-stu-id="37cf6-125">If you add only the service reference to the client project, the client project will use the WCF proxy types and not the actual self-tracking entity types.</span></span> <span data-ttu-id="37cf6-126">這表示您將無法取得自動化通知功能，以便在用戶端上管理實體的追蹤。</span><span class="sxs-lookup"><span data-stu-id="37cf6-126">This means that you will not get the automated notification features that manage the tracking of the entities on the client.</span></span> <span data-ttu-id="37cf6-127">如果您故意不要加入實體類型，就必須在用戶端上手動設定變更追蹤資訊，讓變更傳送回服務。</span><span class="sxs-lookup"><span data-stu-id="37cf6-127">If you intentionally do not want to include the entity types, you will have to manually set change-tracking information on the client for the changes to be sent back to the service.</span></span>  
- <span data-ttu-id="37cf6-128">服務作業的呼叫應該沒有狀態，並且建立物件內容的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="37cf6-128">Calls to the service operation should be stateless and create a new instance of object context.</span></span> <span data-ttu-id="37cf6-129">我們也建議您在 **using** 區塊中建立物件內容。</span><span class="sxs-lookup"><span data-stu-id="37cf6-129">We also recommend that you create object context in a **using** block.</span></span>  
- <span data-ttu-id="37cf6-130">當您將已在用戶端上修改的圖形傳送至服務，然後想要繼續在用戶端上使用相同的圖形時，就必須手動逐一查看圖形，並且針對每個物件呼叫 **AcceptChanges** 方法，以便重設變更追蹤器。</span><span class="sxs-lookup"><span data-stu-id="37cf6-130">When you send the graph that was modified on the client to the service and then intend to continue working with the same graph on the client, you have to manually iterate through the graph and call the **AcceptChanges** method on each object to reset the change tracker.</span></span>  

    > <span data-ttu-id="37cf6-131">如果圖形中的物件包含屬性，而這些屬性含有資料庫產生的值 (例如識別或並行值)，Entity Framework 就會在呼叫 **SaveChanges** 方法之後，將這些屬性的值取代為資料庫產生的值。</span><span class="sxs-lookup"><span data-stu-id="37cf6-131">If objects in your graph contain properties with database-generated values (for example, identity or concurrency values), Entity Framework will replace values of these properties with the database-generated values after the **SaveChanges** method is called.</span></span> <span data-ttu-id="37cf6-132">您可以實作服務作業，以便將已儲存的物件或物件的產生屬性值清單傳回給用戶端。</span><span class="sxs-lookup"><span data-stu-id="37cf6-132">You can implement your service operation to return saved objects or a list of generated property values for the objects back to the client.</span></span> <span data-ttu-id="37cf6-133">然後，用戶端就必須將物件執行個體或物件屬性值取代成服務作業所傳回的物件或屬性值。</span><span class="sxs-lookup"><span data-stu-id="37cf6-133">The client would then need to replace the object instances or object property values with the objects or property values returned from the service operation.</span></span>  
- <span data-ttu-id="37cf6-134">合併來自多個服務要求的圖形時，可能會在產生的圖形中導入具有重複索引鍵值的物件。</span><span class="sxs-lookup"><span data-stu-id="37cf6-134">Merging graphs from multiple service requests may introduce objects with duplicate key values in the resulting graph.</span></span> <span data-ttu-id="37cf6-135">Entity Framework 不會在您呼叫 **ApplyChanges** 方法時移除具有重複索引鍵的物件，但是會改為擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="37cf6-135">Entity Framework does not remove the objects with duplicate keys when you call the **ApplyChanges** method but instead throws an exception.</span></span> <span data-ttu-id="37cf6-136">若要避免圖形具有重複的索引鍵值，請遵循下列部落格中描述的其中一種模式：[自我追蹤實體：ApplyChanges 和重複的實體](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409)。</span><span class="sxs-lookup"><span data-stu-id="37cf6-136">To avoid having graphs with duplicate key values follow one of the patterns described in the following blog: [Self-Tracking Entities: ApplyChanges and duplicate entities](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409).</span></span>  
- <span data-ttu-id="37cf6-137">當您設定外部索引鍵屬性來變更物件之間的關聯性時，參考導覽屬性會設定為 null，而且不會同步處理至用戶端上的適當主體實體。</span><span class="sxs-lookup"><span data-stu-id="37cf6-137">When you change the relationship between objects by setting the foreign key property, the reference navigation property is set to null and not synchronized to the appropriate principal entity on the client.</span></span> <span data-ttu-id="37cf6-138">當圖形附加至物件內容後 (例如，在您呼叫 **ApplyChanges** 方法之後)，外部索引鍵屬性和導覽屬性就會進行同步處理。</span><span class="sxs-lookup"><span data-stu-id="37cf6-138">After the graph is attached to the object context (for example, after you call the **ApplyChanges** method), the foreign key properties and navigation properties are synchronized.</span></span>  

    > <span data-ttu-id="37cf6-139">如果您已經在外部索引鍵關聯性上指定了串聯刪除，但是參考導覽屬性卻沒有與適當的主體物件同步處理，此時就可能會發生問題。</span><span class="sxs-lookup"><span data-stu-id="37cf6-139">Not having a reference navigation property synchronized with the appropriate principal object could be an issue if you have specified cascade delete on the foreign key relationship.</span></span> <span data-ttu-id="37cf6-140">如果您刪除主體，此刪除作業將不會傳播至相依的物件。</span><span class="sxs-lookup"><span data-stu-id="37cf6-140">If you delete the principal, the delete will not be propagated to the dependent objects.</span></span> <span data-ttu-id="37cf6-141">如果您已經指定了串聯刪除，請使用導覽屬性來變更關聯性，而非設定外部索引鍵屬性。</span><span class="sxs-lookup"><span data-stu-id="37cf6-141">If you have cascade deletes specified, use navigation properties to change relationships instead of setting the foreign key property.</span></span>  
- <span data-ttu-id="37cf6-142">系統不會啟用自我追蹤實體來執行消極式載入。</span><span class="sxs-lookup"><span data-stu-id="37cf6-142">Self-tracking entities are not enabled to perform lazy loading.</span></span>  
- <span data-ttu-id="37cf6-143">自我追蹤實體不支援 ASP.NET 狀態管理物件的二進位序列化和序列化。</span><span class="sxs-lookup"><span data-stu-id="37cf6-143">Binary serialization and serialization to ASP.NET state management objects is not supported by self-tracking entities.</span></span> <span data-ttu-id="37cf6-144">不過，您可以自訂範本，以便加入二進位序列化支援。</span><span class="sxs-lookup"><span data-stu-id="37cf6-144">However, you can customize the template to add the binary serialization support.</span></span> <span data-ttu-id="37cf6-145">如需詳細資訊，請參閱[使用二進位序列化和 ViewState 搭配自我追蹤實體](https://go.microsoft.com/fwlink/?LinkId=199208)。</span><span class="sxs-lookup"><span data-stu-id="37cf6-145">For more information, see [Using Binary Serialization and ViewState with Self-Tracking Entities](https://go.microsoft.com/fwlink/?LinkId=199208).</span></span>  

## <a name="security-considerations"></a><span data-ttu-id="37cf6-146">安全性考量</span><span class="sxs-lookup"><span data-stu-id="37cf6-146">Security Considerations</span></span>  

<span data-ttu-id="37cf6-147">下列是使用自我追蹤實體時應該列入考慮的安全性考量：</span><span class="sxs-lookup"><span data-stu-id="37cf6-147">The following security considerations should be taken into account when working with self-tracking entities:</span></span>  

- <span data-ttu-id="37cf6-148">服務不應該信任來自不信任用戶端或通過不信任通道的擷取或更新資料要求。</span><span class="sxs-lookup"><span data-stu-id="37cf6-148">A service should not trust requests to retrieve or update data from a non-trusted client or through a non-trusted channel.</span></span> <span data-ttu-id="37cf6-149">您必須驗證用戶端：應該使用安全通道或訊息封套。</span><span class="sxs-lookup"><span data-stu-id="37cf6-149">A client must be authenticated: a secure channel or message envelope should be used.</span></span> <span data-ttu-id="37cf6-150">您必須驗證用戶端的更新或擷取資料要求，以便確保它們符合給定案例的預期和合法變更。</span><span class="sxs-lookup"><span data-stu-id="37cf6-150">Clients' requests to update or retrieve data must be validated to ensure they conform to expected and legitimate changes for the given scenario.</span></span>  
- <span data-ttu-id="37cf6-151">請避免使用機密資訊做為實體索引鍵 (例如身分證號碼)。</span><span class="sxs-lookup"><span data-stu-id="37cf6-151">Avoid using sensitive information as entity keys (for example, social security numbers).</span></span> <span data-ttu-id="37cf6-152">這樣做可降低不小心將自我追蹤實體圖形中之機密資訊序列化至未完全信任之用戶端的可能性。</span><span class="sxs-lookup"><span data-stu-id="37cf6-152">This mitigates the possibility of inadvertently serializing sensitive information in the self-tracking entity graphs to a client that is not fully trusted.</span></span> <span data-ttu-id="37cf6-153">使用獨立關聯時，與正在序列化之實體相關的實體的原始索引鍵也可能會傳送至用戶端。</span><span class="sxs-lookup"><span data-stu-id="37cf6-153">With independent associations, the original key of an entity that is related to the one that is being serialized might be sent to the client as well.</span></span>  
- <span data-ttu-id="37cf6-154">若要避免將包含敏感性資料的例外狀況訊息傳播至用戶層，您應該在例外狀況處理程式碼中包裝伺服器層的 **ApplyChanges** 和 **SaveChanges** 呼叫。</span><span class="sxs-lookup"><span data-stu-id="37cf6-154">To avoid propagating exception messages that contain sensitive data to the client tier, calls to **ApplyChanges** and **SaveChanges** on the server tier should be wrapped in exception-handling code.</span></span>  
