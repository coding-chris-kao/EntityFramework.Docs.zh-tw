---
title: 記錄和攔截資料庫作業-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
ms.openlocfilehash: 35b0284a5ad8b2b732f074589bd458d243312575
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78419475"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="aa6b0-102">記錄和攔截資料庫作業</span><span class="sxs-lookup"><span data-stu-id="aa6b0-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="aa6b0-103">**僅限 EF6 及更新版本** - Entity Framework 6 已引進此頁面中所討論的功能及 API 等等。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="aa6b0-104">如果您使用的是較早版本，則不適用部分或全部的資訊。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="aa6b0-105">從 Entity Framework 6 開始，每當 Entity Framework 將命令傳送至資料庫時，應用程式代碼就可以攔截此命令。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="aa6b0-106">這最常用於記錄 SQL，但也可以用來修改或中止命令。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="aa6b0-107">具體而言，EF 包含：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="aa6b0-108">類似 DataCoNtext 的內容的記錄檔屬性。請登入 LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="aa6b0-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="aa6b0-109">自訂傳送至記錄之輸出內容和格式的機制</span><span class="sxs-lookup"><span data-stu-id="aa6b0-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="aa6b0-110">適用于攔截的低層級建立區塊提供更大的控制/彈性</span><span class="sxs-lookup"><span data-stu-id="aa6b0-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="aa6b0-111">內容記錄檔屬性</span><span class="sxs-lookup"><span data-stu-id="aa6b0-111">Context Log property</span></span>  

<span data-ttu-id="aa6b0-112">您可以將 DbCoNtext 屬性設定為任何接受字串之方法的委派。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="aa6b0-113">最常見的方法是將它設定為該不正確 "Write" 方法，以搭配任何不正確。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="aa6b0-114">目前內容所產生的所有 SQL 都會記錄到該寫入器。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="aa6b0-115">例如，下列程式碼會將 SQL 記錄到主控台：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="aa6b0-116">請注意，內容。Database .Log 已設定為 Console. Write。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="aa6b0-117">這就是將 SQL 記錄到主控台所需的一切。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-117">This is all that is needed to log SQL to the console.</span></span>  

<span data-ttu-id="aa6b0-118">讓我們新增一些簡單的查詢/插入/更新程式碼，讓我們可以看到一些輸出：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-118">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="aa6b0-119">這會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-119">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="aa6b0-120">（請注意，這是假設已經發生任何資料庫初始化的輸出。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-120">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="aa6b0-121">如果尚未發生資料庫初始化，則會有更多的輸出顯示所有工作遷移會在幕後檢查或建立新的資料庫。）</span><span class="sxs-lookup"><span data-stu-id="aa6b0-121">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

## <a name="what-gets-logged"></a><span data-ttu-id="aa6b0-122">會記錄哪些專案？</span><span class="sxs-lookup"><span data-stu-id="aa6b0-122">What gets logged?</span></span>  

<span data-ttu-id="aa6b0-123">當 Log 屬性設定為時，將會記錄下列所有內容：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-123">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="aa6b0-124">適用于所有不同類型命令的 SQL。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-124">SQL for all different kinds of commands.</span></span> <span data-ttu-id="aa6b0-125">例如：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-125">For example:</span></span>  
    - <span data-ttu-id="aa6b0-126">查詢，包括一般 LINQ 查詢、eSQL 查詢，以及來自 SqlQuery 等方法的原始查詢</span><span class="sxs-lookup"><span data-stu-id="aa6b0-126">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="aa6b0-127">在 SaveChanges 中產生的插入、更新和刪除</span><span class="sxs-lookup"><span data-stu-id="aa6b0-127">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="aa6b0-128">關聯性載入查詢，例如消極式載入所產生的查詢</span><span class="sxs-lookup"><span data-stu-id="aa6b0-128">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="aa6b0-129">參數</span><span class="sxs-lookup"><span data-stu-id="aa6b0-129">Parameters</span></span>  
- <span data-ttu-id="aa6b0-130">是否要以非同步方式執行命令</span><span class="sxs-lookup"><span data-stu-id="aa6b0-130">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="aa6b0-131">指出命令開始執行的時間戳記</span><span class="sxs-lookup"><span data-stu-id="aa6b0-131">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="aa6b0-132">命令是否已成功完成、擲回例外狀況失敗，或已取消（針對非同步）</span><span class="sxs-lookup"><span data-stu-id="aa6b0-132">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="aa6b0-133">結果值的某些指示</span><span class="sxs-lookup"><span data-stu-id="aa6b0-133">Some indication of the result value</span></span>  
- <span data-ttu-id="aa6b0-134">執行命令所花費的大約時間量。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-134">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="aa6b0-135">請注意，這是傳送命令以取回結果物件的時間。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-135">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="aa6b0-136">不包含讀取結果的時間。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-136">It does not include time to read the results.</span></span>  

<span data-ttu-id="aa6b0-137">查看上述的範例輸出，記錄的四個命令都是：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-137">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="aa6b0-138">呼叫內容所產生的查詢。Blog. First</span><span class="sxs-lookup"><span data-stu-id="aa6b0-138">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="aa6b0-139">請注意，取得 SQL 的 ToString 方法不會處理此查詢，因為「第一個」並未提供可呼叫 ToString 的 IQueryable</span><span class="sxs-lookup"><span data-stu-id="aa6b0-139">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="aa6b0-140">從延遲載入的 blog 產生的查詢。回</span><span class="sxs-lookup"><span data-stu-id="aa6b0-140">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="aa6b0-141">請注意發生消極式載入之金鑰值的參數詳細資料。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-141">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="aa6b0-142">只會記錄設定為非預設值之參數的屬性。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-142">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="aa6b0-143">例如，只有在不是零的情況下，才會顯示 Size 屬性。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-143">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="aa6b0-144">SaveChangesAsync 所產生的兩個命令;一個用於更新變更貼文標題，另一個用於插入以加入新的貼文</span><span class="sxs-lookup"><span data-stu-id="aa6b0-144">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="aa6b0-145">請注意 FK 和標題屬性的參數詳細資料</span><span class="sxs-lookup"><span data-stu-id="aa6b0-145">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="aa6b0-146">請注意，這些命令會以非同步方式執行</span><span class="sxs-lookup"><span data-stu-id="aa6b0-146">Notice that these commands are being executed asynchronously</span></span>  

## <a name="logging-to-different-places"></a><span data-ttu-id="aa6b0-147">記錄到不同的位置</span><span class="sxs-lookup"><span data-stu-id="aa6b0-147">Logging to different places</span></span>  

<span data-ttu-id="aa6b0-148">如上所示，登入主控台非常簡單。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-148">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="aa6b0-149">藉由使用不同[種類的「](https://msdn.microsoft.com/library/system.io.textwriter.aspx)類型」，也很容易就能記錄到記憶體、檔案等等。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-149">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="aa6b0-150">如果您很熟悉 LINQ to SQL，您可能會注意到 LINQ to SQL 中的 Log 屬性設為實際的「無效」物件（例如，Console）。在 EF 中，Log 屬性會設定為可接受字串的方法（例如、Console. Write 或 Console。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-150">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="aa6b0-151">這種情況的原因是要接受可做為字串接收的任何委派，以將 EF 與「解除耦合」分離。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-151">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="aa6b0-152">例如，假設您已經有一些記錄架構，而且它會定義一種記錄方法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-152">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="aa6b0-153">這可能會連接到 EF Log 屬性，如下所示：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-153">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

## <a name="result-logging"></a><span data-ttu-id="aa6b0-154">結果記錄</span><span class="sxs-lookup"><span data-stu-id="aa6b0-154">Result logging</span></span>  

<span data-ttu-id="aa6b0-155">預設記錄器會記錄命令文字（SQL）、參數和「執行中」行，並在命令傳送到資料庫之前加上時間戳記。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-155">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="aa6b0-156">執行命令之後，會記錄包含經過時間的「已完成」行。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-156">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="aa6b0-157">請注意，針對非同步命令，在非同步工作實際完成、失敗或取消之前，不會記錄「已完成」行。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-157">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="aa6b0-158">「已完成」行包含不同的資訊，取決於命令的類型，以及執行是否成功。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-158">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

### <a name="successful-execution"></a><span data-ttu-id="aa6b0-159">成功執行</span><span class="sxs-lookup"><span data-stu-id="aa6b0-159">Successful execution</span></span>  

<span data-ttu-id="aa6b0-160">若為成功完成的命令，輸出會是「以 x 毫秒完成，結果為：」，後面會指出結果的意義。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-160">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="aa6b0-161">對於傳回資料讀取器的命令，結果指示是傳回的[DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx)類型。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-161">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="aa6b0-162">對於傳回整數值的命令（如上方所示的 update 命令），會是該整數。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-162">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

### <a name="failed-execution"></a><span data-ttu-id="aa6b0-163">執行失敗</span><span class="sxs-lookup"><span data-stu-id="aa6b0-163">Failed execution</span></span>  

<span data-ttu-id="aa6b0-164">對於因擲回例外狀況而失敗的命令，輸出會包含來自例外狀況的訊息。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-164">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="aa6b0-165">例如，使用 SqlQuery 來查詢存在的資料表，會導致記錄輸出如下所示：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-165">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

### <a name="canceled-execution"></a><span data-ttu-id="aa6b0-166">已取消執行</span><span class="sxs-lookup"><span data-stu-id="aa6b0-166">Canceled execution</span></span>  

<span data-ttu-id="aa6b0-167">對於取消工作的非同步命令，結果可能會失敗併發生例外狀況，因為這是當嘗試取消時，基礎 ADO.NET 提供者通常會執行的動作。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-167">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="aa6b0-168">如果沒有發生這種情況，而且工作已完全取消，則輸出看起來會像這樣：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-168">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```console
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="aa6b0-169">變更記錄檔內容和格式</span><span class="sxs-lookup"><span data-stu-id="aa6b0-169">Changing log content and formatting</span></span>  

<span data-ttu-id="aa6b0-170">在中，資料庫 .Log 屬性會使用 DatabaseLogFormatter 物件。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-170">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="aa6b0-171">此物件可有效地將 IDbCommandInterceptor 的實作為系結（如下所示）到接受字串和 DbCoNtext 的委派。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-171">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="aa6b0-172">這表示在 EF 執行命令之前和之後，會呼叫 DatabaseLogFormatter 上的方法。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-172">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="aa6b0-173">這些 DatabaseLogFormatter 方法會收集並設定記錄輸出的格式，並將它傳送至委派。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-173">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="aa6b0-174">自訂 DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="aa6b0-174">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="aa6b0-175">藉由建立衍生自 DatabaseLogFormatter 的新類別，並視需要覆寫方法，來變更記錄的內容和其格式化方式。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-175">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="aa6b0-176">最常見的覆寫方法是：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-176">The most common methods to override are:</span></span>  

- <span data-ttu-id="aa6b0-177">LogCommand –覆寫此參數，以變更命令在執行之前的記錄方式。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-177">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="aa6b0-178">根據預設，LogCommand 會針對每個參數呼叫 LogParameter;您可以選擇在覆寫中執行相同的動作，或改為以不同的方式處理參數。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-178">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="aa6b0-179">LogResult –覆寫此參數，以變更如何記錄執行命令的結果。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-179">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="aa6b0-180">LogParameter –覆寫此項以變更參數記錄的格式設定和內容。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-180">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="aa6b0-181">例如，假設我們想要在每個命令傳送至資料庫之前，只記錄一行。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-181">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="aa6b0-182">這可以透過兩個覆寫來完成：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-182">This can be done with two overrides:</span></span>  

- <span data-ttu-id="aa6b0-183">覆寫 LogCommand 以格式化和寫入單一行的 SQL</span><span class="sxs-lookup"><span data-stu-id="aa6b0-183">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="aa6b0-184">覆寫 LogResult 以不執行任何動作。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-184">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="aa6b0-185">程式碼看起來會像這樣：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-185">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="aa6b0-186">若要記錄輸出，只要呼叫寫入方法，就會將輸出傳送至已設定的寫入委派。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-186">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="aa6b0-187">（請注意，此程式碼會簡單地移除分行符號，就像範例一樣。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-187">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="aa6b0-188">這可能不適合用來查看複雜的 SQL）。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-188">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="aa6b0-189">設定 DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="aa6b0-189">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="aa6b0-190">一旦建立新的 DatabaseLogFormatter 類別之後，就必須向 EF 註冊它。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-190">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="aa6b0-191">這是使用以程式碼為基礎的設定來完成。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-191">This is done using code-based configuration.</span></span> <span data-ttu-id="aa6b0-192">簡單來說，這表示要建立一個衍生自 DbConfiguration 的新類別（在與 DbCoNtext 類別相同的元件中），然後在這個新類別的函式中呼叫 SetDatabaseLogFormatter。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-192">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="aa6b0-193">例如：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-193">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="aa6b0-194">使用新的 DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="aa6b0-194">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="aa6b0-195">這個新的 DatabaseLogFormatter 現在會在任何時候都使用 Database .Log。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-195">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="aa6b0-196">因此，執行第1部分的程式碼現在會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-196">So, running the code from part 1 will now result in the following output:</span></span>  

```console
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="aa6b0-197">攔截建立區塊</span><span class="sxs-lookup"><span data-stu-id="aa6b0-197">Interception building blocks</span></span>  

<span data-ttu-id="aa6b0-198">到目前為止，我們已經討論過如何使用 DbCoNtext 來記錄 EF 所產生的 SQL。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-198">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="aa6b0-199">但是，這段程式碼在某些較低層的建立區塊上其實是相當精簡的外觀，以便進行一般的攔截。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-199">But this code is actually a relatively thin facade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="aa6b0-200">攔截介面</span><span class="sxs-lookup"><span data-stu-id="aa6b0-200">Interception interfaces</span></span>  

<span data-ttu-id="aa6b0-201">攔截程式碼是根據攔截介面的概念來建立的。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-201">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="aa6b0-202">這些介面會繼承自 IDbInterceptor，並定義 EF 執行某個動作時所呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-202">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="aa6b0-203">其目的是要攔截每個物件類型的一個介面。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-203">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="aa6b0-204">例如，IDbCommandInterceptor 介面會定義在 EF 呼叫 ExecuteNonQuery、ExecuteScalar、ExecuteReader 和相關方法之前呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-204">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="aa6b0-205">同樣地，介面會定義每個作業完成時所呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-205">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="aa6b0-206">我們在上方查看的 DatabaseLogFormatter 類別會執行此介面來記錄命令。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-206">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="aa6b0-207">攔截內容</span><span class="sxs-lookup"><span data-stu-id="aa6b0-207">The interception context</span></span>  

<span data-ttu-id="aa6b0-208">查看在任何攔截器介面上定義的方法，很明顯地，每個呼叫都有一個類型為 DbInterceptionCoNtext 的物件，或是一個衍生自此的類型，例如 DbCommandInterceptionCoNtext\<\>。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-208">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="aa6b0-209">此物件包含 EF 正在採取之動作的相關內容資訊。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-209">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="aa6b0-210">例如，如果是代表 DbCoNtext 來採取動作，則 DbCoNtext 會包含在 DbInterceptionCoNtext 中。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-210">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="aa6b0-211">同樣地，針對以非同步方式執行的命令，會在 DbCommandInterceptionCoNtext 上設定 IsAsync 旗標。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-211">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="aa6b0-212">結果處理</span><span class="sxs-lookup"><span data-stu-id="aa6b0-212">Result handling</span></span>  

<span data-ttu-id="aa6b0-213">DbCommandInterceptionCoNtext\<\> 類別包含一個稱為 Result、OriginalResult、Exception 和 OriginalException 的屬性。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-213">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="aa6b0-214">對於在執行作業之前呼叫的攔截方法呼叫，這些屬性會設定為 null/零，也就是 。執行方法。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-214">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="aa6b0-215">如果作業已執行且成功，則 Result 和 OriginalResult 會設定為作業的結果。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-215">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="aa6b0-216">然後可以在作業執行後呼叫的攔截方法中觀察這些值，也就是在 。已執行的方法。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-216">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="aa6b0-217">同樣地，如果作業擲回，則會設定 Exception 和 OriginalException 屬性。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-217">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="aa6b0-218">隱藏執行</span><span class="sxs-lookup"><span data-stu-id="aa6b0-218">Suppressing execution</span></span>  

<span data-ttu-id="aa6b0-219">如果攔截器在命令執行之前設定 Result 屬性（在其中一個 。執行方法）之後，EF 就不會嘗試實際執行命令，而只會使用結果集。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-219">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="aa6b0-220">換句話說，攔截器可以隱藏命令的執行，但讓 EF 繼續執行，就像命令已經執行一樣。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-220">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="aa6b0-221">如何使用此方法的範例，就是傳統上使用包裝提供者完成的命令批次處理。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-221">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="aa6b0-222">攔截器會以批次方式儲存命令以供稍後執行，但會對 EF 「假設」命令已正常執行。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-222">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="aa6b0-223">請注意，它需要的不只是用來執行批次處理，但這是可能會使用變更攔截結果的範例。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-223">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="aa6b0-224">您也可以藉由設定其中一個 ... 的 Exception 屬性來隱藏執行。執行方法。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-224">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="aa6b0-225">這會導致 EF 繼續執行，就像是藉由擲回指定的例外狀況而失敗。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-225">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="aa6b0-226">當然，這可能會造成應用程式當機，但也可能是暫時性的例外狀況，或是 EF 處理的其他例外狀況。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-226">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="aa6b0-227">例如，這可以在測試環境中用來在命令執行失敗時測試應用程式的行為。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-227">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="aa6b0-228">在執行後變更結果</span><span class="sxs-lookup"><span data-stu-id="aa6b0-228">Changing the result after execution</span></span>  

<span data-ttu-id="aa6b0-229">如果攔截器在命令執行後設定 Result 屬性（在其中一個 。執行的方法），則 EF 會使用變更的結果，而不是實際從作業傳回的結果。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-229">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="aa6b0-230">同樣地，如果攔截器在命令執行後設定例外狀況屬性，則 EF 會擲回設定例外狀況，就像作業已擲回例外狀況一樣。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-230">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="aa6b0-231">攔截器也可以將例外狀況屬性設定為 null，表示不應該擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-231">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="aa6b0-232">這在作業執行失敗時很有用，但攔截器希望 EF 繼續進行，如同作業已成功。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-232">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="aa6b0-233">這通常也會牽涉到設定結果，使 EF 在繼續時有一些結果值可以使用。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-233">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="aa6b0-234">OriginalResult 和 OriginalException</span><span class="sxs-lookup"><span data-stu-id="aa6b0-234">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="aa6b0-235">在 EF 執行過作業之後，如果執行失敗，則會設定 Result 和 OriginalResult 屬性，如果執行失敗且發生例外狀況，則會設定例外狀況和 OriginalException 屬性。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-235">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="aa6b0-236">OriginalResult 和 OriginalException 屬性是唯讀的，而且只有在實際執行作業之後，才會由 EF 設定。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-236">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="aa6b0-237">攔截器無法設定這些屬性。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-237">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="aa6b0-238">這表示任何攔截器可以區別某些其他攔截器所設定的例外狀況或結果，而不是執行作業時所發生的實際例外狀況或結果。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-238">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="aa6b0-239">正在註冊攔截器</span><span class="sxs-lookup"><span data-stu-id="aa6b0-239">Registering interceptors</span></span>  

<span data-ttu-id="aa6b0-240">一旦建立了一個或多個攔截介面的類別之後，就可以使用 DbInterception 類別向 EF 註冊它。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-240">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="aa6b0-241">例如：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-241">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="aa6b0-242">攔截器也可以使用 DbConfiguration 程式碼型設定機制，在應用程式域層級註冊。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-242">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="aa6b0-243">範例：記錄至 NLog</span><span class="sxs-lookup"><span data-stu-id="aa6b0-243">Example: Logging to NLog</span></span>  

<span data-ttu-id="aa6b0-244">讓我們將所有內容一起放入一個使用 IDbCommandInterceptor 和[NLog](https://nlog-project.org/)的範例：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-244">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](https://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="aa6b0-245">針對任何以非非同步方式執行的命令記錄警告</span><span class="sxs-lookup"><span data-stu-id="aa6b0-245">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="aa6b0-246">針對任何在執行時擲回的命令記錄錯誤</span><span class="sxs-lookup"><span data-stu-id="aa6b0-246">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="aa6b0-247">以下是執行記錄的類別，應該註冊，如上所示：</span><span class="sxs-lookup"><span data-stu-id="aa6b0-247">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="aa6b0-248">請注意，此程式碼如何使用攔截內容來探索何時以非非同步方式執行命令，以及在執行命令時發生錯誤時進行探索。</span><span class="sxs-lookup"><span data-stu-id="aa6b0-248">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
