---
title: 定序和區分大小寫-EF Core
description: 在資料庫和使用 Entity Framework Core 的查詢中設定定序和區分大小寫
author: roji
ms.date: 04/27/2020
uid: core/miscellaneous/collations-and-case-sensitivity
ms.openlocfilehash: 48e0a6b316742dc1467134ae81f90086bb93d011
ms.sourcegitcommit: 704240349e18b6404e5a809f5b7c9d365b152e2e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/16/2021
ms.locfileid: "100543532"
---
# <a name="collations-and-case-sensitivity"></a><span data-ttu-id="2f75e-103">定序和區分大小寫</span><span class="sxs-lookup"><span data-stu-id="2f75e-103">Collations and Case Sensitivity</span></span>

> [!NOTE]
> <span data-ttu-id="2f75e-104">這項功能是在 EF Core 5.0 中引進。</span><span class="sxs-lookup"><span data-stu-id="2f75e-104">This feature was introduced in EF Core 5.0.</span></span>

<span data-ttu-id="2f75e-105">資料庫中的文字處理可能很複雜，而且需要更多的使用者注意。</span><span class="sxs-lookup"><span data-stu-id="2f75e-105">Text processing in databases can be a complex, and requires more user attention that one would suspect.</span></span> <span data-ttu-id="2f75e-106">針對其中一件事，資料庫處理文字的方式會有很大的差異;例如，有些資料庫預設會區分大小寫 (例如 Sqlite、于 postgresql) ，其他資料庫則是不區分大小寫的 (SQL Server、MySQL) 。</span><span class="sxs-lookup"><span data-stu-id="2f75e-106">For one thing, databases vary considerably in how they handle text; for example, while some databases are case-sensitive by default (e.g. Sqlite, PostgreSQL), others are case-insensitive (SQL Server, MySQL).</span></span> <span data-ttu-id="2f75e-107">此外，由於索引使用方式的關係，區分大小寫和類似的層面可能會對查詢效能造成最大的影響：雖然 `string.Lower` 在區分大小寫的資料庫中使用強制進行不區分大小寫的比較可能很吸引人，但是這樣做可能會讓您的應用程式無法使用索引。</span><span class="sxs-lookup"><span data-stu-id="2f75e-107">In addition, because of index usage, case-sensitivity and similar aspects can have a far-reaching impact on query performance: while it may be tempting to use `string.Lower` to force a case-insensitive comparison in a case-sensitive database, doing so may prevent your application from using indexes.</span></span> <span data-ttu-id="2f75e-108">此頁面詳細說明如何設定區分大小寫或更一般的定序，以及如何以有效率的方式來設定，而不會影響查詢效能。</span><span class="sxs-lookup"><span data-stu-id="2f75e-108">This page details how to configure case sensitivity, or more generally, collations, and how to do so in an efficient way without compromising query performance.</span></span>

## <a name="introduction-to-collations"></a><span data-ttu-id="2f75e-109">定序簡介</span><span class="sxs-lookup"><span data-stu-id="2f75e-109">Introduction to collations</span></span>

<span data-ttu-id="2f75e-110">文字處理的基本概念是定序 *，這* 是一組規則，用來決定文字值的排序方式和比較是否相等。</span><span class="sxs-lookup"><span data-stu-id="2f75e-110">A fundamental concept in text processing is the *collation*, which is a set of rules determining how text values are ordered and compared for equality.</span></span> <span data-ttu-id="2f75e-111">例如，雖然不區分大小寫的定序會忽略大寫和小寫字母之間的差異以進行相等比較，但區分大小寫的定序並不會。</span><span class="sxs-lookup"><span data-stu-id="2f75e-111">For example, while a case-insensitive collation disregards differences between upper- and lower-case letters for the purposes of equality comparison, a case-sensitive collation does not.</span></span> <span data-ttu-id="2f75e-112">不過，由於區分大小寫區分文化特性 (例如 `i` ，並 `I` 以土耳其文) 表示不同的字母，因此存在多個不區分大小寫的定序，每個定序都有自己的一組規則。</span><span class="sxs-lookup"><span data-stu-id="2f75e-112">However, since case-sensitivity is culture-sensitive (e.g. `i` and `I` represent different letter in Turkish), there exist multiple case-insensitive collations, each with its own set of rules.</span></span> <span data-ttu-id="2f75e-113">定序的範圍也會延伸至不區分大小寫，以及字元資料的其他方面;例如，在德文中，有時會 (，但不一定會) 希望視為 `ä` `ae` 相同。</span><span class="sxs-lookup"><span data-stu-id="2f75e-113">The scope of collations also extends beyond case-sensitivity, to other aspects of character data; in German, for example, it is sometimes (but not always) desirable to treat `ä` and `ae` as identical.</span></span> <span data-ttu-id="2f75e-114">最後，定序也會定義文字值的 *排序* 方式：在德文之後的地方 `ä` `a` ，瑞典文會將它放在字母結尾。</span><span class="sxs-lookup"><span data-stu-id="2f75e-114">Finally, collations also define how text values are *ordered*: while German places `ä` after `a`, Swedish places it at the end of the alphabet.</span></span>

<span data-ttu-id="2f75e-115">資料庫中的所有文字作業都會使用定序（不論是明確或隱含）來判斷作業如何比較和排序字串。</span><span class="sxs-lookup"><span data-stu-id="2f75e-115">All text operations in a database use a collation - whether explicitly or implicitly - to determine how the operation compares and orders strings.</span></span> <span data-ttu-id="2f75e-116">可用定序及其命名配置的實際清單是資料庫專屬的，請參閱 [下一節](#database-specific-information) ，以取得各種資料庫相關檔頁面的連結。</span><span class="sxs-lookup"><span data-stu-id="2f75e-116">The actual list of available collations and their naming schemes is database-specific; consult [the section below](#database-specific-information) for links to relevant documentation pages of various databases.</span></span> <span data-ttu-id="2f75e-117">幸運的是，資料庫通常允許在資料庫或資料行層級定義預設的定序，並明確指定要在查詢中針對特定作業使用哪一個定序。</span><span class="sxs-lookup"><span data-stu-id="2f75e-117">Fortunately, database do generally allow a default collation to be defined at the database or column level, and to explicitly specify which collation should be use for specific operations in a query.</span></span>

## <a name="database-collation"></a><span data-ttu-id="2f75e-118">資料庫定序</span><span class="sxs-lookup"><span data-stu-id="2f75e-118">Database collation</span></span>

<span data-ttu-id="2f75e-119">在大部分的資料庫系統中，會在資料庫層級定義預設的定序。除非覆寫，否則該定序會隱含地套用至該資料庫內發生的所有文字作業。</span><span class="sxs-lookup"><span data-stu-id="2f75e-119">In most database systems, a default collation is defined at the database level; unless overridden, that collation implicitly applies to all text operations occurring within that database.</span></span> <span data-ttu-id="2f75e-120">資料庫定序通常會在資料庫建立時設定 (透過 `CREATE DATABASE` DDL 語句) ，而且如果未指定，則會預設為在安裝時所決定的某個伺服器層級值。</span><span class="sxs-lookup"><span data-stu-id="2f75e-120">The database collation is typically set at database creation time (via the `CREATE DATABASE` DDL statement), and if not specified, defaults to a some server-level value determined at setup time.</span></span> <span data-ttu-id="2f75e-121">例如，SQL Server 中的預設伺服器層級定序是 `SQL_Latin1_General_CP1_CI_AS` ，這是不區分大小寫、區分重音的定序。</span><span class="sxs-lookup"><span data-stu-id="2f75e-121">For example, the default server-level collation in SQL Server is `SQL_Latin1_General_CP1_CI_AS`, which is a case-insensitive, accent-sensitive collation.</span></span> <span data-ttu-id="2f75e-122">雖然資料庫系統通常允許變更現有資料庫的定序，但這麼做可能會造成複雜的情況;建議您在建立資料庫之前挑選定序。</span><span class="sxs-lookup"><span data-stu-id="2f75e-122">Although database systems usually do permit altering the collation of an existing database, doing so can lead to complications; it is recommended to pick a collation before database creation.</span></span>

<span data-ttu-id="2f75e-123">使用 EF Core 遷移來管理您的資料庫架構時，您模型的方法中的下列內容會將 `OnModelCreating` SQL Server 資料庫設定為使用區分大小寫的定序：</span><span class="sxs-lookup"><span data-stu-id="2f75e-123">When using EF Core migrations to manage your database schema, the following in your model's `OnModelCreating` method configures a SQL Server database to use a case-sensitive collation:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/Collations/Program.cs?name=DatabaseCollation)]

## <a name="column-collation"></a><span data-ttu-id="2f75e-124">資料行定序</span><span class="sxs-lookup"><span data-stu-id="2f75e-124">Column collation</span></span>

<span data-ttu-id="2f75e-125">您也可以在文字資料行上定義定序，並覆寫資料庫預設值。</span><span class="sxs-lookup"><span data-stu-id="2f75e-125">Collations can also be defined on text columns, overriding the database default.</span></span> <span data-ttu-id="2f75e-126">如果某些資料行必須區分大小寫，而且資料庫的其餘部分必須區分大小寫，這項功能就很有用。</span><span class="sxs-lookup"><span data-stu-id="2f75e-126">This can be useful if certain columns need to be case-insensitive, while the rest of the database needs to be case-sensitive.</span></span>

<span data-ttu-id="2f75e-127">使用 EF Core 遷移來管理您的資料庫架構時，下列內容會將屬性的資料行設定為不區分大小寫的 `Name` 資料庫中的資料行，否則會設定為區分大小寫：</span><span class="sxs-lookup"><span data-stu-id="2f75e-127">When using EF Core migrations to manage your database schema, the following configures the column for the `Name` property to be case-insensitive in a database that is otherwise configured to be case-sensitive:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/Collations/Program.cs?name=ColumnCollation)]

## <a name="explicit-collation-in-a-query"></a><span data-ttu-id="2f75e-128">查詢中的明確定序</span><span class="sxs-lookup"><span data-stu-id="2f75e-128">Explicit collation in a query</span></span>

<span data-ttu-id="2f75e-129">在某些情況下，您必須使用不同的定序來查詢相同的資料行。</span><span class="sxs-lookup"><span data-stu-id="2f75e-129">In some cases, the same column needs to be queried using different collations by different queries.</span></span> <span data-ttu-id="2f75e-130">例如，一個查詢可能需要在資料行上執行區分大小寫的比較，而另一個查詢可能需要在相同的資料行上執行不區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="2f75e-130">For example, one query may need to perform a case-sensitive comparison on a column, while another may need to perform a case-insensitive comparison on the same column.</span></span> <span data-ttu-id="2f75e-131">您可以在查詢本身內明確指定定序來完成這項作業：</span><span class="sxs-lookup"><span data-stu-id="2f75e-131">This can be accomplished by explicitly specifying a collation within the query itself:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/Collations/Program.cs?name=SimpleQueryCollation)]

<span data-ttu-id="2f75e-132">這會 `COLLATE` 在 SQL 查詢中產生子句，此子句會套用區分大小寫的定序，而不論資料行或資料庫層級所定義的定序為何：</span><span class="sxs-lookup"><span data-stu-id="2f75e-132">This generates a `COLLATE` clause in the SQL query, which applies a case-sensitive collation regardless of the collation defined at the column or database level:</span></span>

```sql
SELECT [c].[Id], [c].[Name]
FROM [Customers] AS [c]
WHERE [c].[Name] COLLATE SQL_Latin1_General_CP1_CS_AS = N'John'
```

### <a name="explicit-collations-and-indexes"></a><span data-ttu-id="2f75e-133">明確定序和索引</span><span class="sxs-lookup"><span data-stu-id="2f75e-133">Explicit collations and indexes</span></span>

<span data-ttu-id="2f75e-134">索引是資料庫效能中最重要的因素之一：使用索引有效率地執行的查詢，可以方格到沒有該索引的終止。</span><span class="sxs-lookup"><span data-stu-id="2f75e-134">Indexes are one of the most important factors in database performance - a query that runs efficiently with an index can grind to a halt without that index.</span></span> <span data-ttu-id="2f75e-135">索引會隱含地繼承其資料行的定序;這表示資料行上的所有查詢都會自動使用在該資料行上定義的索引（假設查詢未指定不同的定序）。</span><span class="sxs-lookup"><span data-stu-id="2f75e-135">Indexes implicitly inherit the collation of their column; this means that all queries on the column are automatically eligible to use indexes defined on that column - provided that the query doesn't specify a different collation.</span></span> <span data-ttu-id="2f75e-136">在查詢中指定明確定序通常會防止該查詢使用該資料行上定義的索引，因為定序將不再相符;因此，建議您在使用這項功能時務必小心。</span><span class="sxs-lookup"><span data-stu-id="2f75e-136">Specifying an explicit collation in a query will generally prevent that query from using an index defined on that column, since the collations would no longer match; it is therefore recommended to exercise caution when using this feature.</span></span> <span data-ttu-id="2f75e-137">最好是在資料行 (或資料庫) 層級定義定序，讓所有的查詢都能隱含地使用該定序，並受益于任何索引。</span><span class="sxs-lookup"><span data-stu-id="2f75e-137">It is always preferable to define the collation at the column (or database) level, allowing all queries to implicitly use that collation and benefit from any index.</span></span>

<span data-ttu-id="2f75e-138">請注意，在建立索引時，有些資料庫允許定義定序 (例如于 postgresql、Sqlite) 。</span><span class="sxs-lookup"><span data-stu-id="2f75e-138">Note that some databases allow the collation to be defined when creating an index (e.g. PostgreSQL, Sqlite).</span></span> <span data-ttu-id="2f75e-139">這可讓您在相同的資料行上定義多個索引，以不同的定序來加速作業 (例如，區分大小寫和不區分大小寫的比較) 。</span><span class="sxs-lookup"><span data-stu-id="2f75e-139">This allows multiple indexes to be defined on the same column, speeding up operations with different collations (e.g. both case-sensitive and case-insensitive comparisons).</span></span> <span data-ttu-id="2f75e-140">如需詳細資訊，請參閱資料庫提供者的檔。</span><span class="sxs-lookup"><span data-stu-id="2f75e-140">Consult your database provider's documentation for more details.</span></span>

> [!WARNING]
> <span data-ttu-id="2f75e-141">一律檢查查詢的查詢計劃，並確定在大量資料上執行的效能關鍵查詢中，使用了適當的索引。</span><span class="sxs-lookup"><span data-stu-id="2f75e-141">Always inspect the query plans of your queries, and make sure the proper indexes are being used in performance-critical queries executing over large amounts of data.</span></span> <span data-ttu-id="2f75e-142">透過 (或藉由呼叫) 來覆寫查詢中的區分大小寫， `EF.Functions.Collate` `string.ToLower` 可能會對應用程式的效能產生極大的影響。</span><span class="sxs-lookup"><span data-stu-id="2f75e-142">Overriding case-sensitivity in a query via `EF.Functions.Collate` (or by calling `string.ToLower`) can have a very significant impact on your application's performance.</span></span>

## <a name="translation-of-built-in-net-string-operations"></a><span data-ttu-id="2f75e-143">內建 .NET 字串作業的轉譯</span><span class="sxs-lookup"><span data-stu-id="2f75e-143">Translation of built-in .NET string operations</span></span>

<span data-ttu-id="2f75e-144">在 .NET 中，字串相等預設會區分大小寫： `s1 == s2` 執行需要字串相同的序數比較。</span><span class="sxs-lookup"><span data-stu-id="2f75e-144">In .NET, string equality is case-sensitive by default: `s1 == s2` performs an ordinal comparison that requires the strings to be identical.</span></span> <span data-ttu-id="2f75e-145">由於資料庫的預設定序會有所不同，而且因為很適合使用索引，所以 EF Core 不會嘗試將簡單的相等性轉譯為資料庫區分大小寫的作業： c # 相等會直接轉譯為 SQL 相等，視使用中的特定資料庫及其定序設定而定，這可能會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="2f75e-145">Because the default collation of databases varies, and because it is desirable for simple equality to use indexes, EF Core makes no attempt to translate simple equality to a database case-sensitive operation: C# equality is translated directly to SQL equality, which may or may not be case-sensitive, depending on the specific database in use and its collation configuration.</span></span>

<span data-ttu-id="2f75e-146">此外，.NET 也提供接受列舉的多載 [`string.Equals`](/dotnet/api/system.string.equals#System_String_Equals_System_String_System_StringComparison_) ，可讓您 [`StringComparison`](/dotnet/api/system.stringcomparison) 指定區分大小寫和文化特性進行比較。</span><span class="sxs-lookup"><span data-stu-id="2f75e-146">In addition, .NET provides overloads of [`string.Equals`](/dotnet/api/system.string.equals#System_String_Equals_System_String_System_StringComparison_) accepting a [`StringComparison`](/dotnet/api/system.stringcomparison) enum, which allows specifying case-sensitivity and culture for the comparison.</span></span> <span data-ttu-id="2f75e-147">根據設計，EF Core refrains 將這些多載轉譯成 SQL，並嘗試使用它們，將會導致例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2f75e-147">By design, EF Core refrains from translating these overloads to SQL, and attempting to use them will result in an exception.</span></span> <span data-ttu-id="2f75e-148">EF Core 不知道應該使用何種區分大小寫或不區分大小寫的定序。</span><span class="sxs-lookup"><span data-stu-id="2f75e-148">For one thing, EF Core does know not which case-sensitive or case-insensitive collation should be used.</span></span> <span data-ttu-id="2f75e-149">更重要的是，在大部分情況下，套用定序可能會導致索引使用，大幅影響非常基本且常用的 .NET 結構效能。</span><span class="sxs-lookup"><span data-stu-id="2f75e-149">More importantly, applying a collation would in most cases prevent index usage, significantly impacting performance for a very basic and commonly-used .NET construct.</span></span> <span data-ttu-id="2f75e-150">若要強制查詢使用區分大小寫或不區分大小寫的比較，請依照 `EF.Functions.Collate` [上述詳細](#explicit-collations-and-indexes)說明明確地指定定序。</span><span class="sxs-lookup"><span data-stu-id="2f75e-150">To force a query to use case-sensitive or case-insensitive comparison, specify a collation explicitly via `EF.Functions.Collate` as [detailed above](#explicit-collations-and-indexes).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="2f75e-151">其他資源</span><span class="sxs-lookup"><span data-stu-id="2f75e-151">Additional resources</span></span>

### <a name="database-specific-information"></a><span data-ttu-id="2f75e-152">資料庫特定資訊</span><span class="sxs-lookup"><span data-stu-id="2f75e-152">Database-specific information</span></span>

* <span data-ttu-id="2f75e-153">[有關定序的 SQL Server 檔](/sql/relational-databases/collations/collation-and-unicode-support)。</span><span class="sxs-lookup"><span data-stu-id="2f75e-153">[SQL Server documentation on collations](/sql/relational-databases/collations/collation-and-unicode-support).</span></span>
* <span data-ttu-id="2f75e-154">[有關定序的資料 Sqlite 檔](/dotnet/standard/data/sqlite/collation)。</span><span class="sxs-lookup"><span data-stu-id="2f75e-154">[Microsoft.Data.Sqlite documentation on collations](/dotnet/standard/data/sqlite/collation).</span></span>
* <span data-ttu-id="2f75e-155">[有關定序的于 postgresql 檔](https://www.postgresql.org/docs/current/collation.html)。</span><span class="sxs-lookup"><span data-stu-id="2f75e-155">[PostgreSQL documentation on collations](https://www.postgresql.org/docs/current/collation.html).</span></span>
* <span data-ttu-id="2f75e-156">[有關定序的 MySQL 檔](https://dev.mysql.com/doc/refman/en/charset-general.html)。</span><span class="sxs-lookup"><span data-stu-id="2f75e-156">[MySQL documentation on collations](https://dev.mysql.com/doc/refman/en/charset-general.html).</span></span>

### <a name="other-resources"></a><span data-ttu-id="2f75e-157">其他資源</span><span class="sxs-lookup"><span data-stu-id="2f75e-157">Other resources</span></span>

* <span data-ttu-id="2f75e-158">[EF Core 的站立會議課程](https://www.youtube.com/watch?v=OgMhLVa_VfA&list=PLdo4fOcmZ0oX-DBuRG4u58ZTAJgBAeQ-t&index=1)，介紹定序以及探索效能和索引編制方面。</span><span class="sxs-lookup"><span data-stu-id="2f75e-158">[EF Core Community Standup session](https://www.youtube.com/watch?v=OgMhLVa_VfA&list=PLdo4fOcmZ0oX-DBuRG4u58ZTAJgBAeQ-t&index=1), introducing collations and exploring perf and indexing aspects.</span></span>
