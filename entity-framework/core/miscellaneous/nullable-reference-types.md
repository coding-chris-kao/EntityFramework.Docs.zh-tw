---
title: 使用可為 null 的參考型別-EF Core
author: roji
ms.date: 09/09/2019
ms.assetid: bde4e0ee-fba3-4813-a849-27049323d301
uid: core/miscellaneous/nullable-reference-types
ms.openlocfilehash: 7d262ab9fb45535b626ce8d503b31a5e9a4630d3
ms.sourcegitcommit: 6f7af3f138bf7c724cbdda261f97e5cf7035e8d7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/25/2020
ms.locfileid: "88847562"
---
# <a name="working-with-nullable-reference-types"></a><span data-ttu-id="0524c-102">使用可為 Null 的參考型別</span><span class="sxs-lookup"><span data-stu-id="0524c-102">Working with Nullable Reference Types</span></span>

<span data-ttu-id="0524c-103">C # 8 引進了新的功能，稱為 [可為 null 的參考](/dotnet/csharp/tutorials/nullable-reference-types)型別，可讓參考型別成為批註，以指出其是否有效，以包含 null。</span><span class="sxs-lookup"><span data-stu-id="0524c-103">C# 8 introduced a new feature called [nullable reference types](/dotnet/csharp/tutorials/nullable-reference-types), allowing reference types to be annotated, indicating whether it is valid for them to contain null or not.</span></span> <span data-ttu-id="0524c-104">如果您不熟悉這項功能，建議您閱讀 c # 檔，讓自己熟悉。</span><span class="sxs-lookup"><span data-stu-id="0524c-104">If you are new to this feature, it is recommended that make yourself familiar with it by reading the C# docs.</span></span>

<span data-ttu-id="0524c-105">本頁面介紹 EF Core 對可為 null 的參考型別的支援，並說明使用這些類型的最佳作法。</span><span class="sxs-lookup"><span data-stu-id="0524c-105">This page introduces EF Core's support for nullable reference types, and describes best practices for working with them.</span></span>

## <a name="required-and-optional-properties"></a><span data-ttu-id="0524c-106">必要和選用屬性</span><span class="sxs-lookup"><span data-stu-id="0524c-106">Required and optional properties</span></span>

<span data-ttu-id="0524c-107">必要和選用屬性的主要檔，以及它們與可為 null 參考型別的互動是 [必要的和選擇性的屬性](xref:core/modeling/entity-properties#required-and-optional-properties) 頁面。</span><span class="sxs-lookup"><span data-stu-id="0524c-107">The main documentation on required and optional properties and their interaction with nullable reference types is the [Required and Optional Properties](xref:core/modeling/entity-properties#required-and-optional-properties) page.</span></span> <span data-ttu-id="0524c-108">建議您一開始先閱讀該頁面。</span><span class="sxs-lookup"><span data-stu-id="0524c-108">It is recommended you start out by reading that page first.</span></span>

> [!NOTE]
> <span data-ttu-id="0524c-109">在現有的專案上啟用可為 null 的參考型別時，請務必注意：先前設定為選用的參考型別屬性現在會設定為必要，除非它們明確標注為可為 null。</span><span class="sxs-lookup"><span data-stu-id="0524c-109">Exercise caution when enabling nullable reference types on an existing project: reference type properties which were previously configured as optional will now be configured as required, unless they are explicitly annotated to be nullable.</span></span> <span data-ttu-id="0524c-110">管理關係資料庫架構時，這可能會導致產生遷移，進而改變資料庫資料行的 null 屬性。</span><span class="sxs-lookup"><span data-stu-id="0524c-110">When managing a relational database schema, this may cause migrations to be generated which alter the database column's nullability.</span></span>

## <a name="dbcontext-and-dbset"></a><span data-ttu-id="0524c-111">DbCoNtext 和 DbSet</span><span class="sxs-lookup"><span data-stu-id="0524c-111">DbContext and DbSet</span></span>

<span data-ttu-id="0524c-112">啟用可為 null 的參考型別時，c # 編譯器會針對任何未初始化的不可為 null 的屬性發出警告，因為這些屬性會包含 null。</span><span class="sxs-lookup"><span data-stu-id="0524c-112">When nullable reference types are enabled, the C# compiler emits warnings for any uninitialized non-nullable property, as these would contain null.</span></span> <span data-ttu-id="0524c-113">因此，在內容類型上具有未初始化 DbSet 屬性的常見作法，現在會產生警告。</span><span class="sxs-lookup"><span data-stu-id="0524c-113">As a result, the common practice of having uninitialized DbSet properties on a context type will now generate a warning.</span></span> <span data-ttu-id="0524c-114">您可以依照下列方式修正此問題：</span><span class="sxs-lookup"><span data-stu-id="0524c-114">This can be fixed as follows:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/NullableReferenceTypesContext.cs?name=Context&highlight=3-4)]

<span data-ttu-id="0524c-115">另一種策略是使用不可為 null 的 auto 屬性，但若要將它們初始化為 null，請使用 null-容許運算子 (！ ) 將編譯器警告解除回應。</span><span class="sxs-lookup"><span data-stu-id="0524c-115">Another strategy is to use non-nullable auto-properties, but to initialize them to null, using the null-forgiving operator (!) to silence the compiler warning.</span></span> <span data-ttu-id="0524c-116">DbCoNtext 的函式可確保所有 DbSet 屬性都會初始化，而且永遠不會在其上觀察到 null。</span><span class="sxs-lookup"><span data-stu-id="0524c-116">The DbContext constructor ensures that all DbSet properties will get initialized, and null will never be observed on them.</span></span>

## <a name="non-nullable-properties-and-initialization"></a><span data-ttu-id="0524c-117">不可為 null 的屬性和初始化</span><span class="sxs-lookup"><span data-stu-id="0524c-117">Non-nullable properties and initialization</span></span>

<span data-ttu-id="0524c-118">未初始化的不可為 null 參考型別的編譯器警告也是實體型別上的一般屬性問題。</span><span class="sxs-lookup"><span data-stu-id="0524c-118">Compiler warnings for uninitialized non-nullable reference types are also a problem for regular properties on your entity types.</span></span> <span data-ttu-id="0524c-119">在上述範例 [中，我們使用了](xref:core/modeling/constructors)函式系結來避免這些警告，這項功能可與不可為 null 的屬性完美搭配運作，以確保一律會初始化。</span><span class="sxs-lookup"><span data-stu-id="0524c-119">In our example above, we avoided these warnings by using [constructor binding](xref:core/modeling/constructors), a feature which works perfectly with non-nullable properties, ensuring they are always initialized.</span></span> <span data-ttu-id="0524c-120">不過，在某些情況下，無法使用「函式系結」的選項：例如，無法以此方式初始化導覽屬性。</span><span class="sxs-lookup"><span data-stu-id="0524c-120">However, in some scenarios constructor binding isn't an option: navigation properties, for example, cannot be initialized in this way.</span></span>

<span data-ttu-id="0524c-121">需要的導覽屬性有額外的難度：雖然特定的主體一律會有相依的，但特定的查詢可能不會載入它，視程式中該點的需求而定 ([查看載入資料) 的不同模式](xref:core/querying/related-data) 。</span><span class="sxs-lookup"><span data-stu-id="0524c-121">Required navigation properties present an additional difficulty: although a dependent will always exist for a given principal, it may or may not be loaded by a particular query, depending on the needs at that point in the program ([see the different patterns for loading data](xref:core/querying/related-data)).</span></span> <span data-ttu-id="0524c-122">同時，您不需要讓這些屬性成為可為 null 的，因為這會強制所有這些屬性的存取權檢查是否為 null，即使它們是必要的。</span><span class="sxs-lookup"><span data-stu-id="0524c-122">At the same time, it is undesirable to make these properties nullable, since that would force all access to them to check for null, even if they are required.</span></span>

<span data-ttu-id="0524c-123">處理這些案例的其中一種方式，是讓不可為 null 的屬性具有可為 null 的 [支援欄位](xref:core/modeling/backing-field)：</span><span class="sxs-lookup"><span data-stu-id="0524c-123">One way to deal with these scenarios, is to have a non-nullable property with a nullable [backing field](xref:core/modeling/backing-field):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=10-17)]

<span data-ttu-id="0524c-124">因為導覽屬性不可為 null，所以會設定必要的導覽;只要正確載入流覽，就可以透過屬性存取相依的。</span><span class="sxs-lookup"><span data-stu-id="0524c-124">Since the navigation property is non-nullable, a required navigation is configured; and as long as the navigation is properly loaded, the dependent will be accessible via the property.</span></span> <span data-ttu-id="0524c-125">但是，如果在沒有先正確載入相關實體的情況下存取屬性，則會擲回 InvalidOperationException，因為 API 合約的使用不正確。</span><span class="sxs-lookup"><span data-stu-id="0524c-125">If, however, the property is accessed without first properly loading the related entity, an InvalidOperationException is thrown, since the API contract has been used incorrectly.</span></span> <span data-ttu-id="0524c-126">請注意，EF 必須設定為一律存取支援欄位，而不是屬性（property），因為它依賴能夠讀取值（即使未設定）。請參閱有關如何執行這項作業的 [支援欄位](xref:core/modeling/backing-field) 檔，並考慮指定 `PropertyAccessMode.Field` 以確定設定是否正確。</span><span class="sxs-lookup"><span data-stu-id="0524c-126">Note that EF must be configured to always access the backing field and not the property, as it relies on being able to read the value even when unset; consult the documentation on [backing fields](xref:core/modeling/backing-field) on how to do this, and consider specifying `PropertyAccessMode.Field` to make sure the configuration is correct.</span></span>

<span data-ttu-id="0524c-127">作為 terser 的替代方案，您可以直接使用容許運算子的協助將屬性初始化為 null， (！ ) ：</span><span class="sxs-lookup"><span data-stu-id="0524c-127">As a terser alternative, it is possible to simply initialize the property to null with the help of the null-forgiving operator (!):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=19)]

<span data-ttu-id="0524c-128">由於程式設計錯誤的結果，將永遠不會觀察實際的 null 值，例如存取導覽屬性，而不事先適當地載入相關實體。</span><span class="sxs-lookup"><span data-stu-id="0524c-128">An actual null value will never be observed except as a result of a programming bug, e.g. accessing the navigation property without properly loading the related entity beforehand.</span></span>

> [!NOTE]
> <span data-ttu-id="0524c-129">集合導覽（包含多個相關實體的參考）應該一律為不可為 null。</span><span class="sxs-lookup"><span data-stu-id="0524c-129">Collection navigations, which contain references to multiple related entities, should always be non-nullable.</span></span> <span data-ttu-id="0524c-130">空集合表示沒有相關的實體，但清單本身絕對不能是 null。</span><span class="sxs-lookup"><span data-stu-id="0524c-130">An empty collection means that no related entities exist, but the list itself should never be null.</span></span>

## <a name="navigating-and-including-nullable-relationships"></a><span data-ttu-id="0524c-131">導覽及包含可為 null 的關聯性</span><span class="sxs-lookup"><span data-stu-id="0524c-131">Navigating and including nullable relationships</span></span>

<span data-ttu-id="0524c-132">處理選擇性關聯性時，可能會遇到可能不可能發生實際 null 參考例外狀況的編譯器警告。</span><span class="sxs-lookup"><span data-stu-id="0524c-132">When dealing with optional relationships, it's possible to encounter compiler warnings where an actual null reference exception would be impossible.</span></span> <span data-ttu-id="0524c-133">轉譯和執行 LINQ 查詢時，EF Core 保證如果選擇性的相關實體不存在，則會直接忽略它的任何導覽，而不會擲回。</span><span class="sxs-lookup"><span data-stu-id="0524c-133">When translating and executing your LINQ queries, EF Core guarantees that if an optional related entity does not exist, any navigation to it will simply be ignored, rather than throwing.</span></span> <span data-ttu-id="0524c-134">不過，編譯器並不知道此 EF Core 保證，並會產生警告，就像 LINQ 查詢是在記憶體中執行，並具有 LINQ to Objects 一樣。</span><span class="sxs-lookup"><span data-stu-id="0524c-134">However, the compiler is unaware of this EF Core guarantee, and produces warnings as if the LINQ query were executed in memory, with LINQ to Objects.</span></span> <span data-ttu-id="0524c-135">如此一來，就必須使用容許運算子 (！ ) 來通知編譯器，不可能有實際的 null 值：</span><span class="sxs-lookup"><span data-stu-id="0524c-135">As a result, it is necessary to use the null-forgiving operator (!) to inform the compiler that an actual null value isn't possible:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=46)]

<span data-ttu-id="0524c-136">在選擇性導覽中包含多個層級的關聯性時，會發生類似的問題：</span><span class="sxs-lookup"><span data-stu-id="0524c-136">A similar issue occurs when including multiple levels of relationships across optional navigations:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=36-39&highlight=2)]

<span data-ttu-id="0524c-137">如果您覺得自己這麼做很多，而且問題中的實體類型主要是 (或獨佔) 用於 EF Core 查詢中，請考慮將導覽屬性設為不可為 null，並透過流暢的 API 或資料批註將其設定為選擇性。</span><span class="sxs-lookup"><span data-stu-id="0524c-137">If you find yourself doing this a lot, and the entity types in question are predominantly (or exclusively) used in EF Core queries, consider making the navigation properties non-nullable, and to configure them as optional via the Fluent API or Data Annotations.</span></span> <span data-ttu-id="0524c-138">這會移除所有編譯器警告，同時保留關聯性。但是，如果您的實體是在 EF Core 之外進行，您可能會觀察到 null 值，但屬性會標注為不可為 null。</span><span class="sxs-lookup"><span data-stu-id="0524c-138">This will remove all compiler warnings while keeping the relationship optional; however, if your entities are traversed outside of EF Core, you may observe null values although the properties are annotated as non-nullable.</span></span>

## <a name="limitations"></a><span data-ttu-id="0524c-139">限制</span><span class="sxs-lookup"><span data-stu-id="0524c-139">Limitations</span></span>

* <span data-ttu-id="0524c-140">反向工程目前不支援 [c # 8 可為 null 的參考型別 (NRTs) ](/dotnet/csharp/tutorials/nullable-reference-types)： EF Core 一律會產生假設功能已關閉的 c # 程式碼。</span><span class="sxs-lookup"><span data-stu-id="0524c-140">Reverse engineering does not currently support [C# 8 nullable reference types (NRTs)](/dotnet/csharp/tutorials/nullable-reference-types): EF Core always generates C# code that assumes the feature is off.</span></span> <span data-ttu-id="0524c-141">例如，可為 null 的文字資料行將 scaffold 為類型的屬性，而不是使用 `string` `string?` 流暢的 API 或資料批註來設定是否需要屬性。</span><span class="sxs-lookup"><span data-stu-id="0524c-141">For example, nullable text columns will be scaffolded as a property with type `string` , not `string?`, with either the Fluent API or Data Annotations used to configure whether a property is required or not.</span></span> <span data-ttu-id="0524c-142">您可以編輯 scaffold 程式碼，並以 c # 可 null 性注釋取代這些程式碼。</span><span class="sxs-lookup"><span data-stu-id="0524c-142">You can edit the scaffolded code and replace these with C# nullability annotations.</span></span> <span data-ttu-id="0524c-143">問題 [#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520)會追蹤可為 null 之參考型別的型別支援。</span><span class="sxs-lookup"><span data-stu-id="0524c-143">Scaffolding support for nullable reference types is tracked by issue [#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520).</span></span>
* <span data-ttu-id="0524c-144">EF Core 的公用 API 介面尚未標注為可 null 性 (公用 API 為 "無警示" ) ，因此在開啟 NRT 功能時，有時很難使用。</span><span class="sxs-lookup"><span data-stu-id="0524c-144">EF Core's public API surface has not yet been annotated for nullability (the public API is "null-oblivious"), making it sometimes awkward to use when the NRT feature is turned on.</span></span> <span data-ttu-id="0524c-145">這特別包含 EF Core 所公開的非同步 LINQ 運算子，例如 [singleordefaultasync](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_)。</span><span class="sxs-lookup"><span data-stu-id="0524c-145">This notably includes the async LINQ operators exposed by EF Core, such as [FirstOrDefaultAsync](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_).</span></span> <span data-ttu-id="0524c-146">我們計畫在5.0 版中解決此情況。</span><span class="sxs-lookup"><span data-stu-id="0524c-146">We plan to address this for the 5.0 release.</span></span>
