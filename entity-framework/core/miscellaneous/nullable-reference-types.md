---
title: 使用可為 null 的參考型別-EF Core
author: roji
ms.date: 09/09/2019
ms.assetid: bde4e0ee-fba3-4813-a849-27049323d301
uid: core/miscellaneous/nullable-reference-types
ms.openlocfilehash: c16a475c363320cd18804a4efe78ccae1ae22f0d
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78416652"
---
# <a name="working-with-nullable-reference-types"></a><span data-ttu-id="63ea3-102">使用可為 Null 的參考型別</span><span class="sxs-lookup"><span data-stu-id="63ea3-102">Working with Nullable Reference Types</span></span>

<span data-ttu-id="63ea3-103">C#8引進了一個稱為[nullable 參考型別](/dotnet/csharp/tutorials/nullable-reference-types)的新功能，允許標注參考型別，指出其是否有效，以包含 null。</span><span class="sxs-lookup"><span data-stu-id="63ea3-103">C# 8 introduced a new feature called [nullable reference types](/dotnet/csharp/tutorials/nullable-reference-types), allowing reference types to be annotated, indicating whether it is valid for them to contain null or not.</span></span> <span data-ttu-id="63ea3-104">如果您是這項功能的新手，建議您閱讀C#檔，讓自己熟悉它。</span><span class="sxs-lookup"><span data-stu-id="63ea3-104">If you are new to this feature, it is recommended that make yourself familiar with it by reading the C# docs.</span></span>

<span data-ttu-id="63ea3-105">本頁面介紹可為 null 參考型別的 EF Core 支援，並說明使用它們的最佳作法。</span><span class="sxs-lookup"><span data-stu-id="63ea3-105">This page introduces EF Core's support for nullable reference types, and describes best practices for working with them.</span></span>

## <a name="required-and-optional-properties"></a><span data-ttu-id="63ea3-106">必要和選擇性屬性</span><span class="sxs-lookup"><span data-stu-id="63ea3-106">Required and optional properties</span></span>

<span data-ttu-id="63ea3-107">必要和選擇性屬性的主要檔以及其與 nullable 參考型別的互動，都是[必要和選擇性的屬性](xref:core/modeling/entity-properties#required-and-optional-properties)頁面。</span><span class="sxs-lookup"><span data-stu-id="63ea3-107">The main documentation on required and optional properties and their interaction with nullable reference types is the [Required and Optional Properties](xref:core/modeling/entity-properties#required-and-optional-properties) page.</span></span> <span data-ttu-id="63ea3-108">建議您一開始先閱讀該頁面。</span><span class="sxs-lookup"><span data-stu-id="63ea3-108">It is recommended you start out by reading that page first.</span></span>

> [!NOTE]
> <span data-ttu-id="63ea3-109">在現有專案上啟用可為 null 的參考型別時，請特別注意：先前設定為選擇性的參考類型屬性現在會設定為必要，除非它們已明確標注成可為 null。</span><span class="sxs-lookup"><span data-stu-id="63ea3-109">Exercise caution when enabling nullable reference types on an existing project: reference type properties which were previously configured as optional will now be configured as required, unless they are explicitly annotated to be nullable.</span></span> <span data-ttu-id="63ea3-110">管理關係資料庫架構時，這可能會產生可改變資料庫資料行之 null 屬性的遷移。</span><span class="sxs-lookup"><span data-stu-id="63ea3-110">When managing a relational database schema, this may cause migrations to be generated which alter the database column's nullability.</span></span>

## <a name="dbcontext-and-dbset"></a><span data-ttu-id="63ea3-111">DbCoNtext 和 DbSet</span><span class="sxs-lookup"><span data-stu-id="63ea3-111">DbContext and DbSet</span></span>

<span data-ttu-id="63ea3-112">當可為 null 的參考型別啟用C#時，編譯器會針對任何未初始化的不可為 null 屬性發出警告，因為這會包含 null。</span><span class="sxs-lookup"><span data-stu-id="63ea3-112">When nullable reference types are enabled, the C# compiler emits warnings for any uninitialized non-nullable property, as these would contain null.</span></span> <span data-ttu-id="63ea3-113">因此，在內容上定義不可為 null `DbSet` 的常見作法，現在會產生警告。</span><span class="sxs-lookup"><span data-stu-id="63ea3-113">As a result, the common practice of defining a non-nullable `DbSet` on a context will now generate a warning.</span></span> <span data-ttu-id="63ea3-114">不過，EF Core 一律會初始化 DbCoNtext 衍生類型上的所有 `DbSet` 屬性，因此即使編譯器不知道這一點，也一定會是 null。</span><span class="sxs-lookup"><span data-stu-id="63ea3-114">However, EF Core always initializes all `DbSet` properties on DbContext-derived types, so they are guaranteed to never be null, even if the compiler is unaware of this.</span></span> <span data-ttu-id="63ea3-115">因此，建議您將 `DbSet` 屬性保持為不可為 null-可讓您在沒有 null 檢查的情況下存取它們，並藉由使用 null 容許運算子（！）的協助明確將其設定為 null，以回應編譯器警告：</span><span class="sxs-lookup"><span data-stu-id="63ea3-115">Therefore, it is recommended to keep your `DbSet` properties non-nullable - allowing you to access them without null checks - and to silence the compiler warnings by explicitly setting them to null with the help of the null-forgiving operator (!):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/NullableReferenceTypesContext.cs?name=Context&highlight=3-4)]

## <a name="non-nullable-properties-and-initialization"></a><span data-ttu-id="63ea3-116">不可為 null 的屬性和初始化</span><span class="sxs-lookup"><span data-stu-id="63ea3-116">Non-nullable properties and initialization</span></span>

<span data-ttu-id="63ea3-117">未初始化之不可為 null 的參考型別的編譯器警告也是實體類型上一般屬性的問題。</span><span class="sxs-lookup"><span data-stu-id="63ea3-117">Compiler warnings for uninitialized non-nullable reference types are also a problem for regular properties on your entity types.</span></span> <span data-ttu-id="63ea3-118">在上述範例中，我們使用「函式系結」來避免這些[警告，這](xref:core/modeling/constructors)項功能可與不可為 null 的屬性完美搭配運作，確保它們一律會初始化。</span><span class="sxs-lookup"><span data-stu-id="63ea3-118">In our example above, we avoided these warnings by using [constructor binding](xref:core/modeling/constructors), a feature which works perfectly with non-nullable properties, ensuring they are always initialized.</span></span> <span data-ttu-id="63ea3-119">不過，在某些情況下，不會有一個選項：例如，無法以這種方式初始化導覽屬性。</span><span class="sxs-lookup"><span data-stu-id="63ea3-119">However, in some scenarios constructor binding isn't an option: navigation properties, for example, cannot be initialized in this way.</span></span>

<span data-ttu-id="63ea3-120">必要的導覽屬性有額外的困難：雖然特定主體的相依一定會存在，但根據程式中該點的需求（[請參閱載入資料的不同模式](xref:core/querying/related-data)），特定的查詢可能也不會載入它。</span><span class="sxs-lookup"><span data-stu-id="63ea3-120">Required navigation properties present an additional difficulty: although a dependent will always exist for a given principal, it may or may not be loaded by a particular query, depending on the needs at that point in the program ([see the different patterns for loading data](xref:core/querying/related-data)).</span></span> <span data-ttu-id="63ea3-121">同時，您不需要讓這些屬性成為可為 null，因為這會強制所有的存取權檢查是否為 null，即使是必要的也一樣。</span><span class="sxs-lookup"><span data-stu-id="63ea3-121">At the same time, it is undesirable to make these properties nullable, since that would force all access to them to check for null, even if they are required.</span></span>

<span data-ttu-id="63ea3-122">處理這些案例的其中一種方式，是將不可為 null 的屬性與可為 null 的[支援欄位](xref:core/modeling/backing-field)搭配使用：</span><span class="sxs-lookup"><span data-stu-id="63ea3-122">One way to deal with these scenarios, is to have a non-nullable property with a nullable [backing field](xref:core/modeling/backing-field):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=10-17)]

<span data-ttu-id="63ea3-123">由於導覽屬性不可為 null，因此會設定必要的導覽;而且只要正確載入導覽，就可以透過屬性存取相依性。</span><span class="sxs-lookup"><span data-stu-id="63ea3-123">Since the navigation property is non-nullable, a required navigation is configured; and as long as the navigation is properly loaded, the dependent will be accessible via the property.</span></span> <span data-ttu-id="63ea3-124">不過，如果在沒有第一次正確載入相關實體的情況下存取屬性，則會擲回 InvalidOperationException，因為 API 合約的使用不正確。</span><span class="sxs-lookup"><span data-stu-id="63ea3-124">If, however, the property is accessed without first properly loading the related entity, an InvalidOperationException is thrown, since the API contract has been used incorrectly.</span></span> <span data-ttu-id="63ea3-125">請注意，EF 必須設定為一律存取支援欄位，而不是屬性，因為它依賴能夠讀取值，即使未設定也是如此。請參閱[支援欄位](xref:core/modeling/backing-field)上的檔，以瞭解如何執行此操作，並考慮指定 `PropertyAccessMode.Field` 以確保設定正確。</span><span class="sxs-lookup"><span data-stu-id="63ea3-125">Note that EF must be configured to always access the backing field and not the property, as it relies on being able to read the value even when unset; consult the documentation on [backing fields](xref:core/modeling/backing-field) on how to do this, and consider specifying `PropertyAccessMode.Field` to make sure the configuration is correct.</span></span>

<span data-ttu-id="63ea3-126">做為 terser 的替代方案，您可以使用 null 容許運算子（！）的協助，將屬性初始化為 null：</span><span class="sxs-lookup"><span data-stu-id="63ea3-126">As a terser alternative, it is possible to simply initialize the property to null with the help of the null-forgiving operator (!):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=19)]

<span data-ttu-id="63ea3-127">除非發生程式設計錯誤（例如存取導覽屬性而不事先適當載入相關實體），否則永遠不會觀察到實際的 null 值。</span><span class="sxs-lookup"><span data-stu-id="63ea3-127">An actual null value will never be observed except as a result of a programming bug, e.g. accessing the navigation property without properly loading the related entity beforehand.</span></span>

> [!NOTE]
> <span data-ttu-id="63ea3-128">包含多個相關實體參考的集合導覽，應一律不可為 null。</span><span class="sxs-lookup"><span data-stu-id="63ea3-128">Collection navigations, which contain references to multiple related entities, should always be non-nullable.</span></span> <span data-ttu-id="63ea3-129">空集合表示沒有相關的實體存在，但清單本身絕對不應為 null。</span><span class="sxs-lookup"><span data-stu-id="63ea3-129">An empty collection means that no related entities exist, but the list itself should never be null.</span></span>

## <a name="navigating-and-including-nullable-relationships"></a><span data-ttu-id="63ea3-130">導覽和包含可為 null 的關聯性</span><span class="sxs-lookup"><span data-stu-id="63ea3-130">Navigating and including nullable relationships</span></span>

<span data-ttu-id="63ea3-131">處理選擇性關聯性時，可能會遇到不可能發生實際 null 參考例外狀況的編譯器警告。</span><span class="sxs-lookup"><span data-stu-id="63ea3-131">When dealing with optional relationships, it's possible to encounter compiler warnings where an actual null reference exception would be impossible.</span></span> <span data-ttu-id="63ea3-132">轉譯和執行 LINQ 查詢時，EF Core 保證如果有選擇性的相關實體不存在，則會直接忽略它的任何導覽，而不是擲回。</span><span class="sxs-lookup"><span data-stu-id="63ea3-132">When translating and executing your LINQ queries, EF Core guarantees that if an optional related entity does not exist, any navigation to it will simply be ignored, rather than throwing.</span></span> <span data-ttu-id="63ea3-133">不過，編譯器不會察覺這項 EF Core 保證，而且會產生警告，如同 LINQ 查詢已在記憶體中執行，並具有 LINQ to Objects。</span><span class="sxs-lookup"><span data-stu-id="63ea3-133">However, the compiler is unaware of this EF Core guarantee, and produces warnings as if the LINQ query were executed in memory, with LINQ to Objects.</span></span> <span data-ttu-id="63ea3-134">因此，必須使用 null 容許運算子（！）來通知編譯器，實際的 null 值不可能：</span><span class="sxs-lookup"><span data-stu-id="63ea3-134">As a result, it is necessary to use the null-forgiving operator (!) to inform the compiler that an actual null value isn't possible:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=46)]

<span data-ttu-id="63ea3-135">在選擇性的導覽中包含多個關聯性層級時，就會發生類似的問題：</span><span class="sxs-lookup"><span data-stu-id="63ea3-135">A similar issue occurs when including multiple levels of relationships across optional navigations:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=36-39&highlight=2)]

<span data-ttu-id="63ea3-136">如果您發現自己這麼做很多，而且有問題的實體類型主要（或專門）用於 EF Core 查詢，請考慮將導覽屬性設為不可為 null，並透過流暢的 API 或資料批註，將其設定為選擇性。</span><span class="sxs-lookup"><span data-stu-id="63ea3-136">If you find yourself doing this a lot, and the entity types in question are predominantly (or exclusively) used in EF Core queries, consider making the navigation properties non-nullable, and to configure them as optional via the Fluent API or Data Annotations.</span></span> <span data-ttu-id="63ea3-137">這會移除所有編譯器警告，同時保持關聯性的選擇性;不過，如果您的實體在 EF Core 之外進行遍歷，您可能會觀察到 null 值，雖然屬性會標注為不可為 null。</span><span class="sxs-lookup"><span data-stu-id="63ea3-137">This will remove all compiler warnings while keeping the relationship optional; however, if your entities are traversed outside of EF Core, you may observe null values although the properties are annotated as non-nullable.</span></span>

## <a name="limitations"></a><span data-ttu-id="63ea3-138">限制</span><span class="sxs-lookup"><span data-stu-id="63ea3-138">Limitations</span></span>

* <span data-ttu-id="63ea3-139">反向工程目前不支援[ C# 8 個可為 null 的參考型別（NRTs）](/dotnet/csharp/tutorials/nullable-reference-types)： C# EF Core 一律會產生假設此功能已關閉的程式碼。</span><span class="sxs-lookup"><span data-stu-id="63ea3-139">Reverse engineering does not currently support [C# 8 nullable reference types (NRTs)](/dotnet/csharp/tutorials/nullable-reference-types): EF Core always generates C# code that assumes the feature is off.</span></span> <span data-ttu-id="63ea3-140">例如，可為 null 的文字資料行將會 scaffold 為具有類型 `string` 的屬性，而不是 `string?`，其中包含用來設定是否需要屬性的流暢 API 或資料批註。</span><span class="sxs-lookup"><span data-stu-id="63ea3-140">For example, nullable text columns will be scaffolded as a property with type `string` , not `string?`, with either the Fluent API or Data Annotations used to configure whether a property is required or not.</span></span> <span data-ttu-id="63ea3-141">您可以編輯 scaffold 程式碼，並將其C#取代為 null 屬性注釋。</span><span class="sxs-lookup"><span data-stu-id="63ea3-141">You can edit the scaffolded code and replace these with C# nullability annotations.</span></span> <span data-ttu-id="63ea3-142">由問題[#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520)追蹤可為 null 之參考型別的樣板支援。</span><span class="sxs-lookup"><span data-stu-id="63ea3-142">Scaffolding support for nullable reference types is tracked by issue [#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520).</span></span>
* <span data-ttu-id="63ea3-143">EF Core 的公用 API 介面尚未標注 null 屬性（公用 API 是 "null-遺忘式"），因此在開啟 NRT 功能時，有時會很難使用。</span><span class="sxs-lookup"><span data-stu-id="63ea3-143">EF Core's public API surface has not yet been annotated for nullability (the public API is "null-oblivious"), making it sometimes awkward to use when the NRT feature is turned on.</span></span> <span data-ttu-id="63ea3-144">這值得注意的是，EF Core 所公開的非同步 LINQ 運算子，例如[FirstOrDefaultAsync](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_)。</span><span class="sxs-lookup"><span data-stu-id="63ea3-144">This notably includes the async LINQ operators exposed by EF Core, such as [FirstOrDefaultAsync](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_).</span></span> <span data-ttu-id="63ea3-145">我們計畫在5.0 版本中解決此情況。</span><span class="sxs-lookup"><span data-stu-id="63ea3-145">We plan to address this for the 5.0 release.</span></span>
