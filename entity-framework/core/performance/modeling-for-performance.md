---
title: 效能模型-EF Core
description: 在使用 Entity Framework Core 時有效率地建立模型
author: roji
ms.date: 12/1/2020
uid: core/performance/modeling-for-performance
ms.openlocfilehash: 882398189cc828798c1682f849fac524d90d317f
ms.sourcegitcommit: 4798ab8d04c1fdbe6dd204d94d770fcbf309d09b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/11/2021
ms.locfileid: "103023857"
---
# <a name="modeling-for-performance"></a><span data-ttu-id="75b46-103">效能模型</span><span class="sxs-lookup"><span data-stu-id="75b46-103">Modeling for Performance</span></span>

<span data-ttu-id="75b46-104">在許多情況下，您模型的方式可能會對應用程式的效能造成深遠的影響;雖然正確正規化和「正確」模型通常是很好的起點，但在真實世界的應用程式中，有一些實際的折衷方法可達到良好的效能。</span><span class="sxs-lookup"><span data-stu-id="75b46-104">In many cases, the way you model can have a profound impact on the performance of your application; while a properly normalized and "correct" model is usually a good starting point, in real-world applications some pragmatic compromises can go a long way for achieving good performance.</span></span> <span data-ttu-id="75b46-105">當應用程式在生產環境中執行時，因為很難變更您的模型，所以在建立初始模型時值得記住效能。</span><span class="sxs-lookup"><span data-stu-id="75b46-105">Since it's quite difficult to change your model once an application is running in production, it's worth keeping performance in mind when creating the initial model.</span></span>

## <a name="denormalization-and-caching"></a><span data-ttu-id="75b46-106">反正規化和快取</span><span class="sxs-lookup"><span data-stu-id="75b46-106">Denormalization and caching</span></span>

<span data-ttu-id="75b46-107">反 *正規化是在* 架構中加入多餘資料的作法，通常是為了在查詢時排除聯結。</span><span class="sxs-lookup"><span data-stu-id="75b46-107">*Denormalization* is the practice of adding redundant data to your schema, usually in order to eliminate joins when querying.</span></span> <span data-ttu-id="75b46-108">例如，針對具有 Blog 和貼文的模型，其中每個貼文都有評等，您可能需要經常顯示該 Blog 的平均評等。</span><span class="sxs-lookup"><span data-stu-id="75b46-108">For example, for a model with Blogs and Posts, where each Post has a Rating, you may be required to frequently show the average rating of the Blog.</span></span> <span data-ttu-id="75b46-109">簡單的方法是將貼文依其 Blog 分組，並將平均值計算為查詢的一部分;但這需要兩個數據表之間的昂貴聯結。</span><span class="sxs-lookup"><span data-stu-id="75b46-109">The simple approach to this would group the Posts by their Blog, and calculate the average as part of the query; but this requires a costly join between the two tables.</span></span> <span data-ttu-id="75b46-110">反正規化會將所有貼文的計算平均值新增至 Blog 上的新資料行，讓它可以立即存取，而不需要加入或計算。</span><span class="sxs-lookup"><span data-stu-id="75b46-110">Denormalization would add the calculated average of all posts to a new column on Blog, so that it is immediately accessible, without joining or calculating.</span></span>

<span data-ttu-id="75b46-111">您可以將上述內容視為快 *取的形式* ，也就是在其 Blog 上快取貼文中的匯總資訊。就像使用任何快取一樣，問題在於如何讓快取的值與快取的資料保持在最新狀態。</span><span class="sxs-lookup"><span data-stu-id="75b46-111">The above can be viewed as a form of *caching* - aggregate information from the Posts is cached on their Blog; and like with any caching, the problem is how to keep the cached value up to date with the data it's caching.</span></span> <span data-ttu-id="75b46-112">在許多情況下，快取的資料會延遲一點;例如，在上述範例中，在任何指定的時間點，blog 的平均評等通常是合理的，而不是完全保持最新狀態。</span><span class="sxs-lookup"><span data-stu-id="75b46-112">In many cases, it's OK for the cached data to lag for a bit; for example, in the example above, it's usually reasonable for the blog's average rating to not be completely up to date at any given point.</span></span> <span data-ttu-id="75b46-113">如果是這種情況，您可以讓它每次重新計算一次，然後：否則，就必須設定更詳盡的系統，讓快取的值保持在最新狀態。</span><span class="sxs-lookup"><span data-stu-id="75b46-113">If that's the case, you can have it recalculated every now and then; otherwise, a more elaborate system must be set up to keep the cached values up to date.</span></span>

<span data-ttu-id="75b46-114">以下將詳細說明 EF Core 中的正規化和快取技術，並指向檔中的相關章節。</span><span class="sxs-lookup"><span data-stu-id="75b46-114">The following details some techniques for denormalization and caching in EF Core, and points to the relevant sections in the documentation.</span></span>

### <a name="stored-computed-columns"></a><span data-ttu-id="75b46-115">儲存的計算資料行</span><span class="sxs-lookup"><span data-stu-id="75b46-115">Stored computed columns</span></span>

<span data-ttu-id="75b46-116">如果要快取的資料是相同資料表中其他資料行的產品，則儲存的 [計算資料行](xref:core/modeling/generated-properties#computed-columns) 可以是理想的方案。</span><span class="sxs-lookup"><span data-stu-id="75b46-116">If the data to be cached is a product of other columns in the same table, then a [stored computed column](xref:core/modeling/generated-properties#computed-columns) can be a perfect solution.</span></span> <span data-ttu-id="75b46-117">例如， `Customer` 可能有和資料 `FirstName` `LastName` 行，但我們可能需要依客戶的 *全名* 進行搜尋。</span><span class="sxs-lookup"><span data-stu-id="75b46-117">For example, a `Customer` may have `FirstName` and `LastName` columns, but we may need to search by the customer's *full name*.</span></span> <span data-ttu-id="75b46-118">資料庫會自動維護儲存的計算資料行，這會在資料列變更時重新計算資料行，而且您甚至可以透過它定義索引，以加速查詢。</span><span class="sxs-lookup"><span data-stu-id="75b46-118">A stored computed column is automatically maintained by the database - which recalculates it whenever the row is changed - and you can even define an index over it to speed up queries.</span></span>

### <a name="update-cache-columns-when-inputs-change"></a><span data-ttu-id="75b46-119">在輸入變更時更新快取資料行</span><span class="sxs-lookup"><span data-stu-id="75b46-119">Update cache columns when inputs change</span></span>

<span data-ttu-id="75b46-120">如果您的快取資料行需要從資料表的資料列外部參考輸入，您就無法使用計算資料行。</span><span class="sxs-lookup"><span data-stu-id="75b46-120">If your cached column needs to reference inputs from outside the table's row, you cannot use computed columns.</span></span> <span data-ttu-id="75b46-121">不過，您仍然可以在每次輸入變更時重新計算資料行;例如，您可以在每次變更、新增或移除 Post 時，重新計算平均 Blog 的評等。</span><span class="sxs-lookup"><span data-stu-id="75b46-121">However, it is still possible to recalculate the column whenever its input changes; for example, you could recalculate the average Blog's rating every time a Post is changed, added or removed.</span></span> <span data-ttu-id="75b46-122">在需要重新計算時，請務必識別確切的條件，否則快取的值將不會同步。</span><span class="sxs-lookup"><span data-stu-id="75b46-122">Be sure to identify the exact conditions when recalculation is needed, otherwise your cached value will go out of sync.</span></span>

<span data-ttu-id="75b46-123">執行這項作業的其中一種方式，是透過一般 EF Core API 自行執行更新。</span><span class="sxs-lookup"><span data-stu-id="75b46-123">One way to do this, is to perform the update yourself, via the regular EF Core API.</span></span> <span data-ttu-id="75b46-124">`SaveChanges`[事件](xref:core/logging-events-diagnostics/events)或[攔截](xref:core/logging-events-diagnostics/interceptors#savechanges-interception)器可以用來自動檢查是否有任何文章正在更新，並以該方式執行重新計算。</span><span class="sxs-lookup"><span data-stu-id="75b46-124">`SaveChanges` [Events](xref:core/logging-events-diagnostics/events) or [interceptors](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) can be used to automatically check if any Posts are being updated, and to perform the recalculation that way.</span></span> <span data-ttu-id="75b46-125">請注意，這通常需要額外的資料庫往返，因為必須傳送額外的命令。</span><span class="sxs-lookup"><span data-stu-id="75b46-125">Note that this typically entails additional database roundtrips, as additional commands must be sent.</span></span>

<span data-ttu-id="75b46-126">對於更有效能影響的應用程式，可以定義資料庫觸發程式，以在資料庫中自動執行重新計算。</span><span class="sxs-lookup"><span data-stu-id="75b46-126">For more perf-sensitive applications, database triggers can be defined to automatically perform the recalculation in the database.</span></span> <span data-ttu-id="75b46-127">這會儲存額外的資料庫往返、自動發生在與主要更新相同的交易中，而且可能更容易設定。</span><span class="sxs-lookup"><span data-stu-id="75b46-127">This saves the extra database roundtrips, automatically occurs within the same transaction as the main update, and can be simpler to set up.</span></span> <span data-ttu-id="75b46-128">EF 未提供任何特定的 API 來建立或維護觸發程式，但您可以 [建立空白的遷移，並透過原始 SQL 新增觸發程序定義](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)。</span><span class="sxs-lookup"><span data-stu-id="75b46-128">EF doesn't provide any specific API for creating or maintaining triggers, but it's perfectly fine to [create an empty migration and add the trigger definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

### <a name="materialized-views"></a><span data-ttu-id="75b46-129">具體化檢視</span><span class="sxs-lookup"><span data-stu-id="75b46-129">Materialized views</span></span>

<span data-ttu-id="75b46-130">具體化視圖類似于一般視圖，不同之處在于其資料會儲存在磁片 ( 「具體化」 ) ，而不是每次查詢檢視時計算。</span><span class="sxs-lookup"><span data-stu-id="75b46-130">Materialized views are similar to regular views, except that their data is stored on disk ("materialized"), rather than calculated every time when the view is queried.</span></span> <span data-ttu-id="75b46-131">當您不想只要將單一快取資料行加入至現有的資料庫，但想要快取複雜且昂貴之查詢結果的整個 resultset 時（就像是一般資料表），這項工具就很有用。然後，您可以在不進行任何計算或聯結的情況下，低廉價格查詢這些結果。</span><span class="sxs-lookup"><span data-stu-id="75b46-131">This tool is useful when you don't want to simply add a single cache column to an existing database, but rather want to cache the entire resultset of a complicated and expensive query's results, just as if it were a regular table; these results can then be queried very cheaply without any computation or joins happening.</span></span> <span data-ttu-id="75b46-132">不同于計算資料行，具體化視圖不會在其基礎資料表變更時自動更新-必須以手動方式重新整理。</span><span class="sxs-lookup"><span data-stu-id="75b46-132">Unlike computed columns, materialized views aren't automatically updated when their underlying tables change - they must be manually refreshed.</span></span> <span data-ttu-id="75b46-133">如果快取的資料可能會延後，您可以透過計時器來重新整理視圖;另一個選項是設定資料庫觸發程式，以在發生特定資料庫事件時，檢查具體化的觀點。</span><span class="sxs-lookup"><span data-stu-id="75b46-133">If the cached data can lag, refreshing the view can be done via a timer; another option is to set up database triggers to review a materialized view once certain database events occur.</span></span>

<span data-ttu-id="75b46-134">EF 目前未提供任何特定的 API 來建立或維護視圖，具體化為; 否則為。但是， [建立空白的遷移並透過原始 SQL 加入 view 定義](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)是完全好的方式。</span><span class="sxs-lookup"><span data-stu-id="75b46-134">EF doesn't currently provide any specific API for creating or maintaining views, materialized or otherwise; but it's perfectly fine to [create an empty migration and add the view definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

## <a name="inheritance-mapping"></a><span data-ttu-id="75b46-135">繼承對應</span><span class="sxs-lookup"><span data-stu-id="75b46-135">Inheritance mapping</span></span>

<span data-ttu-id="75b46-136">建議您先閱讀 [繼承的專用頁面](xref:core/modeling/inheritance) ，再繼續進行本節。</span><span class="sxs-lookup"><span data-stu-id="75b46-136">It's recommended to read [the dedicated page on inheritance](xref:core/modeling/inheritance) before continuing with this section.</span></span>

<span data-ttu-id="75b46-137">EF Core 目前支援兩種將繼承模型對應至關係資料庫的技術：</span><span class="sxs-lookup"><span data-stu-id="75b46-137">EF Core currently supports two techniques for mapping an inheritance model to a relational database:</span></span>

* <span data-ttu-id="75b46-138">**每個** 階層的資料表 (TPH) ，其中整個類別的 .net 階層會對應到單一資料庫資料表</span><span class="sxs-lookup"><span data-stu-id="75b46-138">**Table-per-hierarchy** (TPH), in which an entire .NET hierarchy of classes is mapped to a single database table</span></span>
* <span data-ttu-id="75b46-139">**每一類型的資料表** (TPT) ，其中 .net 階層架構中的每個類型都會對應到資料庫中的不同資料表。</span><span class="sxs-lookup"><span data-stu-id="75b46-139">**Table-per-type** (TPT), in which each type in the .NET hierarchy is mapped to a different table in the database.</span></span>

<span data-ttu-id="75b46-140">繼承對應技術的選擇可能會對應用程式效能產生相當大的影響，建議您在認可至選擇之前仔細測量。</span><span class="sxs-lookup"><span data-stu-id="75b46-140">The choice of inheritance mapping technique can have a considerable impact on application performance - it's recommended to carefully measure before committing to a choice.</span></span>

<span data-ttu-id="75b46-141">人們有時會選擇 TPT，因為它看起來會是「清除程式」的技巧;每個 .NET 類型都會有個別的資料表，使資料庫架構看起來類似 .NET 類型階層。</span><span class="sxs-lookup"><span data-stu-id="75b46-141">People sometimes choose TPT because it appears to be the "cleaner" technique; a separate table for each .NET type makes the database schema look similar to the .NET type hierarchy.</span></span> <span data-ttu-id="75b46-142">此外，由於 TPH 必須在單一資料表中代表整個階層，因此資料列會有 *所有* 資料行，不論實際保留在資料列中的類型為何，不相關的資料行一律為空白且未使用。</span><span class="sxs-lookup"><span data-stu-id="75b46-142">In addition, since TPH must represent the entire hierarchy in a single table, rows have *all* columns regardless of the type actually being held in the row, and unrelated columns are always empty and unused.</span></span> <span data-ttu-id="75b46-143">除了如同是「unclean」的對應技巧之外，許多人認為這些空白資料行在資料庫中佔用的空間很大，而且也可能會影響效能。</span><span class="sxs-lookup"><span data-stu-id="75b46-143">Aside from seeming to be an "unclean" mapping technique, many believe that these empty columns take up considerable space in the database and may hurt performance as well.</span></span>

<span data-ttu-id="75b46-144">不過，測量會顯示 TPT 在大部分情況下都是效能觀點的最差對應技術;其中的所有資料都是來自單一資料表，而 TPT 查詢必須聯結多個資料表，而聯結則是關係資料庫中效能問題的其中一個主要來源。</span><span class="sxs-lookup"><span data-stu-id="75b46-144">However, measuring shows that TPT is in most cases the inferior mapping technique from a performance standpoint; where all data in TPH comes from a single table, TPT queries must join together multiple tables, and joins are one of the primary sources of performance issues in relational databases.</span></span> <span data-ttu-id="75b46-145">資料庫通常通常會與空白資料行妥善處理，而 [SQL Server sparse 資料行](/sql/relational-databases/tables/use-sparse-columns) 之類的功能也可以更進一步降低這種負擔。</span><span class="sxs-lookup"><span data-stu-id="75b46-145">Databases also generally tend to deal well with empty columns, and features such as [SQL Server sparse columns](/sql/relational-databases/tables/use-sparse-columns) can reduce this overhead even further.</span></span>

<span data-ttu-id="75b46-146">如需具體的範例， [請參閱此基準測試](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Benchmarks/Inheritance.cs) ，其會設定具有7類型階層的簡單模型;5000資料列會針對每個類型總計35000資料列植入，而基準測試只會從資料庫載入所有資料列：</span><span class="sxs-lookup"><span data-stu-id="75b46-146">For a concrete example, [see this benchmark](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Benchmarks/Inheritance.cs) which sets up a simple model with a 7-type hierarchy; 5000 rows are seeded for each type - totalling 35000 rows - and the benchmark simply loads all rows from the database:</span></span>

| <span data-ttu-id="75b46-147">方法</span><span class="sxs-lookup"><span data-stu-id="75b46-147">Method</span></span> |     <span data-ttu-id="75b46-148">平均數</span><span class="sxs-lookup"><span data-stu-id="75b46-148">Mean</span></span> |   <span data-ttu-id="75b46-149">錯誤</span><span class="sxs-lookup"><span data-stu-id="75b46-149">Error</span></span> |  <span data-ttu-id="75b46-150">StdDev</span><span class="sxs-lookup"><span data-stu-id="75b46-150">StdDev</span></span> |     <span data-ttu-id="75b46-151">Gen 0</span><span class="sxs-lookup"><span data-stu-id="75b46-151">Gen 0</span></span> |     <span data-ttu-id="75b46-152">Gen 1</span><span class="sxs-lookup"><span data-stu-id="75b46-152">Gen 1</span></span> |     <span data-ttu-id="75b46-153">Gen 2</span><span class="sxs-lookup"><span data-stu-id="75b46-153">Gen 2</span></span> | <span data-ttu-id="75b46-154">已配置</span><span class="sxs-lookup"><span data-stu-id="75b46-154">Allocated</span></span> |
|------- |---------:|--------:|--------:|----------:|----------:|----------:|----------:|
|    <span data-ttu-id="75b46-155">TPH</span><span class="sxs-lookup"><span data-stu-id="75b46-155">TPH</span></span> | <span data-ttu-id="75b46-156">132.3 毫秒</span><span class="sxs-lookup"><span data-stu-id="75b46-156">132.3 ms</span></span> | <span data-ttu-id="75b46-157">2.29 毫秒</span><span class="sxs-lookup"><span data-stu-id="75b46-157">2.29 ms</span></span> | <span data-ttu-id="75b46-158">2.03 毫秒</span><span class="sxs-lookup"><span data-stu-id="75b46-158">2.03 ms</span></span> | <span data-ttu-id="75b46-159">8000.0000</span><span class="sxs-lookup"><span data-stu-id="75b46-159">8000.0000</span></span> | <span data-ttu-id="75b46-160">3000.0000</span><span class="sxs-lookup"><span data-stu-id="75b46-160">3000.0000</span></span> | <span data-ttu-id="75b46-161">1250.0000</span><span class="sxs-lookup"><span data-stu-id="75b46-161">1250.0000</span></span> |  <span data-ttu-id="75b46-162">44.49 MB</span><span class="sxs-lookup"><span data-stu-id="75b46-162">44.49 MB</span></span> |
|    <span data-ttu-id="75b46-163">TPT</span><span class="sxs-lookup"><span data-stu-id="75b46-163">TPT</span></span> | <span data-ttu-id="75b46-164">201.3 毫秒</span><span class="sxs-lookup"><span data-stu-id="75b46-164">201.3 ms</span></span> | <span data-ttu-id="75b46-165">3.32 毫秒</span><span class="sxs-lookup"><span data-stu-id="75b46-165">3.32 ms</span></span> | <span data-ttu-id="75b46-166">3.10 毫秒</span><span class="sxs-lookup"><span data-stu-id="75b46-166">3.10 ms</span></span> | <span data-ttu-id="75b46-167">9000.0000</span><span class="sxs-lookup"><span data-stu-id="75b46-167">9000.0000</span></span> | <span data-ttu-id="75b46-168">4000.0000</span><span class="sxs-lookup"><span data-stu-id="75b46-168">4000.0000</span></span> |         - |  <span data-ttu-id="75b46-169">61.84 MB</span><span class="sxs-lookup"><span data-stu-id="75b46-169">61.84 MB</span></span> |

<span data-ttu-id="75b46-170">如您所見，在此案例中，TPH 的效率相當於 TPT。</span><span class="sxs-lookup"><span data-stu-id="75b46-170">As can be seen, TPH is considerably more efficient than TPT for this scenario.</span></span> <span data-ttu-id="75b46-171">請注意，實際的結果一律取決於正在執行的特定查詢和階層中的資料表數目，因此其他查詢可能會顯示不同的效能差距;建議您使用此基準測試程式碼作為測試其他查詢的範本。</span><span class="sxs-lookup"><span data-stu-id="75b46-171">Note that actual results always depend on the specific query being executed and the number of tables in the hierarchy, so other queries may show a different performance gap; you're encouraged to use this benchmark code as a template for testing other queries.</span></span>
