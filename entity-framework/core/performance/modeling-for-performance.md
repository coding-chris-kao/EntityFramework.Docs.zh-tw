---
title: 效能模型-EF Core
description: 在使用 Entity Framework Core 時有效率地建立模型
author: roji
ms.date: 12/1/2020
uid: core/performance/modeling-for-performance
ms.openlocfilehash: 882398189cc828798c1682f849fac524d90d317f
ms.sourcegitcommit: 4798ab8d04c1fdbe6dd204d94d770fcbf309d09b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/11/2021
ms.locfileid: "103023857"
---
# <a name="modeling-for-performance"></a>效能模型

在許多情況下，您模型的方式可能會對應用程式的效能造成深遠的影響;雖然正確正規化和「正確」模型通常是很好的起點，但在真實世界的應用程式中，有一些實際的折衷方法可達到良好的效能。 當應用程式在生產環境中執行時，因為很難變更您的模型，所以在建立初始模型時值得記住效能。

## <a name="denormalization-and-caching"></a>反正規化和快取

反 *正規化是在* 架構中加入多餘資料的作法，通常是為了在查詢時排除聯結。 例如，針對具有 Blog 和貼文的模型，其中每個貼文都有評等，您可能需要經常顯示該 Blog 的平均評等。 簡單的方法是將貼文依其 Blog 分組，並將平均值計算為查詢的一部分;但這需要兩個數據表之間的昂貴聯結。 反正規化會將所有貼文的計算平均值新增至 Blog 上的新資料行，讓它可以立即存取，而不需要加入或計算。

您可以將上述內容視為快 *取的形式* ，也就是在其 Blog 上快取貼文中的匯總資訊。就像使用任何快取一樣，問題在於如何讓快取的值與快取的資料保持在最新狀態。 在許多情況下，快取的資料會延遲一點;例如，在上述範例中，在任何指定的時間點，blog 的平均評等通常是合理的，而不是完全保持最新狀態。 如果是這種情況，您可以讓它每次重新計算一次，然後：否則，就必須設定更詳盡的系統，讓快取的值保持在最新狀態。

以下將詳細說明 EF Core 中的正規化和快取技術，並指向檔中的相關章節。

### <a name="stored-computed-columns"></a>儲存的計算資料行

如果要快取的資料是相同資料表中其他資料行的產品，則儲存的 [計算資料行](xref:core/modeling/generated-properties#computed-columns) 可以是理想的方案。 例如， `Customer` 可能有和資料 `FirstName` `LastName` 行，但我們可能需要依客戶的 *全名* 進行搜尋。 資料庫會自動維護儲存的計算資料行，這會在資料列變更時重新計算資料行，而且您甚至可以透過它定義索引，以加速查詢。

### <a name="update-cache-columns-when-inputs-change"></a>在輸入變更時更新快取資料行

如果您的快取資料行需要從資料表的資料列外部參考輸入，您就無法使用計算資料行。 不過，您仍然可以在每次輸入變更時重新計算資料行;例如，您可以在每次變更、新增或移除 Post 時，重新計算平均 Blog 的評等。 在需要重新計算時，請務必識別確切的條件，否則快取的值將不會同步。

執行這項作業的其中一種方式，是透過一般 EF Core API 自行執行更新。 `SaveChanges`[事件](xref:core/logging-events-diagnostics/events)或[攔截](xref:core/logging-events-diagnostics/interceptors#savechanges-interception)器可以用來自動檢查是否有任何文章正在更新，並以該方式執行重新計算。 請注意，這通常需要額外的資料庫往返，因為必須傳送額外的命令。

對於更有效能影響的應用程式，可以定義資料庫觸發程式，以在資料庫中自動執行重新計算。 這會儲存額外的資料庫往返、自動發生在與主要更新相同的交易中，而且可能更容易設定。 EF 未提供任何特定的 API 來建立或維護觸發程式，但您可以 [建立空白的遷移，並透過原始 SQL 新增觸發程序定義](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)。

### <a name="materialized-views"></a>具體化檢視

具體化視圖類似于一般視圖，不同之處在于其資料會儲存在磁片 ( 「具體化」 ) ，而不是每次查詢檢視時計算。 當您不想只要將單一快取資料行加入至現有的資料庫，但想要快取複雜且昂貴之查詢結果的整個 resultset 時（就像是一般資料表），這項工具就很有用。然後，您可以在不進行任何計算或聯結的情況下，低廉價格查詢這些結果。 不同于計算資料行，具體化視圖不會在其基礎資料表變更時自動更新-必須以手動方式重新整理。 如果快取的資料可能會延後，您可以透過計時器來重新整理視圖;另一個選項是設定資料庫觸發程式，以在發生特定資料庫事件時，檢查具體化的觀點。

EF 目前未提供任何特定的 API 來建立或維護視圖，具體化為; 否則為。但是， [建立空白的遷移並透過原始 SQL 加入 view 定義](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)是完全好的方式。

## <a name="inheritance-mapping"></a>繼承對應

建議您先閱讀 [繼承的專用頁面](xref:core/modeling/inheritance) ，再繼續進行本節。

EF Core 目前支援兩種將繼承模型對應至關係資料庫的技術：

* **每個** 階層的資料表 (TPH) ，其中整個類別的 .net 階層會對應到單一資料庫資料表
* **每一類型的資料表** (TPT) ，其中 .net 階層架構中的每個類型都會對應到資料庫中的不同資料表。

繼承對應技術的選擇可能會對應用程式效能產生相當大的影響，建議您在認可至選擇之前仔細測量。

人們有時會選擇 TPT，因為它看起來會是「清除程式」的技巧;每個 .NET 類型都會有個別的資料表，使資料庫架構看起來類似 .NET 類型階層。 此外，由於 TPH 必須在單一資料表中代表整個階層，因此資料列會有 *所有* 資料行，不論實際保留在資料列中的類型為何，不相關的資料行一律為空白且未使用。 除了如同是「unclean」的對應技巧之外，許多人認為這些空白資料行在資料庫中佔用的空間很大，而且也可能會影響效能。

不過，測量會顯示 TPT 在大部分情況下都是效能觀點的最差對應技術;其中的所有資料都是來自單一資料表，而 TPT 查詢必須聯結多個資料表，而聯結則是關係資料庫中效能問題的其中一個主要來源。 資料庫通常通常會與空白資料行妥善處理，而 [SQL Server sparse 資料行](/sql/relational-databases/tables/use-sparse-columns) 之類的功能也可以更進一步降低這種負擔。

如需具體的範例， [請參閱此基準測試](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Benchmarks/Inheritance.cs) ，其會設定具有7類型階層的簡單模型;5000資料列會針對每個類型總計35000資料列植入，而基準測試只會從資料庫載入所有資料列：

| 方法 |     平均數 |   錯誤 |  StdDev |     Gen 0 |     Gen 1 |     Gen 2 | 已配置 |
|------- |---------:|--------:|--------:|----------:|----------:|----------:|----------:|
|    TPH | 132.3 毫秒 | 2.29 毫秒 | 2.03 毫秒 | 8000.0000 | 3000.0000 | 1250.0000 |  44.49 MB |
|    TPT | 201.3 毫秒 | 3.32 毫秒 | 3.10 毫秒 | 9000.0000 | 4000.0000 |         - |  61.84 MB |

如您所見，在此案例中，TPH 的效率相當於 TPT。 請注意，實際的結果一律取決於正在執行的特定查詢和階層中的資料表數目，因此其他查詢可能會顯示不同的效能差距;建議您使用此基準測試程式碼作為測試其他查詢的範本。
