---
title: 有效率的查詢-EF Core
description: 使用 Entity Framework Core 進行有效率查詢的效能指南
author: roji
ms.date: 12/1/2020
uid: core/performance/efficient-querying
ms.openlocfilehash: e14837b779f2fbe8d5bf10206c6a336a952fc35b
ms.sourcegitcommit: 4798ab8d04c1fdbe6dd204d94d770fcbf309d09b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/11/2021
ms.locfileid: "103023870"
---
# <a name="efficient-querying"></a><span data-ttu-id="85ed3-103">有效率的查詢</span><span class="sxs-lookup"><span data-stu-id="85ed3-103">Efficient Querying</span></span>

<span data-ttu-id="85ed3-104">有效率地查詢是廣泛的主題，其中涵蓋了範圍廣泛的索引、相關的實體載入策略以及許多其他主題。</span><span class="sxs-lookup"><span data-stu-id="85ed3-104">Querying efficiently is a vast subject, that covers subjects as wide-ranging as indexes, related entity loading strategies, and many others.</span></span> <span data-ttu-id="85ed3-105">本節詳細說明一些常見的主題，讓您的查詢更快，而使用者通常會遇到陷阱。</span><span class="sxs-lookup"><span data-stu-id="85ed3-105">This section details some common themes for making your queries faster, and pitfalls users typically encounter.</span></span>

## <a name="use-indexes-properly"></a><span data-ttu-id="85ed3-106">適當地使用索引</span><span class="sxs-lookup"><span data-stu-id="85ed3-106">Use indexes properly</span></span>

<span data-ttu-id="85ed3-107">查詢快速執行的主要決定因素是，查詢是否會適當地使用適當的索引：資料庫通常用來保存大量資料，而跨越整個資料表的查詢通常是嚴重效能問題的來源。</span><span class="sxs-lookup"><span data-stu-id="85ed3-107">The main deciding factor in whether a query runs fast or not is whether it will properly utilize indexes where appropriate: databases are typically used to hold large amounts of data, and queries which traverse entire tables are typically sources of serious performance issues.</span></span> <span data-ttu-id="85ed3-108">索引問題並不容易發現，因為指定的查詢是否會使用索引，因此不會立即察覺。</span><span class="sxs-lookup"><span data-stu-id="85ed3-108">Indexing issues aren't easy to spot, because it isn't immediately obvious whether a given query will use an index or not.</span></span> <span data-ttu-id="85ed3-109">例如：</span><span class="sxs-lookup"><span data-stu-id="85ed3-109">For example:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Indexes)]

<span data-ttu-id="85ed3-110">找出索引問題的好方法是先找出緩慢的查詢，然後透過您資料庫的最愛工具檢查其查詢計劃。如需如何執行此作業的詳細資訊，請參閱 [ [效能診斷](xref:core/performance/performance-diagnosis) ] 頁面。</span><span class="sxs-lookup"><span data-stu-id="85ed3-110">A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via your database's favorite tool; see the [performance diagnosis](xref:core/performance/performance-diagnosis) page for more information on how to do that.</span></span> <span data-ttu-id="85ed3-111">查詢計劃會顯示查詢是否流經整個資料表，或使用索引。</span><span class="sxs-lookup"><span data-stu-id="85ed3-111">The query plan displays whether the query traverses the entire table, or uses an index.</span></span>

<span data-ttu-id="85ed3-112">一般來說，使用索引或診斷與其相關的效能問題並沒有任何特殊的 EF 知識;與索引相關的一般資料庫知識，與 EF 應用程式相關，與不使用 EF 的應用程式一樣。</span><span class="sxs-lookup"><span data-stu-id="85ed3-112">As a general rule, there isn't any special EF knowledge to using indexes or diagnosing performance issues related to them; general database knowledge related to indexes is just as relevant to EF applications as to applications not using EF.</span></span> <span data-ttu-id="85ed3-113">以下列出使用索引時要牢記在心的一些一般指導方針：</span><span class="sxs-lookup"><span data-stu-id="85ed3-113">The following lists some general guidelines to keep in mind when using indexes:</span></span>

* <span data-ttu-id="85ed3-114">當索引加速查詢時，它們也會使更新變慢，因為它們必須保持在最新狀態。</span><span class="sxs-lookup"><span data-stu-id="85ed3-114">While indexes speed up queries, they also slow down updates since they need to be kept up-to-date.</span></span> <span data-ttu-id="85ed3-115">避免定義不需要的索引，並考慮使用 [索引篩選準則](xref:core/modeling/indexes#index-filter) 將索引限制為數據列的子集，藉此減少此額外負荷。</span><span class="sxs-lookup"><span data-stu-id="85ed3-115">Avoid defining indexes which aren't needed, and consider using [index filters](xref:core/modeling/indexes#index-filter) to limit the index to a subset of the rows, thereby reducing this overhead.</span></span>
* <span data-ttu-id="85ed3-116">複合索引可以加速篩選多個資料行的查詢，但也可以加速查詢，而這些查詢不會篩選所有索引資料行，視順序而定。</span><span class="sxs-lookup"><span data-stu-id="85ed3-116">Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don't filter on all the index's columns - depending on ordering.</span></span> <span data-ttu-id="85ed3-117">例如，資料行 A 和 B 上的索引會加速 A 和 B 的查詢篩選，以及只查詢篩選的查詢，但不會加速僅限 B 的查詢篩選。</span><span class="sxs-lookup"><span data-stu-id="85ed3-117">For example, an index on columns A and B speed up queries filtering by A and B, as well as queries filtering only by A, but it does not speed up queries filtering over only by B.</span></span>
* <span data-ttu-id="85ed3-118">如果查詢依據運算式篩選資料行 (例如 `price / 2`) ，就不能使用簡單的索引。</span><span class="sxs-lookup"><span data-stu-id="85ed3-118">If a query filters by an expression over a column (e.g. `price / 2`), a simple index cannot be used.</span></span> <span data-ttu-id="85ed3-119">不過，您可以為您的運算式定義已 [儲存的保存資料行](xref:core/modeling/generated-properties#computed-columns) ，並在該資料行上建立索引。</span><span class="sxs-lookup"><span data-stu-id="85ed3-119">However, you can define a [stored persisted column](xref:core/modeling/generated-properties#computed-columns) for your expression, and create an index over that.</span></span> <span data-ttu-id="85ed3-120">某些資料庫也支援運算式索引，可以直接用來加速任何運算式的查詢篩選。</span><span class="sxs-lookup"><span data-stu-id="85ed3-120">Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression.</span></span>
* <span data-ttu-id="85ed3-121">不同的資料庫可讓您以各種方式設定索引，而且在許多情況下，EF Core 提供者會透過流暢的 API 公開這些索引。</span><span class="sxs-lookup"><span data-stu-id="85ed3-121">Different databases allow indexes to be configured in various ways, and in many cases EF Core providers expose these via the Fluent API.</span></span> <span data-ttu-id="85ed3-122">例如，SQL Server 提供者可讓您設定 [索引是否已叢集化，或](xref:core/providers/sql-server/indexes#clustering)設定其 [填滿因數](xref:core/providers/sql-server/indexes#fill-factor)。</span><span class="sxs-lookup"><span data-stu-id="85ed3-122">For example, the SQL Server provider allows you to configure whether an index is [clustered](xref:core/providers/sql-server/indexes#clustering), or set its [fill factor](xref:core/providers/sql-server/indexes#fill-factor).</span></span> <span data-ttu-id="85ed3-123">如需詳細資訊，請參閱您的提供者檔。</span><span class="sxs-lookup"><span data-stu-id="85ed3-123">Consult your provider's documentation for more information.</span></span>

## <a name="project-only-properties-you-need"></a><span data-ttu-id="85ed3-124">只投影您需要的屬性</span><span class="sxs-lookup"><span data-stu-id="85ed3-124">Project only properties you need</span></span>

<span data-ttu-id="85ed3-125">EF Core 可讓您輕鬆地查詢實體實例，然後在程式碼中使用這些實例。</span><span class="sxs-lookup"><span data-stu-id="85ed3-125">EF Core makes it very easy to query out entity instances, and then use those instances in code.</span></span> <span data-ttu-id="85ed3-126">不過，查詢實體實例可能會經常從資料庫中取回更多資料。</span><span class="sxs-lookup"><span data-stu-id="85ed3-126">However, querying entity instances can frequently pull back more data than necessary from your database.</span></span> <span data-ttu-id="85ed3-127">請考慮下列事項：</span><span class="sxs-lookup"><span data-stu-id="85ed3-127">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectEntities)]

<span data-ttu-id="85ed3-128">雖然這段程式碼只需要每個 Blog 的 `Url` 屬性，但是整個 blog 實體都會被提取，而不需要的資料行則會從資料庫傳送：</span><span class="sxs-lookup"><span data-stu-id="85ed3-128">Although this code only actually needs each Blog's `Url` property, the entire Blog entity is fetched, and unneeded columns are transferred from the database:</span></span>

```sql
SELECT [b].[BlogId], [b].[CreationDate], [b].[Name], [b].[Rating], [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="85ed3-129">您可以使用來將其優化， `Select` 以告訴 EF 要投影哪些資料行：</span><span class="sxs-lookup"><span data-stu-id="85ed3-129">This can be optimized by using `Select` to tell EF which columns to project out:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectSingleProperty)]

<span data-ttu-id="85ed3-130">產生的 SQL 只會取回所需的資料行：</span><span class="sxs-lookup"><span data-stu-id="85ed3-130">The resulting SQL pulls back only the needed columns:</span></span>

```csharp
SELECT [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="85ed3-131">如果您需要投影出多個資料行，請使用您想要的屬性來投影至 c # 匿名型別。</span><span class="sxs-lookup"><span data-stu-id="85ed3-131">If you need to project out more than one column, project out to a C# anonymous type with the properties you want.</span></span>

<span data-ttu-id="85ed3-132">請注意，這項技術對於唯讀查詢非常有用，但如果您需要 *更新* 提取的 blog，則會變得更複雜，因為 EF 的變更追蹤只適用于實體實例。</span><span class="sxs-lookup"><span data-stu-id="85ed3-132">Note that this technique is very useful for read-only queries, but things get more complicated if you need to *update* the fetched blogs, since EF's change tracking only works with entity instances.</span></span> <span data-ttu-id="85ed3-133">您可以藉由附加修改過的 Blog 實例，並告訴 EF 哪些屬性已變更，但這是更先進的技術，但可能不值得您執行更新，而不需要載入整個實體。</span><span class="sxs-lookup"><span data-stu-id="85ed3-133">It's possible to perform updates without loading entire entities by attaching a modified Blog instance and telling EF which properties have changed, but that is a more advanced technique that may not be worth it.</span></span>

## <a name="limit-the-resultset-size"></a><span data-ttu-id="85ed3-134">限制結果集大小</span><span class="sxs-lookup"><span data-stu-id="85ed3-134">Limit the resultset size</span></span>

<span data-ttu-id="85ed3-135">根據預設，查詢會傳回符合其篩選準則的所有資料列：</span><span class="sxs-lookup"><span data-stu-id="85ed3-135">By default, a query returns all rows that matches its filters:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NoLimit)]

<span data-ttu-id="85ed3-136">由於傳回的資料列數目取決於您資料庫中的實際資料，因此不可能知道要從資料庫載入多少資料、結果會佔用多少記憶體，以及處理這些結果時所產生的額外負載 (例如，透過網路) 將它們傳送至使用者瀏覽器。</span><span class="sxs-lookup"><span data-stu-id="85ed3-136">Since the number of rows returned depends on actual data in your database, it's impossible to know how much data will be loaded from the database, how much memory will be taken up by the results, and how much additional load will be generated when processing these results (e.g. by sending them to a user browser over the network).</span></span> <span data-ttu-id="85ed3-137">十分，測試資料庫通常包含少量的資料，因此所有專案在測試時都能正常運作，但當查詢開始在真實世界的資料上執行，而且傳回許多資料列時，效能問題突然出現。</span><span class="sxs-lookup"><span data-stu-id="85ed3-137">Crucially, test databases frequently contain little data, so that everything works well while testing, but performance problems suddenly appear when the query starts running on real-world data and many rows are returned.</span></span>

<span data-ttu-id="85ed3-138">因此，通常值得考慮限制結果的數目：</span><span class="sxs-lookup"><span data-stu-id="85ed3-138">As a result, it's usually worth giving thought to limiting the number of results:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Limit25)]

<span data-ttu-id="85ed3-139">您的 UI 至少會顯示一則訊息，指出資料庫 (中可能存在更多資料列，並允許) 以其他方式進行抓取。</span><span class="sxs-lookup"><span data-stu-id="85ed3-139">At a minimum, your UI could show a message indicating that more rows may exist in the database (and allow retrieving them in some other manner).</span></span> <span data-ttu-id="85ed3-140">全方位的解決方案會執行 *分頁*，其中您的 UI 一次只會顯示特定數目的資料列，並允許使用者視需要前進到下一個頁面;這通常會結合 <xref:System.Linq.Enumerable.Take%2A> 和 <xref:System.Linq.Enumerable.Skip%2A> 運算子，以在每次都選取 resultset 中的特定範圍。</span><span class="sxs-lookup"><span data-stu-id="85ed3-140">A full-blown solution would implement *paging*, where your UI only shows a certain number of rows at a time, and allow users to advance to the next page as needed; this typically combines the <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> operators to select a specific range in the resultset each time.</span></span>

## <a name="avoid-cartesian-explosion-when-loading-related-entities"></a><span data-ttu-id="85ed3-141">在載入相關實體時避免笛卡兒爆炸</span><span class="sxs-lookup"><span data-stu-id="85ed3-141">Avoid cartesian explosion when loading related entities</span></span>

<span data-ttu-id="85ed3-142">在關係資料庫中，所有相關的實體都會透過在單一查詢中導入聯結的方式載入。</span><span class="sxs-lookup"><span data-stu-id="85ed3-142">In relational databases, all related entities are loaded by introducing JOINs in single query.</span></span>

```sql
SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title]
FROM [Blogs] AS [b]
LEFT JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId]
```

<span data-ttu-id="85ed3-143">如果一般的 blog 有多個相關的文章，這些貼文的資料列將會複製 blog 的資訊。</span><span class="sxs-lookup"><span data-stu-id="85ed3-143">If a typical blog has multiple related posts, rows for these posts will duplicate the blog's information.</span></span> <span data-ttu-id="85ed3-144">這項重複會導致所謂的「笛卡兒爆炸」問題。</span><span class="sxs-lookup"><span data-stu-id="85ed3-144">This duplication leads to the so-called "cartesian explosion" problem.</span></span> <span data-ttu-id="85ed3-145">載入更多一對多關聯性時，重複的資料量可能會成長，而且會對應用程式的效能造成不良影響。</span><span class="sxs-lookup"><span data-stu-id="85ed3-145">As more one-to-many relationships are loaded, the amount of duplicated data may grow and adversely affect the performance of your application.</span></span>

<span data-ttu-id="85ed3-146">EF 可透過使用「分割查詢」來避免此效果，這會透過個別查詢來載入相關實體。</span><span class="sxs-lookup"><span data-stu-id="85ed3-146">EF allows avoiding this effect via the use of "split queries", which load the related entities via separate queries.</span></span> <span data-ttu-id="85ed3-147">如需詳細資訊，請閱讀 [分割和單一查詢的相關檔](xref:core/querying/single-split-queries)。</span><span class="sxs-lookup"><span data-stu-id="85ed3-147">For more information, read [the documentation on split and single queries](xref:core/querying/single-split-queries).</span></span>

> [!NOTE]
> <span data-ttu-id="85ed3-148">目前的 [分割查詢](xref:core/querying/single-split-queries) 執行會執行每個查詢的往返。</span><span class="sxs-lookup"><span data-stu-id="85ed3-148">The current implementation of [split queries](xref:core/querying/single-split-queries) executes a roundtrip for each query.</span></span> <span data-ttu-id="85ed3-149">我們打算在未來改進這項功能，並在單一往返中執行所有查詢。</span><span class="sxs-lookup"><span data-stu-id="85ed3-149">We plan to improve this in the future, and execute all queries in a single roundtrip.</span></span>

## <a name="load-related-entities-eagerly-when-possible"></a><span data-ttu-id="85ed3-150">盡可能立即載入相關實體</span><span class="sxs-lookup"><span data-stu-id="85ed3-150">Load related entities eagerly when possible</span></span>

<span data-ttu-id="85ed3-151">建議您先閱讀 [相關實體的專用頁面](xref:core/querying/related-data) ，再繼續進行本節。</span><span class="sxs-lookup"><span data-stu-id="85ed3-151">It's recommended to read [the dedicated page on related entities](xref:core/querying/related-data) before continuing with this section.</span></span>

<span data-ttu-id="85ed3-152">處理相關的實體時，我們通常會事先知道需要載入的專案：一般範例會載入一組特定的 Blog，以及所有的貼文。</span><span class="sxs-lookup"><span data-stu-id="85ed3-152">When dealing with related entities, we usually know in advance what we need to load: a typical example would be loading a certain set of Blogs, along with all their Posts.</span></span> <span data-ttu-id="85ed3-153">在這些情況下，最好是使用積極式 [載入](xref:core/querying/related-data/eager)，讓 EF 可以在一個往返中提取所有必要的資料。</span><span class="sxs-lookup"><span data-stu-id="85ed3-153">In these scenarios, it is always better to use [eager loading](xref:core/querying/related-data/eager), so that EF can fetch all the required data in one roundtrip.</span></span> <span data-ttu-id="85ed3-154">EF Core 5.0 中引進的 [篩選包含](xref:core/querying/related-data/eager#filtered-include) 功能，也可讓您限制要載入的相關實體，同時讓載入程式保持積極，因此在單一往返中雖可行：</span><span class="sxs-lookup"><span data-stu-id="85ed3-154">The [filtered include](xref:core/querying/related-data/eager#filtered-include) feature, introduced in EF Core 5.0, also allows you to limit which related entities you'd like to load, while keeping the loading process eager and therefore doable in a single roundtrip:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/Program.cs#FilteredInclude)]

<span data-ttu-id="85ed3-155">在其他情況下，我們可能不知道我們在取得其主體實體之前需要哪些相關實體。</span><span class="sxs-lookup"><span data-stu-id="85ed3-155">In other scenarios, we may not know which related entity we're going to need before we get its principal entity.</span></span> <span data-ttu-id="85ed3-156">例如，在載入某些 Blog 時，我們可能需要查閱一些其他資料來源（可能是 webservice），以瞭解我們是否對該 Blog 的文章感興趣。</span><span class="sxs-lookup"><span data-stu-id="85ed3-156">For example, when loading some Blog, we may need to consult some other data source - possibly a webservice - in order to know whether we're interested in that Blog's Posts.</span></span> <span data-ttu-id="85ed3-157">在這些情況下，您可以使用[明確](xref:core/querying/related-data/explicit)[或消極](xref:core/querying/related-data/lazy)式載入來個別提取相關的實體，並填入 Blog 的貼文導覽。</span><span class="sxs-lookup"><span data-stu-id="85ed3-157">In these cases, [explicit](xref:core/querying/related-data/explicit) or [lazy](xref:core/querying/related-data/lazy) loading can be used to fetch related entities separately, and populate the Blog's Posts navigation.</span></span> <span data-ttu-id="85ed3-158">請注意，由於這些方法並不積極，因此需要對資料庫進行額外的往返，也就是緩慢的來源;根據您的特定案例，只要一律載入所有貼文，而不是執行額外的往返，並選擇性地只取得您需要的貼文，可能會更有效率。</span><span class="sxs-lookup"><span data-stu-id="85ed3-158">Note that since these methods aren't eager, they require additional roundtrips to the database, which is source of slowdown; depending on your specific scenario, it may be more efficient to just always load all Posts, rather than to execute the additional roundtrips and selectively get only the Posts you need.</span></span>

### <a name="beware-of-lazy-loading"></a><span data-ttu-id="85ed3-159">注意消極式載入</span><span class="sxs-lookup"><span data-stu-id="85ed3-159">Beware of lazy loading</span></span>

<span data-ttu-id="85ed3-160">消極式[載入](xref:core/querying/related-data/lazy)通常看起來像是一個非常有用的方式來撰寫資料庫邏輯，因為 EF Core 會在程式碼存取資料庫時，從資料庫自動載入相關實體。</span><span class="sxs-lookup"><span data-stu-id="85ed3-160">[Lazy loading](xref:core/querying/related-data/lazy) often seems like a very useful way to write database logic, since EF Core automatically loads related entities from the database as they are accessed by your code.</span></span> <span data-ttu-id="85ed3-161">這可避免載入不需要的相關實體 (例如 [明確載入](xref:core/querying/related-data/explicit)) ，而且看似讓程式設計人員不必全部處理相關的實體。</span><span class="sxs-lookup"><span data-stu-id="85ed3-161">This avoids loading related entities that aren't needed (like [explicit loading](xref:core/querying/related-data/explicit)), and seemingly frees the programmer from having to deal with related entities altogether.</span></span> <span data-ttu-id="85ed3-162">不過，消極式載入特別容易產生不必要的額外往返，而導致應用程式變慢。</span><span class="sxs-lookup"><span data-stu-id="85ed3-162">However, lazy loading is particularly prone for producing unneeded extra roundtrips which can slow the application.</span></span>

<span data-ttu-id="85ed3-163">請考慮下列事項：</span><span class="sxs-lookup"><span data-stu-id="85ed3-163">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NPlusOne)]

<span data-ttu-id="85ed3-164">這種看似無害的程式碼會逐一查看所有的 blog 和其貼文，並將其列印出來。開啟 EF Core 的 [語句記錄](xref:core/logging-events-diagnostics/index) 會顯示下列各項：</span><span class="sxs-lookup"><span data-stu-id="85ed3-164">This seemingly innocent piece of code iterates through all the blogs and their posts, printing them out. Turning on EF Core's [statement logging](xref:core/logging-events-diagnostics/index) reveals the following:</span></span>

```console
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[BlogId], [b].[Rating], [b].[Url]
      FROM [Blogs] AS [b]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[@__p_0='1'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='2'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='3'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0

... and so on
```

<span data-ttu-id="85ed3-165">這其中發生了什麼狀況？</span><span class="sxs-lookup"><span data-stu-id="85ed3-165">What's going on here?</span></span> <span data-ttu-id="85ed3-166">為什麼會針對上述的簡單迴圈傳送這些查詢？</span><span class="sxs-lookup"><span data-stu-id="85ed3-166">Why are all these queries being sent for the simple loops above?</span></span> <span data-ttu-id="85ed3-167">使用消極式載入時，只有在存取文章屬性時，才會將 Blog 的貼文 (延遲) 載入;如此一來，內部 foreach 中的每個反復專案都會在其本身的往返中觸發額外的資料庫查詢。</span><span class="sxs-lookup"><span data-stu-id="85ed3-167">With lazy loading, a Blog's Posts are only (lazily) loaded when its Posts property is accessed; as a result, each iteration in the inner foreach triggers an additional database query, in its own roundtrip.</span></span> <span data-ttu-id="85ed3-168">如此一來，在初始查詢載入所有的 blog 之後，我們就會在 *每個 blog* 中有另一個查詢，並載入其所有文章;這有時稱為 *N + 1* 問題，而這可能會造成極大的效能問題。</span><span class="sxs-lookup"><span data-stu-id="85ed3-168">As a result, after the initial query loading all the blogs, we then have another query *per blog*, loading all its posts; this is sometimes called the *N+1* problem, and it can cause very significant performance issues.</span></span>

<span data-ttu-id="85ed3-169">假設我們將需要所有的 blog 貼文，請改為在這裡使用積極式載入。</span><span class="sxs-lookup"><span data-stu-id="85ed3-169">Assuming we're going to need all of the blogs' posts, it makes sense to use eager loading here instead.</span></span> <span data-ttu-id="85ed3-170">我們可以使用 [Include](xref:core/querying/related-data/eager#eager-loading) 運算子來執行載入，但因為我們只需要 (Blog 的 url，因此應該只 [載入) 所需的內容](xref:core/performance/efficient-querying#project-only-properties-you-need) 。</span><span class="sxs-lookup"><span data-stu-id="85ed3-170">We can use the [Include](xref:core/querying/related-data/eager#eager-loading) operator to perform the loading, but since we only need the Blogs' URLs (and we should only [load what's needed](xref:core/performance/efficient-querying#project-only-properties-you-need)).</span></span> <span data-ttu-id="85ed3-171">因此，我們會改為使用投影：</span><span class="sxs-lookup"><span data-stu-id="85ed3-171">So we'll use a projection instead:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#EagerlyLoadRelatedAndProject)]

<span data-ttu-id="85ed3-172">這會讓 EF Core 在單一查詢中提取所有的 Blog 以及它們的貼文。</span><span class="sxs-lookup"><span data-stu-id="85ed3-172">This will make EF Core fetch all the Blogs - along with their Posts - in a single query.</span></span> <span data-ttu-id="85ed3-173">在某些情況下，使用 [分割查詢](xref:core/querying/single-split-queries)來避免笛卡兒爆炸效果也可能很有用。</span><span class="sxs-lookup"><span data-stu-id="85ed3-173">In some cases, it may also be useful to avoid cartesian explosion effects by using [split queries](xref:core/querying/single-split-queries).</span></span>

> [!WARNING]
> <span data-ttu-id="85ed3-174">由於消極式載入讓您很容易不小心觸發 N + 1 問題，因此建議您避免使用它。</span><span class="sxs-lookup"><span data-stu-id="85ed3-174">Because lazy loading makes it extremely easy to inadvertently trigger the N+1 problem, it is recommended to avoid it.</span></span> <span data-ttu-id="85ed3-175">積極或明確的載入，可讓您在發生資料庫往返時，在原始程式碼中非常清楚。</span><span class="sxs-lookup"><span data-stu-id="85ed3-175">Eager or explicit loading make it very clear in the source code when a database roundtrip occurs.</span></span>

## <a name="buffering-and-streaming"></a><span data-ttu-id="85ed3-176">緩衝處理和串流</span><span class="sxs-lookup"><span data-stu-id="85ed3-176">Buffering and streaming</span></span>

<span data-ttu-id="85ed3-177">緩衝處理是指將您所有的查詢結果載入到記憶體中，而串流表示 EF 會每次都將應用程式放入單一結果，而不會在記憶體中包含整個結果集。</span><span class="sxs-lookup"><span data-stu-id="85ed3-177">Buffering refers to loading all your query results into memory, whereas streaming means that EF hands the application a single result each time, never containing the entire resultset in memory.</span></span> <span data-ttu-id="85ed3-178">原則而言，串流查詢的記憶體需求是固定的，不論查詢傳回1個數據列或 1000;另一方面，緩衝查詢需要更多的記憶體，傳回的資料列越多。</span><span class="sxs-lookup"><span data-stu-id="85ed3-178">In principle, the memory requirements of a streaming query are fixed - they are the same whether the query returns 1 row or 1000; a buffering query, on the other hand, requires more memory the more rows are returned.</span></span> <span data-ttu-id="85ed3-179">對於產生大型結果集的查詢而言，這可能是重要的效能因素。</span><span class="sxs-lookup"><span data-stu-id="85ed3-179">For queries that result large resultsets, this can be an important performance factor.</span></span>

<span data-ttu-id="85ed3-180">查詢緩衝區或資料流程是否取決於其評估方式：</span><span class="sxs-lookup"><span data-stu-id="85ed3-180">Whether a query buffers or streams depends on how it is evaluated:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#BufferingAndStreaming)]

<span data-ttu-id="85ed3-181">如果您的查詢只傳回一些結果，您可能不需要擔心這一點。</span><span class="sxs-lookup"><span data-stu-id="85ed3-181">If your queries return just a few results, then you probably don't have to worry about this.</span></span> <span data-ttu-id="85ed3-182">但是，如果您的查詢可能會傳回大量的資料列，則值得考慮串流處理而非緩衝處理。</span><span class="sxs-lookup"><span data-stu-id="85ed3-182">However, if your query might return large numbers of rows, it's worth giving thought to streaming instead of buffering.</span></span>

> [!NOTE]
> <span data-ttu-id="85ed3-183"><xref:System.Linq.Enumerable.ToList%2A> <xref:System.Linq.Enumerable.ToArray%2A> 如果您想要在結果上使用另一個 LINQ 運算子，請避免使用或，這將會不必要地將所有結果緩衝到記憶體中。</span><span class="sxs-lookup"><span data-stu-id="85ed3-183">Avoid using <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> if you intend to use another LINQ operator on the result - this will needlessly buffer all results into memory.</span></span> <span data-ttu-id="85ed3-184">請改用 <xref:System.Linq.Enumerable.AsEnumerable%2A>。</span><span class="sxs-lookup"><span data-stu-id="85ed3-184">Use <xref:System.Linq.Enumerable.AsEnumerable%2A> instead.</span></span>

### <a name="internal-buffering-by-ef"></a><span data-ttu-id="85ed3-185">EF 的內部緩衝</span><span class="sxs-lookup"><span data-stu-id="85ed3-185">Internal buffering by EF</span></span>

<span data-ttu-id="85ed3-186">在某些情況下，無論您如何評估查詢，EF 本身會在內部緩衝結果集。</span><span class="sxs-lookup"><span data-stu-id="85ed3-186">In certain situations, EF will itself buffer the resultset internally, regardless of how you evaluate your query.</span></span> <span data-ttu-id="85ed3-187">發生這種情況的兩個案例如下：</span><span class="sxs-lookup"><span data-stu-id="85ed3-187">The two cases where this happens are:</span></span>

* <span data-ttu-id="85ed3-188">當重試執行策略就緒時。</span><span class="sxs-lookup"><span data-stu-id="85ed3-188">When a retrying execution strategy is in place.</span></span> <span data-ttu-id="85ed3-189">這樣做的目的是為了確保在稍後重試查詢時傳回相同的結果。</span><span class="sxs-lookup"><span data-stu-id="85ed3-189">This is done to make sure the same results are returned if the query is retried later.</span></span>
* <span data-ttu-id="85ed3-190">使用 [split 查詢](xref:core/querying/single-split-queries) 時，會緩衝處理除了最後一個查詢以外的所有結果集，除非 SQL Server 上已啟用 MARS。</span><span class="sxs-lookup"><span data-stu-id="85ed3-190">When [split query](xref:core/querying/single-split-queries) is used, the resultsets of all but the last query are buffered - unless MARS is enabled on SQL Server.</span></span> <span data-ttu-id="85ed3-191">這是因為通常無法同時啟用多個查詢結果集。</span><span class="sxs-lookup"><span data-stu-id="85ed3-191">This is because it is usually impossible to have multiple query resultsets active at the same time.</span></span>

<span data-ttu-id="85ed3-192">請注意，除了您透過 LINQ 運算子所造成的任何緩衝之外，也會發生此內部緩衝。</span><span class="sxs-lookup"><span data-stu-id="85ed3-192">Note that this internal buffering occurs in addition to any buffering you cause via LINQ operators.</span></span> <span data-ttu-id="85ed3-193">例如，如果您在 <xref:System.Linq.Enumerable.ToList%2A> 查詢上使用，且正在重試執行策略，則會將結果集載入記憶體 *兩次*：一次由 EF 在內部，而一次是 <xref:System.Linq.Enumerable.ToList%2A> 。</span><span class="sxs-lookup"><span data-stu-id="85ed3-193">For example, if you use <xref:System.Linq.Enumerable.ToList%2A> on a query and a retrying execution strategy is in place, the resultset is loaded into memory *twice*: once internally by EF, and once by <xref:System.Linq.Enumerable.ToList%2A>.</span></span>

## <a name="tracking-no-tracking-and-identity-resolution"></a><span data-ttu-id="85ed3-194">追蹤、無追蹤和識別解析</span><span class="sxs-lookup"><span data-stu-id="85ed3-194">Tracking, no-tracking and identity resolution</span></span>

<span data-ttu-id="85ed3-195">建議您先閱讀 [追蹤和不追蹤的專用頁面，](xref:core/querying/tracking) 再繼續進行本節。</span><span class="sxs-lookup"><span data-stu-id="85ed3-195">It's recommended to read [the dedicated page on tracking and no-tracking](xref:core/querying/tracking) before continuing with this section.</span></span>

<span data-ttu-id="85ed3-196">EF 預設會追蹤實體實例，以便在呼叫時，偵測並保存它們的變更 <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> 。</span><span class="sxs-lookup"><span data-stu-id="85ed3-196">EF tracks entity instances by default, so that changes on them are detected and persisted when <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called.</span></span> <span data-ttu-id="85ed3-197">追蹤查詢的另一個影響是 EF 會偵測是否已載入資料的實例，並自動傳回追蹤的實例，而不是傳回新的實例;這稱為 *識別解析*。</span><span class="sxs-lookup"><span data-stu-id="85ed3-197">Another effect of tracking queries is that EF detects if an instance has already been loaded for your data, and will automatically return that tracked instance rather than returning a new one; this is called *identity resolution*.</span></span> <span data-ttu-id="85ed3-198">從效能的觀點來看，變更追蹤表示下列各項：</span><span class="sxs-lookup"><span data-stu-id="85ed3-198">From a performance perspective, change tracking means the following:</span></span>

* <span data-ttu-id="85ed3-199">EF 內部會維護追蹤實例的字典。</span><span class="sxs-lookup"><span data-stu-id="85ed3-199">EF internally maintains a dictionary of tracked instances.</span></span> <span data-ttu-id="85ed3-200">載入新的資料時，EF 會檢查字典以查看是否已針對該實體的索引鍵追蹤實例， (識別解析) 。</span><span class="sxs-lookup"><span data-stu-id="85ed3-200">When new data is loaded, EF checks the dictionary to see if an instance is already tracked for that entity's key (identity resolution).</span></span> <span data-ttu-id="85ed3-201">載入查詢的結果時，字典維護和查閱需要一些時間。</span><span class="sxs-lookup"><span data-stu-id="85ed3-201">The dictionary maintenance and lookups take up some time when loading the query's results.</span></span>
* <span data-ttu-id="85ed3-202">在將載入的實例處理至應用程式之前，EF 會 *快照* 該實例，並在內部保留快照集。</span><span class="sxs-lookup"><span data-stu-id="85ed3-202">Before handing a loaded instance to the application, EF *snapshots* that instance and keeps the snapshot internally.</span></span> <span data-ttu-id="85ed3-203">當 <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> 呼叫時，應用程式的實例會與快照集進行比較，以探索要保存的變更。</span><span class="sxs-lookup"><span data-stu-id="85ed3-203">When <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called, the application's instance is compared with the snapshot to discover the changes to be persisted.</span></span> <span data-ttu-id="85ed3-204">快照集會佔用更多的記憶體，而且快照集進程本身需要時間。有時可能會透過 [值](xref:core/modeling/value-comparers)比較子來指定不同且可能更有效率的快照集行為，或使用變更追蹤 proxy 來完全略過快照集進程 (但這是) 的一組缺點。</span><span class="sxs-lookup"><span data-stu-id="85ed3-204">The snapshot takes up more memory, and the snapshotting process itself takes time; it's sometimes possible to specify different, possibly more efficient snapshotting behavior via [value comparers](xref:core/modeling/value-comparers), or to use change-tracking proxies to bypass the snapshotting process altogether (though that comes with its own set of disadvantages).</span></span>

<span data-ttu-id="85ed3-205">在未將變更存回資料庫的唯讀案例中，您可以使用 [無追蹤查詢](xref:core/querying/tracking#no-tracking-queries)來避免上述的負荷。</span><span class="sxs-lookup"><span data-stu-id="85ed3-205">In read-only scenarios where changes aren't saved back to the database, the above overheads can be avoided by using [no-tracking queries](xref:core/querying/tracking#no-tracking-queries).</span></span> <span data-ttu-id="85ed3-206">不過，由於沒有追蹤查詢不會執行識別解析，因此多個其他載入的資料列所參考的資料庫資料列將會具體化為不同的實例。</span><span class="sxs-lookup"><span data-stu-id="85ed3-206">However, since no-tracking queries do not perform identity resolution, a database row which is referenced by multiple other loaded rows will be materialized as different instances.</span></span>

<span data-ttu-id="85ed3-207">為了說明這一點，假設我們從資料庫載入大量的貼文，以及每一篇文章所參考的 Blog。</span><span class="sxs-lookup"><span data-stu-id="85ed3-207">To illustrate, assume we are loading a large number of Posts from the database, as well as the Blog referenced by each Post.</span></span> <span data-ttu-id="85ed3-208">如果出現100文章參考相同的 Blog，追蹤查詢會透過識別解析來偵測到此情況，而且所有 Post 實例都會參考相同的重複複製的 Blog 實例。</span><span class="sxs-lookup"><span data-stu-id="85ed3-208">If 100 Posts happen to reference the same Blog, a tracking query detects this via identity resolution, and all Post instances will refer the same de-duplicated Blog instance.</span></span> <span data-ttu-id="85ed3-209">相反地，無追蹤查詢會重複相同的 Blog 100 次，而且應用程式程式碼必須據以撰寫。</span><span class="sxs-lookup"><span data-stu-id="85ed3-209">A no-tracking query, in contrast, duplicates the same Blog 100 times - and application code must be written accordingly.</span></span>

<span data-ttu-id="85ed3-210">以下是比較追蹤的結果，以及每個包含20篇文章的查詢載入10個 Blog 的追蹤行為。</span><span class="sxs-lookup"><span data-stu-id="85ed3-210">Here are the results for a benchmark comparing tracking vs. no-tracking behavior for a query loading 10 Blogs with 20 Posts each.</span></span> <span data-ttu-id="85ed3-211">您[可以從這裡取得原始程式碼](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Benchmarks/QueryTrackingBehavior.cs)，並將其作為您自己的度量基礎。</span><span class="sxs-lookup"><span data-stu-id="85ed3-211">[The source code is available here](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Benchmarks/QueryTrackingBehavior.cs), feel free to use it as a basis for your own measurements.</span></span>

|       <span data-ttu-id="85ed3-212">方法</span><span class="sxs-lookup"><span data-stu-id="85ed3-212">Method</span></span> | <span data-ttu-id="85ed3-213">NumBlogs</span><span class="sxs-lookup"><span data-stu-id="85ed3-213">NumBlogs</span></span> | <span data-ttu-id="85ed3-214">NumPostsPerBlog</span><span class="sxs-lookup"><span data-stu-id="85ed3-214">NumPostsPerBlog</span></span> |       <span data-ttu-id="85ed3-215">平均數</span><span class="sxs-lookup"><span data-stu-id="85ed3-215">Mean</span></span> |    <span data-ttu-id="85ed3-216">錯誤</span><span class="sxs-lookup"><span data-stu-id="85ed3-216">Error</span></span> |   <span data-ttu-id="85ed3-217">StdDev</span><span class="sxs-lookup"><span data-stu-id="85ed3-217">StdDev</span></span> |     <span data-ttu-id="85ed3-218">Median</span><span class="sxs-lookup"><span data-stu-id="85ed3-218">Median</span></span> | <span data-ttu-id="85ed3-219">外觀比例</span><span class="sxs-lookup"><span data-stu-id="85ed3-219">Ratio</span></span> | <span data-ttu-id="85ed3-220">RatioSD</span><span class="sxs-lookup"><span data-stu-id="85ed3-220">RatioSD</span></span> |   <span data-ttu-id="85ed3-221">Gen 0</span><span class="sxs-lookup"><span data-stu-id="85ed3-221">Gen 0</span></span> |   <span data-ttu-id="85ed3-222">Gen 1</span><span class="sxs-lookup"><span data-stu-id="85ed3-222">Gen 1</span></span> | <span data-ttu-id="85ed3-223">Gen 2</span><span class="sxs-lookup"><span data-stu-id="85ed3-223">Gen 2</span></span> | <span data-ttu-id="85ed3-224">已配置</span><span class="sxs-lookup"><span data-stu-id="85ed3-224">Allocated</span></span> |
|------------- |--------- |---------------- |-----------:|---------:|---------:|-----------:|------:|--------:|--------:|--------:|------:|----------:|
|   <span data-ttu-id="85ed3-225">AsTracking</span><span class="sxs-lookup"><span data-stu-id="85ed3-225">AsTracking</span></span> |       <span data-ttu-id="85ed3-226">10</span><span class="sxs-lookup"><span data-stu-id="85ed3-226">10</span></span> |              <span data-ttu-id="85ed3-227">20</span><span class="sxs-lookup"><span data-stu-id="85ed3-227">20</span></span> | <span data-ttu-id="85ed3-228">1414.7 美國</span><span class="sxs-lookup"><span data-stu-id="85ed3-228">1,414.7 us</span></span> | <span data-ttu-id="85ed3-229">27.20 美國</span><span class="sxs-lookup"><span data-stu-id="85ed3-229">27.20 us</span></span> | <span data-ttu-id="85ed3-230">45.44 美國</span><span class="sxs-lookup"><span data-stu-id="85ed3-230">45.44 us</span></span> | <span data-ttu-id="85ed3-231">1405.5 美國</span><span class="sxs-lookup"><span data-stu-id="85ed3-231">1,405.5 us</span></span> |  <span data-ttu-id="85ed3-232">1.00</span><span class="sxs-lookup"><span data-stu-id="85ed3-232">1.00</span></span> |    <span data-ttu-id="85ed3-233">0.00</span><span class="sxs-lookup"><span data-stu-id="85ed3-233">0.00</span></span> | <span data-ttu-id="85ed3-234">60.5469</span><span class="sxs-lookup"><span data-stu-id="85ed3-234">60.5469</span></span> | <span data-ttu-id="85ed3-235">13.6719</span><span class="sxs-lookup"><span data-stu-id="85ed3-235">13.6719</span></span> |     - | <span data-ttu-id="85ed3-236">380.11 KB</span><span class="sxs-lookup"><span data-stu-id="85ed3-236">380.11 KB</span></span> |
| <span data-ttu-id="85ed3-237">AsNoTracking</span><span class="sxs-lookup"><span data-stu-id="85ed3-237">AsNoTracking</span></span> |       <span data-ttu-id="85ed3-238">10</span><span class="sxs-lookup"><span data-stu-id="85ed3-238">10</span></span> |              <span data-ttu-id="85ed3-239">20</span><span class="sxs-lookup"><span data-stu-id="85ed3-239">20</span></span> |   <span data-ttu-id="85ed3-240">993.3 美國</span><span class="sxs-lookup"><span data-stu-id="85ed3-240">993.3 us</span></span> | <span data-ttu-id="85ed3-241">24.04 美國</span><span class="sxs-lookup"><span data-stu-id="85ed3-241">24.04 us</span></span> | <span data-ttu-id="85ed3-242">65.40 美國</span><span class="sxs-lookup"><span data-stu-id="85ed3-242">65.40 us</span></span> |   <span data-ttu-id="85ed3-243">966.2 美國</span><span class="sxs-lookup"><span data-stu-id="85ed3-243">966.2 us</span></span> |  <span data-ttu-id="85ed3-244">0.71</span><span class="sxs-lookup"><span data-stu-id="85ed3-244">0.71</span></span> |    <span data-ttu-id="85ed3-245">0.05</span><span class="sxs-lookup"><span data-stu-id="85ed3-245">0.05</span></span> | <span data-ttu-id="85ed3-246">37.1094</span><span class="sxs-lookup"><span data-stu-id="85ed3-246">37.1094</span></span> |  <span data-ttu-id="85ed3-247">6.8359</span><span class="sxs-lookup"><span data-stu-id="85ed3-247">6.8359</span></span> |     - | <span data-ttu-id="85ed3-248">232.89 KB</span><span class="sxs-lookup"><span data-stu-id="85ed3-248">232.89 KB</span></span> |

<span data-ttu-id="85ed3-249">最後，您可以使用無追蹤查詢，然後將傳回的實例附加至內容，以指定要進行的變更，來執行更新，而不會造成變更追蹤的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="85ed3-249">Finally, it is possible to perform updates without the overhead of change tracking, by utilizing a no-tracking query and then attaching the returned instance to the context, specifying which changes are to be made.</span></span> <span data-ttu-id="85ed3-250">這會將變更追蹤的負擔從 EF 轉移給使用者，而且只有在變更追蹤的額外負荷已顯示為無法透過分析或基準測試來接受時，才會進行嘗試。</span><span class="sxs-lookup"><span data-stu-id="85ed3-250">This transfers the burden of change tracking from EF to the user, and should only be attempted if the change tracking overhead has been shown to be unacceptable via profiling or benchmarking.</span></span>

## <a name="using-raw-sql"></a><span data-ttu-id="85ed3-251">使用原始 SQL</span><span class="sxs-lookup"><span data-stu-id="85ed3-251">Using raw SQL</span></span>

<span data-ttu-id="85ed3-252">在某些情況下，您的查詢會有更優化的 SQL，但 EF 不會產生。</span><span class="sxs-lookup"><span data-stu-id="85ed3-252">In some cases, more optimized SQL exists for your query, which EF does not generate.</span></span> <span data-ttu-id="85ed3-253">當 SQL 結構是不支援的資料庫的擴充功能，或只是因為 EF 尚未轉譯時，就會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="85ed3-253">This can happen when the SQL construct is an extension specific to your database that's unsupported, or simply because EF does not translate to it yet.</span></span> <span data-ttu-id="85ed3-254">在這些情況下，以手動方式撰寫 SQL 可提供大幅的效能提升，而且 EF 支援數種方式來執行這項作業。</span><span class="sxs-lookup"><span data-stu-id="85ed3-254">In these cases, writing SQL by hand can provide a substantial performance boost, and EF supports several ways to do this.</span></span>

* <span data-ttu-id="85ed3-255">[直接在您的查詢中](xref:core/querying/raw-sql)使用原始 SQL，例如 via <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A> 。</span><span class="sxs-lookup"><span data-stu-id="85ed3-255">Use raw SQL [directly in your query](xref:core/querying/raw-sql), e.g. via <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A>.</span></span> <span data-ttu-id="85ed3-256">EF 甚至還可讓您使用一般 LINQ 查詢來撰寫原始 SQL，讓您只在原始 SQL 中表達查詢的一部分。</span><span class="sxs-lookup"><span data-stu-id="85ed3-256">EF even lets you compose over the raw SQL with regular LINQ queries, allowing you to express only a part of the query in raw SQL.</span></span> <span data-ttu-id="85ed3-257">當原始 SQL 只需要在程式碼基底的單一查詢中使用時，這是很好的技巧。</span><span class="sxs-lookup"><span data-stu-id="85ed3-257">This is a good technique when the raw SQL only needs to be used in a single query in your codebase.</span></span>
* <span data-ttu-id="85ed3-258">定義 [使用者定義函數](xref:core/querying/database-functions) (UDF) ，然後從您的查詢中呼叫該函式。</span><span class="sxs-lookup"><span data-stu-id="85ed3-258">Define a [user-defined function](xref:core/querying/database-functions) (UDF), and then call that from your queries.</span></span> <span data-ttu-id="85ed3-259">請注意，從5.0 開始，EF 會讓 Udf 傳回完整的結果集，這些結果稱為資料表值函式 (Tvf) -而且也可將對應至函式 `DbSet` ，使其看起來就像是另一個資料表。</span><span class="sxs-lookup"><span data-stu-id="85ed3-259">Note that since 5.0, EF allows UDFs to return full resultsets - these are known as table-valued functions (TVFs) - and also allows mapping a `DbSet` to a function, making it look just like just another table.</span></span>
* <span data-ttu-id="85ed3-260">在您的查詢中定義資料庫檢視和查詢。</span><span class="sxs-lookup"><span data-stu-id="85ed3-260">Define a database view and query from it in your queries.</span></span> <span data-ttu-id="85ed3-261">請注意，與函式不同的是，views 無法接受參數。</span><span class="sxs-lookup"><span data-stu-id="85ed3-261">Note that unlike functions, views cannot accept parameters.</span></span>

> [!NOTE]
> <span data-ttu-id="85ed3-262">原始 SQL 通常在確定 EF 無法產生您想要的 SQL 之後，以及效能對於指定的查詢是否很重要時，通常會用來做為最後的手段。</span><span class="sxs-lookup"><span data-stu-id="85ed3-262">Raw SQL should generally be used as a last resort, after making sure that EF can't generate the SQL you want, and when performance is important enough for the given query to justify it.</span></span> <span data-ttu-id="85ed3-263">使用原始 SQL 會帶來可觀的維護缺點。</span><span class="sxs-lookup"><span data-stu-id="85ed3-263">Using raw SQL brings considerable maintenance disadvantages.</span></span>

## <a name="asynchronous-programming"></a><span data-ttu-id="85ed3-264">非同步程式設計</span><span class="sxs-lookup"><span data-stu-id="85ed3-264">Asynchronous programming</span></span>

<span data-ttu-id="85ed3-265">一般而言，為了讓您的應用程式能夠進行調整，請務必一律使用非同步 Api，而不是同步一個 (例如， <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> 而不是 <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>) 。</span><span class="sxs-lookup"><span data-stu-id="85ed3-265">As a general rule, in order for your application to be scalable, it's important to always use asynchronous APIs rather than synchronous one (e.g. <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> rather than <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>).</span></span> <span data-ttu-id="85ed3-266">同步 Api 會在資料庫 i/o 期間封鎖執行緒，增加執行緒的需求，以及必須發生的執行緒內容切換數目。</span><span class="sxs-lookup"><span data-stu-id="85ed3-266">Synchronous APIs block the thread for the duration of database I/O, increasing the need for threads and the number of thread context switches that must occur.</span></span>

<span data-ttu-id="85ed3-267">如需詳細資訊，請參閱 [非同步程式設計](xref:core/miscellaneous/async)上的頁面。</span><span class="sxs-lookup"><span data-stu-id="85ed3-267">For more information, see the page on [async programming](xref:core/miscellaneous/async).</span></span>

> [!WARNING]
> <span data-ttu-id="85ed3-268">避免在相同的應用程式中混用同步和非同步程式碼-很容易不小心觸發微妙的執行緒集區耗盡問題。</span><span class="sxs-lookup"><span data-stu-id="85ed3-268">Avoid mixing synchronous and asynchronous code in the same application - it's very easy to inadvertently trigger subtle thread-pool starvation issues.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="85ed3-269">其他資源</span><span class="sxs-lookup"><span data-stu-id="85ed3-269">Additional resources</span></span>

<span data-ttu-id="85ed3-270">請參閱 null 比較檔頁面的 [效能區段](xref:core/querying/null-comparisons#writing-performant-queries) ，以取得比較可為 null 值時的一些最佳作法。</span><span class="sxs-lookup"><span data-stu-id="85ed3-270">See the [performance section](xref:core/querying/null-comparisons#writing-performant-queries) of the null comparison documentation page for some best practices when comparing nullable values.</span></span>
