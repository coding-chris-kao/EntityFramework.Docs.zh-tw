---
title: 效能簡介-EF Core
description: 有效使用 Entity Framework Core 的效能指南
author: roji
ms.date: 12/1/2020
uid: core/miscellaneous/performance/index
ms.openlocfilehash: 14400d81ea3c93e2ebf40e8e585a457abf31478f
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657790"
---
# <a name="introduction-to-performance"></a><span data-ttu-id="7fde7-103">效能簡介</span><span class="sxs-lookup"><span data-stu-id="7fde7-103">Introduction to Performance</span></span>

<span data-ttu-id="7fde7-104">資料庫效能是廣泛且複雜的主題，橫跨整個元件堆疊：資料庫、網路、資料庫驅動程式，以及資料存取層（例如 EF Core）。</span><span class="sxs-lookup"><span data-stu-id="7fde7-104">Database performance is a vast and complex topic, spanning an entire stack of components: the database, networking, the database driver, and data access layers such as EF Core.</span></span> <span data-ttu-id="7fde7-105">雖然高階層和 O/RMs （例如 EF Core 可大幅簡化應用程式開發和改進可維護性），但有時可能不透明，隱藏效能關鍵性的內部詳細資料，例如執行的 SQL。</span><span class="sxs-lookup"><span data-stu-id="7fde7-105">While high-level layers and O/RMs such as EF Core considerably simplify application development and improve maintainability, they can sometimes be opaque, hiding performance-critical internal details such as the SQL being executed.</span></span> <span data-ttu-id="7fde7-106">本節將嘗試概述如何使用 EF Core 達到良好效能，以及如何避免可能會降低應用程式效能的常見陷阱。</span><span class="sxs-lookup"><span data-stu-id="7fde7-106">This section attempts to provide an overview of how to achieve good performance with EF Core, and how to avoid common pitfalls which can degrade application performance.</span></span>

## <a name="identify-bottlenecks-and-measure-measure-measure"></a><span data-ttu-id="7fde7-107">找出瓶頸和測量、測量、量值</span><span class="sxs-lookup"><span data-stu-id="7fde7-107">Identify bottlenecks and measure, measure, measure</span></span>

<span data-ttu-id="7fde7-108">一律具有效能，請務必不要在沒有顯示問題的資料的情況下進行優化。最棒的 Donald Knuth 一說，「過早的優化是所有惡意的根本」。</span><span class="sxs-lookup"><span data-stu-id="7fde7-108">As always with performance, it's important not to rush into optimization without data showing a problem; as the great Donald Knuth once said, "Premature optimization is the root of all evil".</span></span> <span data-ttu-id="7fde7-109">[效能診斷](xref:core/performance/performance-diagnosis)區段討論各種方法來瞭解應用程式在資料庫邏輯中花費時間的位置，以及如何找出特定的問題區域。</span><span class="sxs-lookup"><span data-stu-id="7fde7-109">The [performance diagnosis](xref:core/performance/performance-diagnosis) section discusses various ways to understand where your application is spending time in database logic, and how to pinpoint specific problematic areas.</span></span> <span data-ttu-id="7fde7-110">一旦識別出緩慢的查詢，就可以考慮解決問題：您的資料庫是否遺漏了索引？</span><span class="sxs-lookup"><span data-stu-id="7fde7-110">Once a slow query has been identified, solutions can be considered: is your database missing an index?</span></span> <span data-ttu-id="7fde7-111">您應該嘗試其他查詢模式嗎？</span><span class="sxs-lookup"><span data-stu-id="7fde7-111">Should you try out other querying patterns?</span></span>

<span data-ttu-id="7fde7-112">一律將您的程式碼和可能的替代專案進行基準測試-效能診斷區段包含 BenchmarkDotNet 的範例基準測試，可供您用來作為自己基準測試的範本。</span><span class="sxs-lookup"><span data-stu-id="7fde7-112">Always benchmark your code and possible alternatives yourself - the performance diagnosis section contains a sample benchmark with BenchmarkDotNet, which you can use as a template for your own benchmarks.</span></span> <span data-ttu-id="7fde7-113">請勿假設一般，公用基準測試適用于您的特定使用案例;您資料表中的各種因素（例如資料庫延遲、查詢複雜度和實際資料量）可能會對最適合的解決方案造成深遠的影響。</span><span class="sxs-lookup"><span data-stu-id="7fde7-113">Don't assume that general, public benchmarks apply as-is to your specific use-case; a variety of factors such as database latency, query complexity and actual data amounts in your tables can have a profound effect on which solution is best.</span></span> <span data-ttu-id="7fde7-114">例如，許多公用基準測試都是在理想的網路狀況下執行，其中資料庫的延遲幾乎為零，而且具有非常輕量的查詢，這幾乎不需要在資料庫端) 任何處理 (或磁片 i/o。</span><span class="sxs-lookup"><span data-stu-id="7fde7-114">For example, many public benchmarks are carried out in ideal networking conditions, where latency to the database is almost zero, and with extremely light queries which hardly require any processing (or disk I/O) on the database side.</span></span> <span data-ttu-id="7fde7-115">雖然這些很適合用來比較不同資料存取層的執行時間負荷，但是它們所顯示的差異通常會在實際的應用程式中證明是微不足道的，在此情況下，資料庫會對資料庫執行實際工作和延遲，是一項重要的效能因素。</span><span class="sxs-lookup"><span data-stu-id="7fde7-115">While these are valuable for comparing the runtime overheads of different data access layers, the differences they reveal usually prove to be negligible in a real-world application, where the database performs actual work and latency to the database is a significant perf factor.</span></span>

## <a name="aspects-of-data-access-performance"></a><span data-ttu-id="7fde7-116">資料存取效能的各個層面</span><span class="sxs-lookup"><span data-stu-id="7fde7-116">Aspects of data access performance</span></span>

<span data-ttu-id="7fde7-117">整體資料存取效能可細分為下列廣泛的類別：</span><span class="sxs-lookup"><span data-stu-id="7fde7-117">Overall data access performance can be broken down into the following broad categories:</span></span>

* <span data-ttu-id="7fde7-118">**純資料庫效能**。</span><span class="sxs-lookup"><span data-stu-id="7fde7-118">**Pure database performance**.</span></span> <span data-ttu-id="7fde7-119">使用關係資料庫時，EF 會將應用程式的 LINQ 查詢轉譯成資料庫所執行的 SQL 語句。這些 SQL 語句本身可以執行更多或更少的效率。</span><span class="sxs-lookup"><span data-stu-id="7fde7-119">With relational database, EF translates the application's LINQ queries into the SQL statements getting executed by the database; these SQL statements themselves can run more or less efficiently.</span></span> <span data-ttu-id="7fde7-120">適當位置中的正確索引可能會讓 SQL 效能產生差異，或重寫您的 LINQ 查詢可能會讓 EF 產生更好的 SQL 查詢。</span><span class="sxs-lookup"><span data-stu-id="7fde7-120">The right index in the right place can make a world of difference in SQL performance, or rewriting your LINQ query may make EF generate a better SQL query.</span></span>
* <span data-ttu-id="7fde7-121">**網路資料傳輸**。</span><span class="sxs-lookup"><span data-stu-id="7fde7-121">**Network data transfer**.</span></span> <span data-ttu-id="7fde7-122">與任何網路系統一樣，請務必限制在網路上來回傳輸的資料量。</span><span class="sxs-lookup"><span data-stu-id="7fde7-122">As with any networking system, it's important to limit the amount of data going back and forth on the wire.</span></span> <span data-ttu-id="7fde7-123">這包括確保您只會傳送和載入您實際需要的資料，但也會在載入相關實體時避免所謂的「笛卡兒爆炸」效果。</span><span class="sxs-lookup"><span data-stu-id="7fde7-123">This covers making sure that you only send and load data which you're actually going to need, but also avoiding the so-called "cartesian explosion" effect when loading related entities.</span></span>
* <span data-ttu-id="7fde7-124">**網路往返**。</span><span class="sxs-lookup"><span data-stu-id="7fde7-124">**Network roundtrips**.</span></span> <span data-ttu-id="7fde7-125">除了往返的資料量之外，網路往返的時間，是因為在資料庫中執行查詢所花費的時間，可在您的應用程式與資料庫之間來回傳送的時間小巫見大巫。</span><span class="sxs-lookup"><span data-stu-id="7fde7-125">Beyond the amount of data going back and forth, the network roundtrips, since the time taken for a query to execute in the database can be dwarfed by the time packets travel back and forth between your application and your database.</span></span> <span data-ttu-id="7fde7-126">往返負荷嚴重取決於您的環境;您的資料庫伺服器越遠，延遲就越高，越大每次往返。</span><span class="sxs-lookup"><span data-stu-id="7fde7-126">Roundtrip overhead heavily depends on your environment; the further away your database server is, the high the latency and the costlier each roundtrip.</span></span> <span data-ttu-id="7fde7-127">隨著雲端的出現，應用程式逐漸發現自己的資料庫，而「多對話」的應用程式執行過多的往返效能也會降低效能。</span><span class="sxs-lookup"><span data-stu-id="7fde7-127">With the advent of the cloud, applications increasingly find themselves further away from the database, and "chatty" applications which perform too many roundtrips experience degraded performance.</span></span> <span data-ttu-id="7fde7-128">因此，請務必瞭解您的應用程式何時要與資料庫聯繫、其執行的往返次數，以及該數位是否可以最小化。</span><span class="sxs-lookup"><span data-stu-id="7fde7-128">Therefore, it's important to understand exactly when your application contacts the database, how many roundtrips it performs, and whether that number can be minimized them.</span></span>
* <span data-ttu-id="7fde7-129">**EF 執行時間額外負荷**。</span><span class="sxs-lookup"><span data-stu-id="7fde7-129">**EF runtime overhead**.</span></span> <span data-ttu-id="7fde7-130">最後，EF 本身會將一些執行時間額外負荷新增至資料庫作業： EF 需要從 (LINQ to SQL 編譯您的查詢，但通常只需進行一次) ，變更追蹤會增加一些額外負荷 (但可以停用) 等等。在實務上，在大部分情況下，實際應用程式的 EF 額外負荷可能會很微不足道，因為資料庫中的查詢執行時間和網路延遲會占總時間;但請務必瞭解您的選項是什麼，以及如何避免一些陷阱。</span><span class="sxs-lookup"><span data-stu-id="7fde7-130">Finally, EF itself adds some runtime overhead to database operations: EF needs to compile your queries from LINQ to SQL (although that should normally be done only once), change tracking adds some overhead (but can be disabled), etc. In practice, the EF overhead for real-world applications is likely to be negligible in most cases, as query execution time in the database and network latency dominate the total time; but it's important to understand what your options are and how to avoid some pitfalls.</span></span>

## <a name="know-whats-happening-under-the-hood"></a><span data-ttu-id="7fde7-131">知道幕後的進展</span><span class="sxs-lookup"><span data-stu-id="7fde7-131">Know what's happening under the hood</span></span>

<span data-ttu-id="7fde7-132">EF 可讓開發人員藉由產生 SQL、具體化結果和執行其他工作，專注于商務邏輯。</span><span class="sxs-lookup"><span data-stu-id="7fde7-132">EF allows developers to concentrate on business logic by generating SQL, materializing results, and performing other tasks.</span></span> <span data-ttu-id="7fde7-133">就像任何分層或抽象化一樣，它也可以隱藏幕後發生的情況，例如執行的實際 SQL 查詢。</span><span class="sxs-lookup"><span data-stu-id="7fde7-133">Like any layer or abstraction, it also tends to hide what's happening under-the-hood, such as the actual SQL queries being executed.</span></span> <span data-ttu-id="7fde7-134">效能不一定是每個應用程式的重要層面，但是在應用程式中，開發人員必須瞭解 EF 對它們執行的動作：檢查輸出的 SQL 查詢、遵循往返以確定未發生 N + 1 問題等等。</span><span class="sxs-lookup"><span data-stu-id="7fde7-134">Performance isn't necessarily a critical aspect of every application out there, but in applications where it is, it is vital that the developer understand what EF is doing for them: inspect outgoing SQL queries, follow roundtrips to make sure the N+1 problem isn't occurring, etc.</span></span>

## <a name="cache-outside-the-database"></a><span data-ttu-id="7fde7-135">在資料庫外部快取</span><span class="sxs-lookup"><span data-stu-id="7fde7-135">Cache outside the database</span></span>

<span data-ttu-id="7fde7-136">最後，與資料庫互動最有效率的方法是完全不要與其互動。</span><span class="sxs-lookup"><span data-stu-id="7fde7-136">Finally, the most efficient way to interact with a database, is to not interact with it at all.</span></span> <span data-ttu-id="7fde7-137">換句話說，如果資料庫存取在您的應用程式中顯示為效能瓶頸，則在資料庫之外快取某些結果可能是值得的，以便將要求降至最低。</span><span class="sxs-lookup"><span data-stu-id="7fde7-137">In other words, if database access shows up as a performance bottleneck in your application, it may be worthwhile to cache certain results outside of the database, so as to minimize requests.</span></span> <span data-ttu-id="7fde7-138">雖然快取會增加複雜度，但它是任何可擴充應用程式中特別重要的部分：雖然應用層可以藉由新增額外的伺服器來處理增加的負載，藉此輕鬆調整，而調整資料庫層級通常會更複雜。</span><span class="sxs-lookup"><span data-stu-id="7fde7-138">Although caching adds complexity, it is an especially crucial part of any scalable application: while the application tier can be easy scaled by adding additional servers to handle increased load, scaling the database tier is usually far more complicated.</span></span>
