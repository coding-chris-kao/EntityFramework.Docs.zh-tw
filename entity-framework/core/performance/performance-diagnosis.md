---
title: 效能診斷-EF Core
description: 診斷 Entity Framework Core 效能並找出瓶頸
author: roji
ms.date: 12/1/2020
uid: core/performance/performance-diagnosis
ms.openlocfilehash: 9416acf3326056ef7a5d732c4bd456dac751167b
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657787"
---
# <a name="performance-diagnosis"></a><span data-ttu-id="ef0cb-103">效能診斷</span><span class="sxs-lookup"><span data-stu-id="ef0cb-103">Performance Diagnosis</span></span>

<span data-ttu-id="ef0cb-104">本節討論在 EF 應用程式中偵測效能問題的方法，以及在識別出有問題的區域之後，如何進一步分析這些問題以找出根本問題。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-104">This section discusses ways for detecting performance issues in your EF application, and once a problematic area has been identified, how to further analyze them to identify the root problem.</span></span> <span data-ttu-id="ef0cb-105">在跳到任何結論之前，請務必仔細診斷和調查任何問題，並避免發生問題根源的位置。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-105">It's important to carefully diagnose and investigate any problems before jumping to any conclusions, and to avoid assuming where the root of the issue is.</span></span>

## <a name="identifying-slow-database-commands-via-logging"></a><span data-ttu-id="ef0cb-106">透過記錄來識別慢速資料庫命令</span><span class="sxs-lookup"><span data-stu-id="ef0cb-106">Identifying slow database commands via logging</span></span>

<span data-ttu-id="ef0cb-107">在一天結束時，EF 會準備並執行要對資料庫執行的命令;使用關係資料庫時，這表示透過 ADO.NET 資料庫 API 來執行 SQL 語句。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-107">At the end of the day, EF prepares and executes commands to be executed against your database; with relational database, that means executing SQL statements via the ADO.NET database API.</span></span> <span data-ttu-id="ef0cb-108">如果某個查詢花費太多時間 (例如，因為遺漏了索引) ，檢查命令執行記錄並觀察實際花費的時間，就可以看到這種情況。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-108">If a certain query is taking too much time (e.g. because an index is missing), this can be seen discovered by inspecting command execution logs and observing how long they actually take.</span></span>

<span data-ttu-id="ef0cb-109">EF 可讓您輕鬆地透過 [簡單的記錄](xref:core/logging-events-diagnostics/simple-logging) 或 Microsoft 副檔名來捕捉命令執行時間 [。記錄](xref:core/logging-events-diagnostics/extensions-logging)：</span><span class="sxs-lookup"><span data-stu-id="ef0cb-109">EF makes it very easy to capture command execution times, via either [simple logging](xref:core/logging-events-diagnostics/simple-logging) or [Microsoft.Extensions.Logging](xref:core/logging-events-diagnostics/extensions-logging):</span></span>

### <a name="simple-logging"></a>[<span data-ttu-id="ef0cb-110">簡單記錄</span><span class="sxs-lookup"><span data-stu-id="ef0cb-110">Simple logging</span></span>](#tab/simple-logging)

[!code-csharp[Main](../../../samples/core/Performance/BloggingContext.cs#SimpleLogging)]

### <a name="microsoftextensionslogging"></a>[<span data-ttu-id="ef0cb-111">Microsoft.Extensions.Logging</span><span class="sxs-lookup"><span data-stu-id="ef0cb-111">Microsoft.Extensions.Logging</span></span>](#tab/microsoft-extensions-logging)

[!code-csharp[Main](../../../samples/core/Performance/ExtensionsLoggingContext.cs#ExtensionsLogging)]

***

<span data-ttu-id="ef0cb-112">當記錄層級設定為時 `LogLevel.Information` ，EF 會發出每個命令執行的記錄檔訊息，以及花費的時間：</span><span class="sxs-lookup"><span data-stu-id="ef0cb-112">When the logging level is set at `LogLevel.Information`, EF emits a log message for each command execution with the time taken:</span></span>

```log
info: 06/12/2020 09:12:36.117 RelationalEventId.CommandExecuted[20101] (Microsoft.EntityFrameworkCore.Database.Command)
      Executed DbCommand (4ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[Id], [b].[Name]
      FROM [Blogs] AS [b]
      WHERE [b].[Name] = N'foo'
```

<span data-ttu-id="ef0cb-113">上述命令所花的時間是4毫秒。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-113">The above command took 4 milliseconds.</span></span> <span data-ttu-id="ef0cb-114">如果某個命令所使用的不是預期的，您發現效能問題可能有問題，而且現在可以將焦點放在其上，以瞭解其執行速度很慢的原因。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-114">If a certain command takes more than expected, you've found a possible culprit for a performance issue, and can now focus on it to understand why it's running slowly.</span></span> <span data-ttu-id="ef0cb-115">命令記錄也可以顯示正在進行非預期的資料庫往返的情況;這會顯示為只預期一個的多個命令。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-115">Command logging can also reveal cases where unexpected database roundtrips are being made; this would show up as multiple commands where only one is expected.</span></span>

> [!WARNING]
> <span data-ttu-id="ef0cb-116">在生產環境中啟用命令執行記錄，通常是個不錯的主意。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-116">Leaving command execution logging enabled in your production environment is usually a bad idea.</span></span> <span data-ttu-id="ef0cb-117">記錄本身會讓您的應用程式變慢，而且可以快速建立大量記錄檔，以填滿您的伺服器磁片。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-117">The logging itself slows down your application, and may quickly create huge log files which can fill up your server's disk.</span></span> <span data-ttu-id="ef0cb-118">建議您只保持登入一小段時間來收集資料，並仔細監視您的應用程式，或在進入生產階段前系統上捕獲記錄資料。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-118">It's recommended to only keep logging on for a short interval of time to gather data - while carefully monitoring your application - or to capture logging data on a pre-production system.</span></span>

## <a name="correlating-database-commands-to-linq-queries"></a><span data-ttu-id="ef0cb-119">將資料庫命令與 LINQ 查詢相互關聯</span><span class="sxs-lookup"><span data-stu-id="ef0cb-119">Correlating database commands to LINQ queries</span></span>

<span data-ttu-id="ef0cb-120">命令執行記錄的其中一個問題是，有時很難相互關聯 SQL 查詢和 LINQ 查詢： EF 所執行的 SQL 命令看起來可能與產生它們的 LINQ 查詢非常不同。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-120">One problem with command execution logging is that it's sometimes difficult to correlate SQL queries and LINQ queries: the SQL commands executed by EF can look very different from the LINQ queries from which they were generated.</span></span> <span data-ttu-id="ef0cb-121">為了協助解決這個問題，您可能會想要使用 EF 的 [查詢標記](xref:core/querying/tags) 功能，讓您在 SQL 查詢中插入一個小型的識別批註：</span><span class="sxs-lookup"><span data-stu-id="ef0cb-121">To help with this difficulty, you may want to use EF's [query tags](xref:core/querying/tags) feature, which allows you to inject a small, identifying comment into the SQL query:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tags/Program.cs#BasicQueryTag)]

<span data-ttu-id="ef0cb-122">標記會顯示在記錄中：</span><span class="sxs-lookup"><span data-stu-id="ef0cb-122">The tag shows up in the logs:</span></span>

```sql
-- This is my spatial query!

SELECT TOP(@__p_1) [p].[Id], [p].[Location]
FROM [People] AS [p]
ORDER BY [p].[Location].STDistance(@__myLocation_0) DESC
```

<span data-ttu-id="ef0cb-123">通常值得以這種方式標記應用程式的主要查詢，讓命令執行記錄更容易讀取。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-123">It's often worth tagging the major queries of an application in this way, to make the command execution logs more immediately readable.</span></span>

## <a name="other-interfaces-for-capturing-performance-data"></a><span data-ttu-id="ef0cb-124">用於捕獲效能資料的其他介面</span><span class="sxs-lookup"><span data-stu-id="ef0cb-124">Other interfaces for capturing performance data</span></span>

<span data-ttu-id="ef0cb-125">EF 的記錄功能有許多替代方法可以用來捕捉命令執行時間，這可能更強大。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-125">There are various alternatives to EF's logging feature for capturing command execution times, which may be more powerful.</span></span> <span data-ttu-id="ef0cb-126">資料庫通常會隨附自己的追蹤和效能分析工具，這些工具通常會提供更豐富的資料庫特定資訊，而不只是簡單的執行時間;實際的設定、功能和使用方式在不同的資料庫之間會有很大的差別。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-126">Databases typically come with their own tracing and performance analysis tools, which usually provide much richer, database-specific information beyond simple execution times; the actual setup, capabilities and usage vary considerably across databases.</span></span>

<span data-ttu-id="ef0cb-127">例如， [SQL Server Management Studio](/sql/ssms/download-sql-server-management-studio-ssms) 是一個功能強大的用戶端，可連接到您的 SQL Server 實例，並提供重要的管理和效能資訊。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-127">For example, [SQL Server Management Studio](/sql/ssms/download-sql-server-management-studio-ssms) is a powerful client that can connect to your SQL Server  instance and provide valuable management and performance information.</span></span> <span data-ttu-id="ef0cb-128">本章節涵蓋的詳細資料不在本章節的討論範圍內，但有兩項值得一提的功能是 [活動監視器](/sql/relational-databases/performance-monitor/open-activity-monitor-sql-server-management-studio)，它提供了伺服器活動的即時儀表板 (包括) 的最高成本查詢，以及 [擴充的事件 (XEvent) ](/sql/relational-databases/extended-events/quick-start-extended-events-in-sql-server) 功能，可讓您定義可針對您的確切需求量身打造的任意資料捕獲會話。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-128">It's beyond the scope of this section to go into the details, but two capabilities worth mentioning are the [Activity Monitor](/sql/relational-databases/performance-monitor/open-activity-monitor-sql-server-management-studio), which provides a live dashboard of server activity (including the most expensive queries), and the [Extended Events (XEvent)](/sql/relational-databases/extended-events/quick-start-extended-events-in-sql-server) feature, which allows defining arbitrary data capture sessions which can be tailored to your exact needs.</span></span> <span data-ttu-id="ef0cb-129">[有關監視的 SQL Server 檔](/sql/relational-databases/performance/monitor-and-tune-for-performance) 會提供這些功能以及其他功能的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-129">[The SQL Server documentation on monitoring](/sql/relational-databases/performance/monitor-and-tune-for-performance) provides more information on these features, as well as others.</span></span>

<span data-ttu-id="ef0cb-130">另一種捕獲效能資料的方法是透過介面收集由 EF 或資料庫驅動程式自動發出的資訊 `DiagnosticSource` ，然後分析該資料，或將其顯示在儀表板上。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-130">Another approach for capturing performance data is to collect information automatically emitted by either EF or the database driver via the `DiagnosticSource` interface, and then analyze that data or display it on a dashboard.</span></span> <span data-ttu-id="ef0cb-131">如果您使用 Azure， [Azure 應用程式 Insights](https://docs.microsoft.com/azure/azure-monitor/learn/tutorial-performance) 會提供現成的強大監視功能，並在分析您的 web 要求的速度時，整合資料庫效能和查詢執行時間。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-131">If you are using Azure, then [Azure Application Insights](https://docs.microsoft.com/azure/azure-monitor/learn/tutorial-performance) provides such powerful monitoring out of the box, integrating database performance and query execution times in the analysis of how quickly your web requests are being served.</span></span> <span data-ttu-id="ef0cb-132">有關此功能的詳細資訊可在 [Application Insights 效能教學](/azure/azure-monitor/learn/tutorial-performance)課程和 [Azure SQL 分析頁面](/azure/azure-monitor/insights/azure-sql)中取得。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-132">More information on this is available in the [Application Insights performance tutorial](/azure/azure-monitor/learn/tutorial-performance), and in the [Azure SQL analytics page](/azure/azure-monitor/insights/azure-sql).</span></span>

## <a name="inspecting-query-execution-plans"></a><span data-ttu-id="ef0cb-133">檢查查詢執行計畫</span><span class="sxs-lookup"><span data-stu-id="ef0cb-133">Inspecting query execution plans</span></span>

<span data-ttu-id="ef0cb-134">當您指出需要優化的有問題查詢之後，下一個步驟通常是分析查詢的 *執行計畫*。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-134">Once you've pinpointed a problematic query that requires optimization, the next step is usually analyzing the query's *execution plan*.</span></span> <span data-ttu-id="ef0cb-135">當資料庫收到 SQL 語句時，它們通常會產生計畫的執行方式，這有時候需要根據已定義的索引、資料表中有多少資料，以及資料表中有多少資料，而這種情況下，也需要在伺服器上快取計畫本身，以獲得最佳效能) 的 (。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-135">When databases receive a SQL statement, they typically produce a plan of how that plan is to be executed; this sometimes requires complicated decision-making based on which indexes have been defined, how much data exists in tables, etc. (incidentally, the plan itself should usually be cached at the server for optimal performance).</span></span> <span data-ttu-id="ef0cb-136">關係資料庫通常會提供一種方式，讓使用者查看查詢計劃，以及查詢的不同部分的計算成本。這對改善您的查詢非常有用。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-136">Relational databases typically provide a way for users to see the query plan, along with calculated costing for different parts of the query; this is invaluable for improving your queries.</span></span>

<span data-ttu-id="ef0cb-137">若要開始 SQL Server，請參閱 [查詢執行計畫](/sql/relational-databases/performance/execution-plans)的相關檔。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-137">To get started on SQL Server, see the documentation on [query execution plans](/sql/relational-databases/performance/execution-plans).</span></span> <span data-ttu-id="ef0cb-138">一般分析工作流程是使用 [SQL Server Management Studio](/sql/relational-databases/performance/display-an-actual-execution-plan)、貼上透過上述其中一種方式識別的慢速查詢 SQL，以及 [產生圖形化執行計畫](/sql/relational-databases/performance/display-an-actual-execution-plan)：</span><span class="sxs-lookup"><span data-stu-id="ef0cb-138">The typical analysis workflow would be to use [SQL Server Management Studio](/sql/relational-databases/performance/display-an-actual-execution-plan), pasting the SQL of a slow query identified via one of the means above, and [producing a graphical execution plan](/sql/relational-databases/performance/display-an-actual-execution-plan):</span></span>

![顯示 SQL Server 執行計畫](_static/actualexecplan.png)

<span data-ttu-id="ef0cb-140">雖然執行計畫在一開始可能有點複雜，但值得花一點時間熟悉它們。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-140">While execution plans may seem complicated at first, it's worth spending a bit of time getting familiar with them.</span></span> <span data-ttu-id="ef0cb-141">特別重要的是，請注意與方案的每個節點相關聯的成本，以及識別如何在不同的節點中 () 使用索引。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-141">It's particularly important to note the costs associated with each node of the plan, and to identify how indexes are used (or not) in the various nodes.</span></span>

<span data-ttu-id="ef0cb-142">雖然上述資訊是 SQL Server 特有的資訊，但其他資料庫通常會提供具有類似視覺效果的相同類型工具。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-142">While the above information is specific to SQL Server, other databases typically provide the same kind of tools with similar visualization.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="ef0cb-143">資料庫有時會根據資料庫中的實際資料來產生不同的查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-143">Databases sometimes generate different query plans depending on actual data in the database.</span></span> <span data-ttu-id="ef0cb-144">例如，如果資料表只包含幾個資料列，則資料庫可能會選擇不使用該資料表上的索引，而是改為執行完整資料表掃描。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-144">For example, if a table contains only a few rows, a database may choose not to use an index on that table, but to perform a full table scan instead.</span></span> <span data-ttu-id="ef0cb-145">如果要分析測試資料庫上的查詢計劃，請務必確定它包含的資料與您的生產系統類似。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-145">If analyzing query plans on a test database, always make sure it contains data that is similar to your production system.</span></span>

## <a name="event-counters"></a><span data-ttu-id="ef0cb-146">事件計數器</span><span class="sxs-lookup"><span data-stu-id="ef0cb-146">Event counters</span></span>

<span data-ttu-id="ef0cb-147">上述各節著重于如何取得命令的相關資訊，以及如何在資料庫中執行這些命令。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-147">The above sections focused on how to get information about your commands, and how these commands are executed in the database.</span></span> <span data-ttu-id="ef0cb-148">除此之外，EF 也會公開一組 *事件計數器* ，以提供 EF 本身內發生之狀況的較低層級資訊，以及您的應用程式使用它的方式。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-148">In addition to that, EF exposes a set of *event counters* which provide more lower-level information on what's happening inside EF itself, and how your application is using it.</span></span> <span data-ttu-id="ef0cb-149">這些計數器有助於診斷特定效能問題和效能異常，例如導致重新編譯的查詢快取 [問題](xref:core/performance/advanced-performance-topics#dynamically-constructed-queries) 、尚未處置 DbCoNtext 流失，以及其他。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-149">These counters can be very useful for diagnosing specific performance issues and performance anomalies, such as [query caching issues](xref:core/performance/advanced-performance-topics#dynamically-constructed-queries) which cause constant recompilation, undisposed DbContext leaks, and others.</span></span>

<span data-ttu-id="ef0cb-150">如需詳細資訊，請參閱 [EF 事件計數器](xref:core/logging-events-diagnostics/event-counters) 的專用頁面。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-150">See the dedicated page on [EF's event counters](xref:core/logging-events-diagnostics/event-counters) for more information.</span></span>

## <a name="benchmarking-with-ef-core"></a><span data-ttu-id="ef0cb-151">EF Core 的基準測試</span><span class="sxs-lookup"><span data-stu-id="ef0cb-151">Benchmarking with EF Core</span></span>

<span data-ttu-id="ef0cb-152">在一天結束時，您有時需要知道撰寫或執行查詢的特定方式是否比另一種方法更快。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-152">At the end of the day, you sometimes need to know whether a particular way of writing or executing a query is faster than another.</span></span> <span data-ttu-id="ef0cb-153">絕對不要設想或 speculate 答案很重要，而且很容易就能將快速基準測試放在一起以取得答案。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-153">It's important to never assume or speculate the answer, and it's extremely easy to put together a quick benchmark to get the answer.</span></span> <span data-ttu-id="ef0cb-154">撰寫基準測試時，強烈建議使用已知的 [BenchmarkDotNet](https://benchmarkdotnet.org/index.html) 程式庫，它會處理使用者嘗試撰寫自己的基準測試時遇到的許多陷阱：您是否已執行一些預先準備的反復專案？</span><span class="sxs-lookup"><span data-stu-id="ef0cb-154">When writing benchmarks, it's strongly recommended to use the well-known [BenchmarkDotNet](https://benchmarkdotnet.org/index.html) library, which handles many pitfalls users encounter when trying to write their own benchmarks: have you performed some warmup iterations?</span></span> <span data-ttu-id="ef0cb-155">您的基準測試實際執行的反覆運算次數，以及原因為何？</span><span class="sxs-lookup"><span data-stu-id="ef0cb-155">How many iterations does your benchmark actually run, and why?</span></span> <span data-ttu-id="ef0cb-156">讓我們看看 EF Core 的基準測試。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-156">Let's take a look at what a benchmark with EF Core looks like.</span></span>

> [!TIP]
> <span data-ttu-id="ef0cb-157">[以下提供適用](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs)于下列來源的完整基準測試專案。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-157">The full benchmark project for the source below is available [here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs).</span></span> <span data-ttu-id="ef0cb-158">建議您將它複製，並使用它作為您自己基準測試的範本。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-158">You are encouraged to copy it and use it as a template for your own benchmarks.</span></span>

<span data-ttu-id="ef0cb-159">作為簡單的基準測試案例，讓我們比較下列不同的方法來計算資料庫中所有 Blog 的平均排名：</span><span class="sxs-lookup"><span data-stu-id="ef0cb-159">As a simple benchmark scenario, let's compare the following different methods of calculating the average ranking of all Blogs in our database:</span></span>

* <span data-ttu-id="ef0cb-160">載入所有實體、加總其個別排名，並計算平均值。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-160">Load all entities, sum up their individual rankings, and calculate the average.</span></span>
* <span data-ttu-id="ef0cb-161">與上述相同，只使用非追蹤查詢。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-161">The same as above, only use a non-tracking query.</span></span> <span data-ttu-id="ef0cb-162">這應該會更快，因為不會執行身分識別解析，而且實體不會基於變更追蹤的用途進行快照。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-162">This should be faster, since identity resolution isn't performed, and the entities aren't snapshotted for the purposes of change tracking.</span></span>
* <span data-ttu-id="ef0cb-163">藉由只投射排名來避免載入整個 Blog 實體實例。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-163">Avoid loading the entire Blog entity instances at all, by projecting out the ranking only.</span></span> <span data-ttu-id="ef0cb-164">會讓我們無法傳輸其他不必要的 Blog 資料行的 Blog 實體類型。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-164">The saves us from transferring the other, unneeded columns of the Blog entity type.</span></span>
* <span data-ttu-id="ef0cb-165">藉由使其成為查詢的一部分，計算資料庫中的平均值。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-165">Calculate the average in the database by making it part of the query.</span></span> <span data-ttu-id="ef0cb-166">這應該是最快的方式，因為所有專案都會在資料庫中計算出來，而且只會將結果傳回給用戶端。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-166">This should be the fastest way, since everything is calculated in the database and only the result is transferred back to the client.</span></span>

<span data-ttu-id="ef0cb-167">有了 BenchmarkDotNet，您就可以撰寫程式碼以做為簡單的方法，就像單元測試一樣，BenchmarkDotNet 會自動針對足夠的反復專案數執行每個方法，以可靠的方式測量花費的時間，以及配置多少記憶體。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-167">With BenchmarkDotNet, you write the code to be benchmarked as a simple method - just like a unit test - and BenchmarkDotNet automatically runs each method for sufficient number of iterations, reliably measuring how long it takes and how much memory is allocated.</span></span> <span data-ttu-id="ef0cb-168">以下是不同的方法 ([完整的基準測試程式碼可以在這裡看到](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs)) ：</span><span class="sxs-lookup"><span data-stu-id="ef0cb-168">Here are the different method ([the full benchmark code can be seen here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs)):</span></span>

### <a name="load-entities"></a>[<span data-ttu-id="ef0cb-169">載入實體</span><span class="sxs-lookup"><span data-stu-id="ef0cb-169">Load entities</span></span>](#tab/load-entities)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=LoadEntities)]

### <a name="load-entities-no-tracking"></a>[<span data-ttu-id="ef0cb-170">載入實體，不追蹤</span><span class="sxs-lookup"><span data-stu-id="ef0cb-170">Load entities, no tracking</span></span>](#tab/load-entities-no-tracking)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=LoadEntitiesNoTracking)]

### <a name="project-only-ranking"></a>[<span data-ttu-id="ef0cb-171">僅限專案排名</span><span class="sxs-lookup"><span data-stu-id="ef0cb-171">Project only ranking</span></span>](#tab/project-only-ranking)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=ProjectOnlyRanking)]

### <a name="calculate-in-database"></a>[<span data-ttu-id="ef0cb-172">在資料庫中計算</span><span class="sxs-lookup"><span data-stu-id="ef0cb-172">Calculate in database</span></span>](#tab/calculate-in-database)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=CalculateInDatabase)]

***

<span data-ttu-id="ef0cb-173">以下是 BenchmarkDotNet 所列印的結果：</span><span class="sxs-lookup"><span data-stu-id="ef0cb-173">The results are below, as printed by BenchmarkDotNet:</span></span>

|                 <span data-ttu-id="ef0cb-174">方法</span><span class="sxs-lookup"><span data-stu-id="ef0cb-174">Method</span></span> |       <span data-ttu-id="ef0cb-175">平均數</span><span class="sxs-lookup"><span data-stu-id="ef0cb-175">Mean</span></span> |    <span data-ttu-id="ef0cb-176">錯誤</span><span class="sxs-lookup"><span data-stu-id="ef0cb-176">Error</span></span> |   <span data-ttu-id="ef0cb-177">StdDev</span><span class="sxs-lookup"><span data-stu-id="ef0cb-177">StdDev</span></span> |     <span data-ttu-id="ef0cb-178">Median</span><span class="sxs-lookup"><span data-stu-id="ef0cb-178">Median</span></span> | <span data-ttu-id="ef0cb-179">外觀比例</span><span class="sxs-lookup"><span data-stu-id="ef0cb-179">Ratio</span></span> | <span data-ttu-id="ef0cb-180">RatioSD</span><span class="sxs-lookup"><span data-stu-id="ef0cb-180">RatioSD</span></span> |    <span data-ttu-id="ef0cb-181">Gen 0</span><span class="sxs-lookup"><span data-stu-id="ef0cb-181">Gen 0</span></span> |   <span data-ttu-id="ef0cb-182">Gen 1</span><span class="sxs-lookup"><span data-stu-id="ef0cb-182">Gen 1</span></span> | <span data-ttu-id="ef0cb-183">Gen 2</span><span class="sxs-lookup"><span data-stu-id="ef0cb-183">Gen 2</span></span> |  <span data-ttu-id="ef0cb-184">已配置</span><span class="sxs-lookup"><span data-stu-id="ef0cb-184">Allocated</span></span> |
|----------------------- |-----------:|---------:|---------:|-----------:|------:|--------:|---------:|--------:|------:|-----------:|
|           <span data-ttu-id="ef0cb-185">LoadEntities</span><span class="sxs-lookup"><span data-stu-id="ef0cb-185">LoadEntities</span></span> | <span data-ttu-id="ef0cb-186">2860.4 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-186">2,860.4 us</span></span> | <span data-ttu-id="ef0cb-187">54.31 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-187">54.31 us</span></span> | <span data-ttu-id="ef0cb-188">93.68 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-188">93.68 us</span></span> | <span data-ttu-id="ef0cb-189">2844.5 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-189">2,844.5 us</span></span> |  <span data-ttu-id="ef0cb-190">4.55</span><span class="sxs-lookup"><span data-stu-id="ef0cb-190">4.55</span></span> |    <span data-ttu-id="ef0cb-191">0.33</span><span class="sxs-lookup"><span data-stu-id="ef0cb-191">0.33</span></span> | <span data-ttu-id="ef0cb-192">210.9375</span><span class="sxs-lookup"><span data-stu-id="ef0cb-192">210.9375</span></span> | <span data-ttu-id="ef0cb-193">70.3125</span><span class="sxs-lookup"><span data-stu-id="ef0cb-193">70.3125</span></span> |     - | <span data-ttu-id="ef0cb-194">1309.56 KB</span><span class="sxs-lookup"><span data-stu-id="ef0cb-194">1309.56 KB</span></span> |
| <span data-ttu-id="ef0cb-195">LoadEntitiesNoTracking</span><span class="sxs-lookup"><span data-stu-id="ef0cb-195">LoadEntitiesNoTracking</span></span> | <span data-ttu-id="ef0cb-196">1353.0 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-196">1,353.0 us</span></span> | <span data-ttu-id="ef0cb-197">21.26 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-197">21.26 us</span></span> | <span data-ttu-id="ef0cb-198">18.85 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-198">18.85 us</span></span> | <span data-ttu-id="ef0cb-199">1355.6 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-199">1,355.6 us</span></span> |  <span data-ttu-id="ef0cb-200">2.10</span><span class="sxs-lookup"><span data-stu-id="ef0cb-200">2.10</span></span> |    <span data-ttu-id="ef0cb-201">0.14</span><span class="sxs-lookup"><span data-stu-id="ef0cb-201">0.14</span></span> |  <span data-ttu-id="ef0cb-202">87.8906</span><span class="sxs-lookup"><span data-stu-id="ef0cb-202">87.8906</span></span> |  <span data-ttu-id="ef0cb-203">3.9063</span><span class="sxs-lookup"><span data-stu-id="ef0cb-203">3.9063</span></span> |     - |  <span data-ttu-id="ef0cb-204">540.09 KB</span><span class="sxs-lookup"><span data-stu-id="ef0cb-204">540.09 KB</span></span> |
|     <span data-ttu-id="ef0cb-205">ProjectOnlyRanking</span><span class="sxs-lookup"><span data-stu-id="ef0cb-205">ProjectOnlyRanking</span></span> |   <span data-ttu-id="ef0cb-206">910.9 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-206">910.9 us</span></span> | <span data-ttu-id="ef0cb-207">20.91 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-207">20.91 us</span></span> | <span data-ttu-id="ef0cb-208">61.65 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-208">61.65 us</span></span> |   <span data-ttu-id="ef0cb-209">892.9 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-209">892.9 us</span></span> |  <span data-ttu-id="ef0cb-210">1.46</span><span class="sxs-lookup"><span data-stu-id="ef0cb-210">1.46</span></span> |    <span data-ttu-id="ef0cb-211">0.14</span><span class="sxs-lookup"><span data-stu-id="ef0cb-211">0.14</span></span> |  <span data-ttu-id="ef0cb-212">41.0156</span><span class="sxs-lookup"><span data-stu-id="ef0cb-212">41.0156</span></span> |  <span data-ttu-id="ef0cb-213">0.9766</span><span class="sxs-lookup"><span data-stu-id="ef0cb-213">0.9766</span></span> |     - |  <span data-ttu-id="ef0cb-214">252.08 KB</span><span class="sxs-lookup"><span data-stu-id="ef0cb-214">252.08 KB</span></span> |
|    <span data-ttu-id="ef0cb-215">CalculateInDatabase</span><span class="sxs-lookup"><span data-stu-id="ef0cb-215">CalculateInDatabase</span></span> |   <span data-ttu-id="ef0cb-216">627.1 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-216">627.1 us</span></span> | <span data-ttu-id="ef0cb-217">14.58 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-217">14.58 us</span></span> | <span data-ttu-id="ef0cb-218">42.54 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-218">42.54 us</span></span> |   <span data-ttu-id="ef0cb-219">626.4 美國</span><span class="sxs-lookup"><span data-stu-id="ef0cb-219">626.4 us</span></span> |  <span data-ttu-id="ef0cb-220">1.00</span><span class="sxs-lookup"><span data-stu-id="ef0cb-220">1.00</span></span> |    <span data-ttu-id="ef0cb-221">0.00</span><span class="sxs-lookup"><span data-stu-id="ef0cb-221">0.00</span></span> |   <span data-ttu-id="ef0cb-222">4.8828</span><span class="sxs-lookup"><span data-stu-id="ef0cb-222">4.8828</span></span> |       - |     - |   <span data-ttu-id="ef0cb-223">33.27 KB</span><span class="sxs-lookup"><span data-stu-id="ef0cb-223">33.27 KB</span></span> |

> [!NOTE]
> <span data-ttu-id="ef0cb-224">當方法在方法中具現化和處置內容時，這些作業會計算基準測試，雖然嚴格來說，它們不是查詢程式的一部分。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-224">As the methods instantiate and dispose the context within the method, these operations are counted for the benchmark, although strictly speaking they are not part of the querying process.</span></span> <span data-ttu-id="ef0cb-225">如果目標是要比較兩個替代專案到另一個 (，因為內容具現化和處置是相同的) ，並為整個作業提供更全面的測量，這應該不重要。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-225">This should not matter if the goal is to compare two alternatives to one another (since the context instantiation and disposal are the same), and gives a more holistic measurement for the entire operation.</span></span>

<span data-ttu-id="ef0cb-226">BenchmarkDotNet 的其中一項限制是它會測量您所提供之方法的簡單、單一執行緒效能，因此不適合用來測量並行案例。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-226">One limitation of BenchmarkDotNet is that it measures simple, single-thread performance of the methods you provide, and is therefore not well-suited for benchmarking concurrent scenarios.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="ef0cb-227">在效能評定時，請務必確定您資料庫中的資料與生產資料類似，否則基準測試結果可能不代表生產環境中的實際效能。</span><span class="sxs-lookup"><span data-stu-id="ef0cb-227">Always make sure to have data in your database that is similar to production data when benchmarking, otherwise the benchmark results may not represent actual performance in production.</span></span>
