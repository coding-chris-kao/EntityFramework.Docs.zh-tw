---
title: 追蹤與 No-Tracking 查詢-EF Core
description: Entity Framework Core 中追蹤和無追蹤查詢的資訊
author: smitpatel
ms.date: 11/09/2020
uid: core/querying/tracking
ms.openlocfilehash: a96ed4ebe12446d5d69fdf58046cade0aec6294d
ms.sourcegitcommit: 4798ab8d04c1fdbe6dd204d94d770fcbf309d09b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/11/2021
ms.locfileid: "103023623"
---
# <a name="tracking-vs-no-tracking-queries"></a><span data-ttu-id="a0134-103">追蹤與 No-Tracking 的查詢</span><span class="sxs-lookup"><span data-stu-id="a0134-103">Tracking vs. No-Tracking Queries</span></span>

<span data-ttu-id="a0134-104">追蹤行為會控制 Entity Framework Core 是否會在其變更追蹤程式中保留實體實例的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="a0134-104">Tracking behavior controls if Entity Framework Core will keep information about an entity instance in its change tracker.</span></span> <span data-ttu-id="a0134-105">如果追蹤實體，即會在 `SaveChanges()` 期間，將實體中偵測到的任何變更保存於資料庫。</span><span class="sxs-lookup"><span data-stu-id="a0134-105">If an entity is tracked, any changes detected in the entity will be persisted to the database during `SaveChanges()`.</span></span> <span data-ttu-id="a0134-106">EF Core 也會修正追蹤查詢結果中的實體與變更追蹤器中的實體之間的導覽屬性。</span><span class="sxs-lookup"><span data-stu-id="a0134-106">EF Core will also fix up navigation properties between the entities in a tracking query result and the entities that are in the change tracker.</span></span>

> [!NOTE]
> <span data-ttu-id="a0134-107">永遠不會追蹤[無索引鍵的實體類型](xref:core/modeling/keyless-entity-types)。</span><span class="sxs-lookup"><span data-stu-id="a0134-107">[Keyless entity types](xref:core/modeling/keyless-entity-types) are never tracked.</span></span> <span data-ttu-id="a0134-108">本文提及實體類型時，是指已定義索引鍵的實體類型。</span><span class="sxs-lookup"><span data-stu-id="a0134-108">Wherever this article mentions entity types, it refers to entity types which have a key defined.</span></span>

> [!TIP]
> <span data-ttu-id="a0134-109">您可以在 GitHub 上檢視此文章的[範例](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Querying/Tracking) \(英文\)。</span><span class="sxs-lookup"><span data-stu-id="a0134-109">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Querying/Tracking) on GitHub.</span></span>

## <a name="tracking-queries"></a><span data-ttu-id="a0134-110">追蹤查詢</span><span class="sxs-lookup"><span data-stu-id="a0134-110">Tracking queries</span></span>

<span data-ttu-id="a0134-111">預設會追蹤傳回實體類型的查詢。</span><span class="sxs-lookup"><span data-stu-id="a0134-111">By default, queries that return entity types are tracking.</span></span> <span data-ttu-id="a0134-112">這表示您可以變更這些實體實例，並讓這些變更持續進行 `SaveChanges()` 。</span><span class="sxs-lookup"><span data-stu-id="a0134-112">Which means you can make changes to those entity instances and have those changes persisted by `SaveChanges()`.</span></span> <span data-ttu-id="a0134-113">在下列範例中，將會偵測到對部落格評等的變更，並在 `SaveChanges()` 期間將其保存於資料庫。</span><span class="sxs-lookup"><span data-stu-id="a0134-113">In the following example, the change to the blogs rating will be detected and persisted to the database during `SaveChanges()`.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#Tracking)]

<span data-ttu-id="a0134-114">當追蹤查詢傳回結果時，EF Core 會檢查實體是否已存在於內容中。</span><span class="sxs-lookup"><span data-stu-id="a0134-114">When the results are returned in a tracking query, EF Core will check if the entity is already in the context.</span></span> <span data-ttu-id="a0134-115">如果 EF Core 找到現有的實體，則會傳回相同的實例。</span><span class="sxs-lookup"><span data-stu-id="a0134-115">If EF Core finds an existing entity, then the same instance is returned.</span></span> <span data-ttu-id="a0134-116">EF Core 不會以資料庫值覆寫專案中實體屬性的目前值和原始值。</span><span class="sxs-lookup"><span data-stu-id="a0134-116">EF Core won't overwrite current and original values of the entity's properties in the entry with the database values.</span></span> <span data-ttu-id="a0134-117">如果在內容中找不到實體，則 EF Core 會建立新的實體實例，並將它附加至內容。</span><span class="sxs-lookup"><span data-stu-id="a0134-117">If the entity isn't found in the context, then EF Core will create a new entity instance and attach it to the context.</span></span> <span data-ttu-id="a0134-118">查詢結果不包含任何加入至內容的實體，但尚未儲存至資料庫。</span><span class="sxs-lookup"><span data-stu-id="a0134-118">Query results don't contain any entity, which is added to the context but not yet saved to the database.</span></span>

## <a name="no-tracking-queries"></a><span data-ttu-id="a0134-119">無追蹤查詢</span><span class="sxs-lookup"><span data-stu-id="a0134-119">No-tracking queries</span></span>

<span data-ttu-id="a0134-120">如果要在唯讀案例中使用結果，則不追蹤的查詢很實用。</span><span class="sxs-lookup"><span data-stu-id="a0134-120">No tracking queries are useful when the results are used in a read-only scenario.</span></span> <span data-ttu-id="a0134-121">執行速度較快，因為不需要設定變更追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="a0134-121">They're quicker to execute because there's no need to set up the change tracking information.</span></span> <span data-ttu-id="a0134-122">如果您不需要更新從資料庫取出的實體，則應該使用無追蹤查詢。</span><span class="sxs-lookup"><span data-stu-id="a0134-122">If you don't need to update the entities retrieved from the database, then a no-tracking query should be used.</span></span> <span data-ttu-id="a0134-123">您可以將個別查詢交換為不追蹤。</span><span class="sxs-lookup"><span data-stu-id="a0134-123">You can swap an individual query to be no-tracking.</span></span> <span data-ttu-id="a0134-124">沒有任何追蹤查詢也會根據資料庫中會忽略任何本機變更或新增實體的結果提供結果。</span><span class="sxs-lookup"><span data-stu-id="a0134-124">No tracking query will also give you results based on what is in the database disregarding any local changes or added entities.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTracking)]

<span data-ttu-id="a0134-125">您也可以在內容執行個體層級變更預設的追蹤行為：</span><span class="sxs-lookup"><span data-stu-id="a0134-125">You can also change the default tracking behavior at the context instance level:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ContextDefaultTrackingBehavior)]

## <a name="identity-resolution"></a><span data-ttu-id="a0134-126">身分識別解析</span><span class="sxs-lookup"><span data-stu-id="a0134-126">Identity resolution</span></span>

<span data-ttu-id="a0134-127">由於追蹤查詢會使用變更追蹤器，因此 EF Core 會在追蹤查詢中進行識別解析。</span><span class="sxs-lookup"><span data-stu-id="a0134-127">Since a tracking query uses the change tracker, EF Core will do identity resolution in a tracking query.</span></span> <span data-ttu-id="a0134-128">具體化實體時，如果已追蹤，EF Core 將會從變更追蹤器傳回相同的實體實例。</span><span class="sxs-lookup"><span data-stu-id="a0134-128">When materializing an entity, EF Core will return the same entity instance from the change tracker if it's already being tracked.</span></span> <span data-ttu-id="a0134-129">如果結果多次包含相同的實體，您就會在每次發生時取回相同的實例。</span><span class="sxs-lookup"><span data-stu-id="a0134-129">If the result contains the same entity multiple times, you get back same instance for each occurrence.</span></span> <span data-ttu-id="a0134-130">無追蹤查詢不會使用變更追蹤器，也不會進行識別解析。</span><span class="sxs-lookup"><span data-stu-id="a0134-130">No-tracking queries don't use the change tracker and don't do identity resolution.</span></span> <span data-ttu-id="a0134-131">因此，即使相同的實體包含在結果中多次，您仍會取回實體的新實例。</span><span class="sxs-lookup"><span data-stu-id="a0134-131">So you get back a new instance of the entity even when the same entity is contained in the result multiple times.</span></span> <span data-ttu-id="a0134-132">在 EF Core 3.0 之前的版本中，這個行為不同，請參閱 [先前的版本](#previous-versions)。</span><span class="sxs-lookup"><span data-stu-id="a0134-132">This behavior was different in versions before EF Core 3.0, see [previous versions](#previous-versions).</span></span>

<span data-ttu-id="a0134-133">從 EF Core 5.0 開始，您可以在相同的查詢中結合上述兩個行為。</span><span class="sxs-lookup"><span data-stu-id="a0134-133">Starting with EF Core 5.0, you can combine both of the above behaviors in same query.</span></span> <span data-ttu-id="a0134-134">也就是說，您可以有沒有追蹤查詢，這會在結果中進行識別解析。</span><span class="sxs-lookup"><span data-stu-id="a0134-134">That is, you can have a no tracking query, which will do identity resolution in the results.</span></span> <span data-ttu-id="a0134-135">就像可 `AsNoTracking()` 查詢的運算子一樣，我們也新增了另一個運算子 `AsNoTrackingWithIdentityResolution()` 。</span><span class="sxs-lookup"><span data-stu-id="a0134-135">Just like `AsNoTracking()` queryable operator, we've added another operator `AsNoTrackingWithIdentityResolution()`.</span></span> <span data-ttu-id="a0134-136">列舉中也加入了相關聯的專案 <xref:Microsoft.EntityFrameworkCore.QueryTrackingBehavior> 。</span><span class="sxs-lookup"><span data-stu-id="a0134-136">There's also associated entry added in the <xref:Microsoft.EntityFrameworkCore.QueryTrackingBehavior> enum.</span></span> <span data-ttu-id="a0134-137">當您將查詢設定為使用沒有追蹤的身分識別解析時，我們會在產生查詢結果時，于背景使用獨立的變更追蹤器，因此每個實例僅具體化一次。</span><span class="sxs-lookup"><span data-stu-id="a0134-137">When you configure the query to use identity resolution with no tracking, we use a stand-alone change tracker in the background when generating query results so each instance is materialized only once.</span></span> <span data-ttu-id="a0134-138">因為這項變更追蹤器與內容中的追蹤程式不同，所以內容不會追蹤結果。</span><span class="sxs-lookup"><span data-stu-id="a0134-138">Since this change tracker is different from the one in the context, the results are not tracked by the context.</span></span> <span data-ttu-id="a0134-139">完整列舉查詢之後，變更追蹤器就會超出範圍，並視需要進行垃圾收集。</span><span class="sxs-lookup"><span data-stu-id="a0134-139">After the query is enumerated fully, the change tracker goes out of scope and garbage collected as required.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTrackingWithIdentityResolution)]

## <a name="tracking-and-custom-projections"></a><span data-ttu-id="a0134-140">追蹤和自訂投影</span><span class="sxs-lookup"><span data-stu-id="a0134-140">Tracking and custom projections</span></span>

<span data-ttu-id="a0134-141">即使查詢的結果類型不是實體類型，EF Core 仍會依預設追蹤包含在結果中的實體類型。</span><span class="sxs-lookup"><span data-stu-id="a0134-141">Even if the result type of the query isn't an entity type, EF Core will still track entity types contained in the result by default.</span></span> <span data-ttu-id="a0134-142">下列查詢會傳回匿名類型，並且將在結果集中追蹤 `Blog` 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a0134-142">In the following query, which returns an anonymous type, the instances of `Blog` in the result set will be tracked.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection1)]

<span data-ttu-id="a0134-143">如果結果集包含來自 LINQ 組合的實體類型，則 EF Core 會追蹤這些型別。</span><span class="sxs-lookup"><span data-stu-id="a0134-143">If the result set contains entity types coming out from LINQ composition, EF Core will track them.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

<span data-ttu-id="a0134-144">如果結果集未包含任何實體類型，則不會進行追蹤。</span><span class="sxs-lookup"><span data-stu-id="a0134-144">If the result set doesn't contain any entity types, then no tracking is done.</span></span> <span data-ttu-id="a0134-145">在下列查詢中，我們會從實體 (傳回具有某些值的匿名型別，但不會) 實際實體類型的實例。</span><span class="sxs-lookup"><span data-stu-id="a0134-145">In the following query, we return an anonymous type with some of the values from the entity (but no instances of the actual entity type).</span></span> <span data-ttu-id="a0134-146">查詢沒有任何追蹤的實體。</span><span class="sxs-lookup"><span data-stu-id="a0134-146">There are no tracked entities coming out of the query.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection3)]

 <span data-ttu-id="a0134-147">EF Core 支援在最上層投影中進行用戶端評估。</span><span class="sxs-lookup"><span data-stu-id="a0134-147">EF Core supports doing client evaluation in the top-level projection.</span></span> <span data-ttu-id="a0134-148">如果 EF Core 具體化實體實例以進行用戶端評估，則會進行追蹤。</span><span class="sxs-lookup"><span data-stu-id="a0134-148">If EF Core materializes an entity instance for client evaluation, it will be tracked.</span></span> <span data-ttu-id="a0134-149">在這裡，因為我們 `blog` 要將實體傳遞給用戶端方法 `StandardizeURL` ，所以 EF Core 也會追蹤 blog 實例。</span><span class="sxs-lookup"><span data-stu-id="a0134-149">Here, since we're passing `blog` entities to the client method `StandardizeURL`, EF Core will track the blog instances too.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientMethod)]

<span data-ttu-id="a0134-150">EF Core 不會追蹤結果中包含的無索引鍵實體實例。</span><span class="sxs-lookup"><span data-stu-id="a0134-150">EF Core doesn't track the keyless entity instances contained in the result.</span></span> <span data-ttu-id="a0134-151">但 EF Core 會根據上述規則，追蹤實體類型的所有其他實例和索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a0134-151">But EF Core tracks all the other instances of entity types with a key according to rules above.</span></span>

<span data-ttu-id="a0134-152">上述一些規則在 EF Core 3.0 之前的運作方式不同。</span><span class="sxs-lookup"><span data-stu-id="a0134-152">Some of the above rules worked differently before EF Core 3.0.</span></span> <span data-ttu-id="a0134-153">如需詳細資訊，請參閱 [先前的版本](#previous-versions)。</span><span class="sxs-lookup"><span data-stu-id="a0134-153">For more information, see [previous versions](#previous-versions).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="a0134-154">舊版</span><span class="sxs-lookup"><span data-stu-id="a0134-154">Previous versions</span></span>

<span data-ttu-id="a0134-155">在3.0 版之前，EF Core 在追蹤的完成方式上有一些差異。</span><span class="sxs-lookup"><span data-stu-id="a0134-155">Before version 3.0, EF Core had some differences in how tracking was done.</span></span> <span data-ttu-id="a0134-156">值得注意的差異如下：</span><span class="sxs-lookup"><span data-stu-id="a0134-156">Notable differences are as follows:</span></span>

- <span data-ttu-id="a0134-157">如 [ [用戶端與伺服器評估](xref:core/querying/client-eval) ] 頁面中所述，在3.0 版之前的查詢的任何部分中，EF Core 支援用戶端評估。</span><span class="sxs-lookup"><span data-stu-id="a0134-157">As explained in the [Client vs Server Evaluation](xref:core/querying/client-eval) page, EF Core supported client evaluation in any part of the query before version 3.0.</span></span> <span data-ttu-id="a0134-158">用戶端評估會造成實體具體化，而不是結果的一部分。</span><span class="sxs-lookup"><span data-stu-id="a0134-158">Client evaluation caused materialization of entities, which weren't part of the result.</span></span> <span data-ttu-id="a0134-159">因此 EF Core 會分析結果來偵測要追蹤的內容。此設計有一些差異，如下所示：</span><span class="sxs-lookup"><span data-stu-id="a0134-159">So EF Core analyzed the result to detect what to track. This design had certain differences as follows:</span></span>
  - <span data-ttu-id="a0134-160">投射中的用戶端評估，這會造成具體化但未傳回具體化實體實例。</span><span class="sxs-lookup"><span data-stu-id="a0134-160">Client evaluation in the projection, which caused materialization but didn't return the materialized entity instance wasn't tracked.</span></span> <span data-ttu-id="a0134-161">下列範例不會追蹤 `blog` 實體。</span><span class="sxs-lookup"><span data-stu-id="a0134-161">The following example didn't track `blog` entities.</span></span>
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

  - <span data-ttu-id="a0134-162">在某些情況下，EF Core 不會追蹤 LINQ 組合所推出的物件。</span><span class="sxs-lookup"><span data-stu-id="a0134-162">EF Core didn't track the objects coming out of LINQ composition in certain cases.</span></span> <span data-ttu-id="a0134-163">下列範例沒有追蹤 `Post` 。</span><span class="sxs-lookup"><span data-stu-id="a0134-163">The following example didn't track `Post`.</span></span>
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

- <span data-ttu-id="a0134-164">每當查詢結果包含無索引鍵的實體類型時，就會進行整個查詢進行非追蹤。</span><span class="sxs-lookup"><span data-stu-id="a0134-164">Whenever query results contained keyless entity types, the whole query was made non-tracking.</span></span> <span data-ttu-id="a0134-165">這表示不會追蹤結果中有索引鍵的實體類型。</span><span class="sxs-lookup"><span data-stu-id="a0134-165">That means that entity types with keys, which are in the result weren't being tracked either.</span></span>
- <span data-ttu-id="a0134-166">EF Core 用來在無追蹤查詢中進行識別解析。</span><span class="sxs-lookup"><span data-stu-id="a0134-166">EF Core used to do identity resolution in no-tracking queries.</span></span> <span data-ttu-id="a0134-167">它使用弱式參考來追蹤已經傳回的實體。</span><span class="sxs-lookup"><span data-stu-id="a0134-167">It used weak references to keep track of entities that had already been returned.</span></span> <span data-ttu-id="a0134-168">因此，如果結果集包含相同的實體多次，則每次出現時，您都會取得相同的實例。</span><span class="sxs-lookup"><span data-stu-id="a0134-168">So if a result set contained the same entity multiples times, you would get the same instance for each occurrence.</span></span> <span data-ttu-id="a0134-169">雖然先前具有相同身分識別的結果超出範圍，且已進行垃圾收集，但 EF Core 會傳回新的實例。</span><span class="sxs-lookup"><span data-stu-id="a0134-169">Though if a previous result with the same identity went out of scope and got garbage collected, EF Core returned a new instance.</span></span>
