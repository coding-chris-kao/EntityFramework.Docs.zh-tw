---
title: 客戶端與伺服器評估 - EF 核心
author: smitpatel
ms.date: 10/03/2019
ms.assetid: 8b6697cc-7067-4dc2-8007-85d80503d123
uid: core/querying/client-eval
ms.openlocfilehash: e01bd146c4dfe7a8d36b641cb52ae366fddd8239
ms.sourcegitcommit: 9b562663679854c37c05fca13d93e180213fb4aa
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/07/2020
ms.locfileid: "78417757"
---
# <a name="client-vs-server-evaluation"></a><span data-ttu-id="6170c-102">用戶端與伺服器評估</span><span class="sxs-lookup"><span data-stu-id="6170c-102">Client vs. Server Evaluation</span></span>

<span data-ttu-id="6170c-103">通常,實體框架核心嘗試盡可能評估伺服器上的查詢。</span><span class="sxs-lookup"><span data-stu-id="6170c-103">As a general rule, Entity Framework Core attempts to evaluate a query on the server as much as possible.</span></span> <span data-ttu-id="6170c-104">EF Core 將查詢的某些部分轉換為參數,可以在用戶端上對其進行計算。</span><span class="sxs-lookup"><span data-stu-id="6170c-104">EF Core converts parts of the query into parameters, which it can evaluate on the client side.</span></span> <span data-ttu-id="6170c-105">查詢的其餘部分(以及生成的參數)將提供給資料庫提供者,以確定要在伺服器上評估的等效資料庫查詢。</span><span class="sxs-lookup"><span data-stu-id="6170c-105">The rest of the query (along with the generated parameters) is given to the database provider to determine the equivalent database query to evaluate on the server.</span></span> <span data-ttu-id="6170c-106">EF Core 支持頂級投影中的部分客戶端評估(實質上是最後一`Select()`次調用 )。</span><span class="sxs-lookup"><span data-stu-id="6170c-106">EF Core supports partial client evaluation in the top-level projection (essentially, the last call to `Select()`).</span></span> <span data-ttu-id="6170c-107">如果查詢中的頂級投影無法轉換為伺服器,EF Core 將從伺服器獲取任何必需的數據,並計算用戶端上查詢的剩餘部分。</span><span class="sxs-lookup"><span data-stu-id="6170c-107">If the top-level projection in the query can't be translated to the server, EF Core will fetch any required data from the server and evaluate remaining parts of the query on the client.</span></span> <span data-ttu-id="6170c-108">如果 EF Core 在頂級投影以外的任何位置檢測到運算式,無法轉換為伺服器,則將引發運行時異常。</span><span class="sxs-lookup"><span data-stu-id="6170c-108">If EF Core detects an expression, in any place other than the top-level projection, which can't be translated to the server, then it throws a runtime exception.</span></span> <span data-ttu-id="6170c-109">瞭解[查詢的工作原理](xref:core/querying/how-query-works),以瞭解 EF Core 如何確定無法轉換為伺服器的內容。</span><span class="sxs-lookup"><span data-stu-id="6170c-109">See [how query works](xref:core/querying/how-query-works) to understand how EF Core determines what can't be translated to server.</span></span>

> [!NOTE]
> <span data-ttu-id="6170c-110">在版本 3.0 之前,實體框架核心支援查詢中的任何位置的客戶端評估。</span><span class="sxs-lookup"><span data-stu-id="6170c-110">Prior to version 3.0, Entity Framework Core supported client evaluation anywhere in the query.</span></span> <span data-ttu-id="6170c-111">有關詳細資訊,請參閱[以前的版本部分](#previous-versions)。</span><span class="sxs-lookup"><span data-stu-id="6170c-111">For more information, see the [previous versions section](#previous-versions).</span></span>

> [!TIP]
> <span data-ttu-id="6170c-112">您可以在 GitHub 上查看本文[的範例](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying)。</span><span class="sxs-lookup"><span data-stu-id="6170c-112">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) on GitHub.</span></span>

## <a name="client-evaluation-in-the-top-level-projection"></a><span data-ttu-id="6170c-113">頂級投影中的客戶端評估</span><span class="sxs-lookup"><span data-stu-id="6170c-113">Client evaluation in the top-level projection</span></span>

<span data-ttu-id="6170c-114">在下面的示例中,説明器方法用於標準化博客的 URL,這些 URL 是從 SQL Server 資料庫返回的。</span><span class="sxs-lookup"><span data-stu-id="6170c-114">In the following example, a helper method is used to standardize URLs for blogs, which are returned from a SQL Server database.</span></span> <span data-ttu-id="6170c-115">由於 SQL Server 提供程式無法深入瞭解此方法的實現方式,因此無法將其轉換為 SQL。</span><span class="sxs-lookup"><span data-stu-id="6170c-115">Since the SQL Server provider has no insight into how this method is implemented, it isn't possible to translate it into SQL.</span></span> <span data-ttu-id="6170c-116">查詢的所有其他方面都在資料庫中計算,但通過此方法傳遞返回`URL`的是在用戶端上完成的。</span><span class="sxs-lookup"><span data-stu-id="6170c-116">All other aspects of the query are evaluated in the database, but passing the returned `URL` through this method is done on the client.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientMethod)]

## <a name="unsupported-client-evaluation"></a><span data-ttu-id="6170c-117">不支援的客戶端評估</span><span class="sxs-lookup"><span data-stu-id="6170c-117">Unsupported client evaluation</span></span>

<span data-ttu-id="6170c-118">雖然客戶端評估很有用,但有時可能會導致性能不佳。</span><span class="sxs-lookup"><span data-stu-id="6170c-118">While client evaluation is useful, it can result in poor performance sometimes.</span></span> <span data-ttu-id="6170c-119">請考慮以下查詢,其中幫助器方法現在用於 where 篩選器。</span><span class="sxs-lookup"><span data-stu-id="6170c-119">Consider the following query, in which the helper method is now used in a where filter.</span></span> <span data-ttu-id="6170c-120">由於無法在資料庫中應用篩選器,因此需要將所有數據提取到記憶體中,才能在用戶端上應用篩選器。</span><span class="sxs-lookup"><span data-stu-id="6170c-120">Because the filter can't be applied in the database, all the data needs to be pulled into memory to apply the filter on the client.</span></span> <span data-ttu-id="6170c-121">根據篩選器和伺服器上的數據量,客戶端評估可能會導致性能不佳。</span><span class="sxs-lookup"><span data-stu-id="6170c-121">Based on the filter and the amount of data on the server, client evaluation could result in poor performance.</span></span> <span data-ttu-id="6170c-122">因此,實體框架核心阻止此類客戶端評估,並引發運行時異常。</span><span class="sxs-lookup"><span data-stu-id="6170c-122">So Entity Framework Core blocks such client evaluation and throws a runtime exception.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientWhere)]

## <a name="explicit-client-evaluation"></a><span data-ttu-id="6170c-123">明確客戶端評估</span><span class="sxs-lookup"><span data-stu-id="6170c-123">Explicit client evaluation</span></span>

<span data-ttu-id="6170c-124">在某些情況下,您可能需要顯式強制到客戶端評估中,例如:</span><span class="sxs-lookup"><span data-stu-id="6170c-124">You may need to force into client evaluation explicitly in certain cases like following</span></span>

- <span data-ttu-id="6170c-125">數據量很小,因此對客戶端進行評估不會造成巨大的性能損失。</span><span class="sxs-lookup"><span data-stu-id="6170c-125">The amount of data is small so that evaluating on the client doesn't incur a huge performance penalty.</span></span>
- <span data-ttu-id="6170c-126">正在使用的 LINQ 運算子沒有伺服器端轉換。</span><span class="sxs-lookup"><span data-stu-id="6170c-126">The LINQ operator being used has no server-side translation.</span></span>

<span data-ttu-id="6170c-127">在這種情況下,您可以通過調`AsEnumerable`用 方法`ToList`(`AsAsyncEnumerable`或`ToListAsync`(或非同步)來顯式加入加入客戶端評估。</span><span class="sxs-lookup"><span data-stu-id="6170c-127">In such cases, you can explicitly opt into client evaluation by calling methods like `AsEnumerable` or `ToList` (`AsAsyncEnumerable` or `ToListAsync` for async).</span></span> <span data-ttu-id="6170c-128">通過使用`AsEnumerable`您將流式傳輸結果,但`ToList`使用會導致通過創建清單(這也會佔用額外記憶體)進行緩衝。</span><span class="sxs-lookup"><span data-stu-id="6170c-128">By using `AsEnumerable` you would be streaming the results, but using `ToList` would cause buffering by creating a list, which also takes additional memory.</span></span> <span data-ttu-id="6170c-129">儘管要多次枚舉,但將結果存儲在清單中會很有幫助,因為資料庫只有一個查詢。</span><span class="sxs-lookup"><span data-stu-id="6170c-129">Though if you're enumerating multiple times, then storing results in a list helps more since there's only one query to the database.</span></span> <span data-ttu-id="6170c-130">根據特定的用法,您應該評估哪種方法對案例更有用。</span><span class="sxs-lookup"><span data-stu-id="6170c-130">Depending on the particular usage, you should evaluate which method is more useful for the case.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ExplicitClientEval)]

## <a name="potential-memory-leak-in-client-evaluation"></a><span data-ttu-id="6170c-131">用戶端評估中的潛在記憶體洩漏</span><span class="sxs-lookup"><span data-stu-id="6170c-131">Potential memory leak in client evaluation</span></span>

<span data-ttu-id="6170c-132">由於查詢轉換和編譯成本高昂,EF Core 緩存已編譯的查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="6170c-132">Since query translation and compilation are expensive, EF Core caches the compiled query plan.</span></span> <span data-ttu-id="6170c-133">緩存的委託在進行頂級投影的客戶端評估時可以使用客戶端代碼。</span><span class="sxs-lookup"><span data-stu-id="6170c-133">The cached delegate may use client code while doing client evaluation of top-level projection.</span></span> <span data-ttu-id="6170c-134">EF Core 為樹的客戶端評估部分生成參數,並通過替換參數值來重用查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="6170c-134">EF Core generates parameters for the client-evaluated parts of the tree and reuses the query plan by replacing the parameter values.</span></span> <span data-ttu-id="6170c-135">但是表達式樹中的某些常量不能轉換為參數。</span><span class="sxs-lookup"><span data-stu-id="6170c-135">But certain constants in the expression tree can't be converted into parameters.</span></span> <span data-ttu-id="6170c-136">如果緩存的委託包含此類常量,則無法回收這些對象,因為它們仍在被引用。</span><span class="sxs-lookup"><span data-stu-id="6170c-136">If the cached delegate contains such constants, then those objects can't be garbage collected since they're still being referenced.</span></span> <span data-ttu-id="6170c-137">如果此類物件包含 DbContext 或其他服務,則可能導致應用的記憶體使用量隨時間而增長。</span><span class="sxs-lookup"><span data-stu-id="6170c-137">If such an object contains a DbContext or other services in it, then it could cause the memory usage of the app to grow over time.</span></span> <span data-ttu-id="6170c-138">此行為通常是記憶體洩漏的跡象。</span><span class="sxs-lookup"><span data-stu-id="6170c-138">This behavior is generally a sign of a memory leak.</span></span> <span data-ttu-id="6170c-139">每當發生無法使用當前資料庫提供程式映射的類型常量時,EF Core 都會引發異常。</span><span class="sxs-lookup"><span data-stu-id="6170c-139">EF Core throws an exception whenever it comes across constants of a type that can't be mapped using current database provider.</span></span> <span data-ttu-id="6170c-140">常見原因及其解決方案如下:</span><span class="sxs-lookup"><span data-stu-id="6170c-140">Common causes and their solutions are as follows:</span></span>

- <span data-ttu-id="6170c-141">**在**用戶端投影中使用實例方法時,表達式樹包含實例的常量。</span><span class="sxs-lookup"><span data-stu-id="6170c-141">**Using an instance method**: When using instance methods in a client projection, the expression tree contains a constant of the instance.</span></span> <span data-ttu-id="6170c-142">如果方法不使用實例中的任何數據,請考慮使該方法成為靜態方法。</span><span class="sxs-lookup"><span data-stu-id="6170c-142">If your method doesn't use any data from the instance, consider making the method static.</span></span> <span data-ttu-id="6170c-143">如果需要方法體中的實例數據,則將特定數據作為參數傳遞給方法。</span><span class="sxs-lookup"><span data-stu-id="6170c-143">If you need instance data in the method body, then pass the specific data as an argument to the method.</span></span>
- <span data-ttu-id="6170c-144">**將常量參數傳遞給方法**:這種情況通常通過在參數`this`中使用到用戶端方法而出現。</span><span class="sxs-lookup"><span data-stu-id="6170c-144">**Passing constant arguments to method**: This case arises generally by using `this` in an argument to client method.</span></span> <span data-ttu-id="6170c-145">請考慮將參數拆分為多個標量參數,該參數可以由資料庫提供程式映射。</span><span class="sxs-lookup"><span data-stu-id="6170c-145">Consider splitting the argument in to multiple scalar arguments, which can be mapped by the database provider.</span></span>
- <span data-ttu-id="6170c-146">**其他常量**:如果遇到任何其他情況下的常量,則可以評估處理中是否需要常量。</span><span class="sxs-lookup"><span data-stu-id="6170c-146">**Other constants**: If a constant is come across in any other case, then you can evaluate whether the constant is needed in processing.</span></span> <span data-ttu-id="6170c-147">如果需要具有常量,或者無法使用上述情況下的解決方案,則創建一個局部變數來存儲值並在查詢中使用局部變數。</span><span class="sxs-lookup"><span data-stu-id="6170c-147">If it's necessary to have the constant, or if you can't use a solution from the above cases, then create a local variable to store the value and use local variable in the query.</span></span> <span data-ttu-id="6170c-148">EF Core 將本地變數轉換為參數。</span><span class="sxs-lookup"><span data-stu-id="6170c-148">EF Core will convert the local variable into a parameter.</span></span>

## <a name="previous-versions"></a><span data-ttu-id="6170c-149">舊版本</span><span class="sxs-lookup"><span data-stu-id="6170c-149">Previous versions</span></span>

<span data-ttu-id="6170c-150">以下部分適用於 3.0 之前的 EF Core 版本。</span><span class="sxs-lookup"><span data-stu-id="6170c-150">The following section applies to EF Core versions before 3.0.</span></span>

<span data-ttu-id="6170c-151">較舊的 EF Core 版本支援查詢的任何部分的客戶端評估,而不僅僅是頂級投影。</span><span class="sxs-lookup"><span data-stu-id="6170c-151">Older EF Core versions supported client evaluation in any part of the query--not just the top-level projection.</span></span> <span data-ttu-id="6170c-152">這就是為什麼與[「不支援的客戶端評估](#unsupported-client-evaluation)」部分下發佈的查詢類似的查詢工作正常的原因。</span><span class="sxs-lookup"><span data-stu-id="6170c-152">That's why queries similar to one posted under the [Unsupported client evaluation](#unsupported-client-evaluation) section worked correctly.</span></span> <span data-ttu-id="6170c-153">由於此行為可能導致未注意的性能問題,EF Core 記錄了客戶端評估警告。</span><span class="sxs-lookup"><span data-stu-id="6170c-153">Since this behavior could cause unnoticed performance issues, EF Core logged a client evaluation warning.</span></span> <span data-ttu-id="6170c-154">有關檢視紀錄紀錄輸出的詳細資訊,請參閱[紀錄紀錄](xref:core/miscellaneous/logging)。</span><span class="sxs-lookup"><span data-stu-id="6170c-154">For more information on viewing logging output, see [Logging](xref:core/miscellaneous/logging).</span></span>

<span data-ttu-id="6170c-155">可選,EF Core 允許您更改預設行為,以在執行客戶端評估時引發異常或不執行任何操作(投影中除外)。</span><span class="sxs-lookup"><span data-stu-id="6170c-155">Optionally EF Core allowed you to change the default behavior to either throw an exception or do nothing when doing client evaluation (except for in the projection).</span></span> <span data-ttu-id="6170c-156">異常引發行為將使其類似於 3.0 中的行為。</span><span class="sxs-lookup"><span data-stu-id="6170c-156">The exception throwing behavior would make it similar to the behavior in 3.0.</span></span> <span data-ttu-id="6170c-157">要更改行為,您需要在設置上下文選項時配置警告 - 通常`DbContext.OnConfiguring`在中`Startup.cs`,或者在中使用 ASP.NET 酷睿時。</span><span class="sxs-lookup"><span data-stu-id="6170c-157">To change the behavior, you need to configure warnings while setting up the options for your context - typically in `DbContext.OnConfiguring`, or in `Startup.cs` if you're using ASP.NET Core.</span></span>

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=EFQuerying;Trusted_Connection=True;")
        .ConfigureWarnings(warnings => warnings.Throw(RelationalEventId.QueryClientEvaluationWarning));
}
```
