---
title: 用戶端與伺服器的評估-EF Core
description: 使用 Entity Framework Core 進行查詢的用戶端和伺服器評估
author: smitpatel
ms.date: 11/09/2020
uid: core/querying/client-eval
ms.openlocfilehash: a1ddfb625be36cb05f01da08eb3be29512c54ab5
ms.sourcegitcommit: f3512e3a98e685a3ba409c1d0157ce85cc390cf4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/10/2020
ms.locfileid: "94430140"
---
# <a name="client-vs-server-evaluation"></a><span data-ttu-id="9cf37-103">用戶端與伺服器評估</span><span class="sxs-lookup"><span data-stu-id="9cf37-103">Client vs. Server Evaluation</span></span>

<span data-ttu-id="9cf37-104">一般來說，Entity Framework Core 會嘗試在伺服器上盡可能評估查詢。</span><span class="sxs-lookup"><span data-stu-id="9cf37-104">As a general rule, Entity Framework Core attempts to evaluate a query on the server as much as possible.</span></span> <span data-ttu-id="9cf37-105">EF Core 會將查詢的部分轉換成可在用戶端上評估的參數。</span><span class="sxs-lookup"><span data-stu-id="9cf37-105">EF Core converts parts of the query into parameters, which it can evaluate on the client side.</span></span> <span data-ttu-id="9cf37-106">查詢的其餘部分 (以及產生的參數) 會提供給資料庫提供者，以判斷要在伺服器上評估的對等資料庫查詢。</span><span class="sxs-lookup"><span data-stu-id="9cf37-106">The rest of the query (along with the generated parameters) is given to the database provider to determine the equivalent database query to evaluate on the server.</span></span> <span data-ttu-id="9cf37-107">EF Core 支援最上層投影 (的部分用戶端評估，基本上是最後一個對) 的呼叫 `Select()` 。</span><span class="sxs-lookup"><span data-stu-id="9cf37-107">EF Core supports partial client evaluation in the top-level projection (essentially, the last call to `Select()`).</span></span> <span data-ttu-id="9cf37-108">如果查詢中的最上層投影無法轉譯為伺服器，EF Core 將會從伺服器提取所有必要的資料，並在用戶端上評估查詢的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="9cf37-108">If the top-level projection in the query can't be translated to the server, EF Core will fetch any required data from the server and evaluate remaining parts of the query on the client.</span></span> <span data-ttu-id="9cf37-109">如果 EF Core 在無法轉譯為伺服器的最上層投影以外的任何地方偵測到運算式，則會擲回執行時間例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9cf37-109">If EF Core detects an expression, in any place other than the top-level projection, which can't be translated to the server, then it throws a runtime exception.</span></span> <span data-ttu-id="9cf37-110">查看 [查詢的運作方式](xref:core/querying/how-query-works) ，瞭解 EF Core 如何判斷無法轉譯至伺服器的內容。</span><span class="sxs-lookup"><span data-stu-id="9cf37-110">See [How queries work](xref:core/querying/how-query-works) to understand how EF Core determines what can't be translated to server.</span></span>

> [!NOTE]
> <span data-ttu-id="9cf37-111">在3.0 版之前，請在查詢中的任何位置 Entity Framework Core 支援的用戶端評估。</span><span class="sxs-lookup"><span data-stu-id="9cf37-111">Prior to version 3.0, Entity Framework Core supported client evaluation anywhere in the query.</span></span> <span data-ttu-id="9cf37-112">如需詳細資訊，請參閱「 [先前的版本」一節](#previous-versions)。</span><span class="sxs-lookup"><span data-stu-id="9cf37-112">For more information, see the [previous versions section](#previous-versions).</span></span>

> [!TIP]
> <span data-ttu-id="9cf37-113">您可以在 GitHub 上檢視此文章的[範例](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/ClientEvaluation) \(英文\)。</span><span class="sxs-lookup"><span data-stu-id="9cf37-113">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/ClientEvaluation) on GitHub.</span></span>

## <a name="client-evaluation-in-the-top-level-projection"></a><span data-ttu-id="9cf37-114">最上層投影中的用戶端評估</span><span class="sxs-lookup"><span data-stu-id="9cf37-114">Client evaluation in the top-level projection</span></span>

<span data-ttu-id="9cf37-115">在下列範例中，helper 方法是用來標準化從 SQL Server 資料庫傳回的 blog 的 Url。</span><span class="sxs-lookup"><span data-stu-id="9cf37-115">In the following example, a helper method is used to standardize URLs for blogs, which are returned from a SQL Server database.</span></span> <span data-ttu-id="9cf37-116">由於 SQL Server 提供者無法深入瞭解此方法的執行方式，因此無法將它轉譯成 SQL。</span><span class="sxs-lookup"><span data-stu-id="9cf37-116">Since the SQL Server provider has no insight into how this method is implemented, it isn't possible to translate it into SQL.</span></span> <span data-ttu-id="9cf37-117">查詢的所有其他層面都會在資料庫中評估，但 `URL` 透過這個方法所傳回的會在用戶端上完成。</span><span class="sxs-lookup"><span data-stu-id="9cf37-117">All other aspects of the query are evaluated in the database, but passing the returned `URL` through this method is done on the client.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ClientMethod)]

## <a name="unsupported-client-evaluation"></a><span data-ttu-id="9cf37-118">不支援的用戶端評估</span><span class="sxs-lookup"><span data-stu-id="9cf37-118">Unsupported client evaluation</span></span>

<span data-ttu-id="9cf37-119">雖然用戶端評估很有用，但有時可能會導致效能不佳。</span><span class="sxs-lookup"><span data-stu-id="9cf37-119">While client evaluation is useful, it can result in poor performance sometimes.</span></span> <span data-ttu-id="9cf37-120">請考慮下列查詢，在其中，helper 方法現在用於 where 篩選準則中。</span><span class="sxs-lookup"><span data-stu-id="9cf37-120">Consider the following query, in which the helper method is now used in a where filter.</span></span> <span data-ttu-id="9cf37-121">因為無法在資料庫中套用篩選，所以必須將所有資料提取至記憶體中，以將篩選套用至用戶端。</span><span class="sxs-lookup"><span data-stu-id="9cf37-121">Because the filter can't be applied in the database, all the data needs to be pulled into memory to apply the filter on the client.</span></span> <span data-ttu-id="9cf37-122">根據篩選和伺服器上的資料量，用戶端評估可能會導致效能不佳。</span><span class="sxs-lookup"><span data-stu-id="9cf37-122">Based on the filter and the amount of data on the server, client evaluation could result in poor performance.</span></span> <span data-ttu-id="9cf37-123">因此 Entity Framework Core 會封鎖這類用戶端評估，並擲回執行時間例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9cf37-123">So Entity Framework Core blocks such client evaluation and throws a runtime exception.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ClientWhere)]

## <a name="explicit-client-evaluation"></a><span data-ttu-id="9cf37-124">明確用戶端評估</span><span class="sxs-lookup"><span data-stu-id="9cf37-124">Explicit client evaluation</span></span>

<span data-ttu-id="9cf37-125">在某些情況下，您可能需要明確地強制執行用戶端評估，如下所示</span><span class="sxs-lookup"><span data-stu-id="9cf37-125">You may need to force into client evaluation explicitly in certain cases like following</span></span>

- <span data-ttu-id="9cf37-126">資料量很小，因此在用戶端上進行評估不會產生顯著的效能影響。</span><span class="sxs-lookup"><span data-stu-id="9cf37-126">The amount of data is small so that evaluating on the client doesn't incur a huge performance penalty.</span></span>
- <span data-ttu-id="9cf37-127">使用的 LINQ 運算子沒有伺服器端轉譯。</span><span class="sxs-lookup"><span data-stu-id="9cf37-127">The LINQ operator being used has no server-side translation.</span></span>

<span data-ttu-id="9cf37-128">在這種情況下，您可以藉由呼叫方法（例如 `AsEnumerable` 或 `ToList` (） `AsAsyncEnumerable` 或 `ToListAsync` 非同步) 來明確加入宣告用戶端評估。</span><span class="sxs-lookup"><span data-stu-id="9cf37-128">In such cases, you can explicitly opt into client evaluation by calling methods like `AsEnumerable` or `ToList` (`AsAsyncEnumerable` or `ToListAsync` for async).</span></span> <span data-ttu-id="9cf37-129">藉由使用，您將會 `AsEnumerable` 串流處理結果，但使用 `ToList` 會藉由建立清單來產生緩衝，這也會佔用額外的記憶體。</span><span class="sxs-lookup"><span data-stu-id="9cf37-129">By using `AsEnumerable` you would be streaming the results, but using `ToList` would cause buffering by creating a list, which also takes additional memory.</span></span> <span data-ttu-id="9cf37-130">但是，如果您要列舉多次，則將結果儲存在清單中有助於更多，因為資料庫只有一個查詢。</span><span class="sxs-lookup"><span data-stu-id="9cf37-130">Though if you're enumerating multiple times, then storing results in a list helps more since there's only one query to the database.</span></span> <span data-ttu-id="9cf37-131">根據特定使用方式，您應該評估哪一種方法對案例而言更有用。</span><span class="sxs-lookup"><span data-stu-id="9cf37-131">Depending on the particular usage, you should evaluate which method is more useful for the case.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ExplicitClientEvaluation)]

> [!TIP]
> <span data-ttu-id="9cf37-132">如果您正在使用 `AsAsyncEnumerable` ，而且想要進一步在用戶端上撰寫查詢，則可以使用定義非同步可列舉值運算子的 [System.object. Async](https://www.nuget.org/packages/System.Interactive.Async/) 程式庫。</span><span class="sxs-lookup"><span data-stu-id="9cf37-132">If you are using `AsAsyncEnumerable` and want to compose the query further on client side then you can use [System.Interactive.Async](https://www.nuget.org/packages/System.Interactive.Async/) library which defines operators for async enumerables.</span></span> <span data-ttu-id="9cf37-133">如需詳細資訊，請參閱 [用戶端 linq 運算子](xref:core/miscellaneous/async#client-side-async-linq-operators)。</span><span class="sxs-lookup"><span data-stu-id="9cf37-133">For more information, see [client side linq operators](xref:core/miscellaneous/async#client-side-async-linq-operators).</span></span>

## <a name="potential-memory-leak-in-client-evaluation"></a><span data-ttu-id="9cf37-134">用戶端評估可能發生記憶體流失</span><span class="sxs-lookup"><span data-stu-id="9cf37-134">Potential memory leak in client evaluation</span></span>

<span data-ttu-id="9cf37-135">由於查詢轉譯和編譯的成本很高，EF Core 快取已編譯的查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="9cf37-135">Since query translation and compilation are expensive, EF Core caches the compiled query plan.</span></span> <span data-ttu-id="9cf37-136">快取的委派可能會在執行最上層投影的用戶端評估時使用用戶端程式代碼。</span><span class="sxs-lookup"><span data-stu-id="9cf37-136">The cached delegate may use client code while doing client evaluation of top-level projection.</span></span> <span data-ttu-id="9cf37-137">EF Core 會為樹狀結構的用戶端評估部分產生參數，並藉由取代參數值來重複使用查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="9cf37-137">EF Core generates parameters for the client-evaluated parts of the tree and reuses the query plan by replacing the parameter values.</span></span> <span data-ttu-id="9cf37-138">但是運算式樹狀架構中的某些常數無法轉換成參數。</span><span class="sxs-lookup"><span data-stu-id="9cf37-138">But certain constants in the expression tree can't be converted into parameters.</span></span> <span data-ttu-id="9cf37-139">如果快取的委派包含這類常數，則這些物件將無法進行垃圾收集，因為它們仍在參考中。</span><span class="sxs-lookup"><span data-stu-id="9cf37-139">If the cached delegate contains such constants, then those objects can't be garbage collected since they're still being referenced.</span></span> <span data-ttu-id="9cf37-140">如果這類物件包含 DbCoNtext 或其他服務，則可能會導致應用程式的記憶體使用量隨著時間成長。</span><span class="sxs-lookup"><span data-stu-id="9cf37-140">If such an object contains a DbContext or other services in it, then it could cause the memory usage of the app to grow over time.</span></span> <span data-ttu-id="9cf37-141">這種行為通常會造成記憶體流失的跡象。</span><span class="sxs-lookup"><span data-stu-id="9cf37-141">This behavior is generally a sign of a memory leak.</span></span> <span data-ttu-id="9cf37-142">EF Core 擲回例外狀況時，會擲回例外狀況，但無法使用目前的資料庫提供者來對應的類型常數。</span><span class="sxs-lookup"><span data-stu-id="9cf37-142">EF Core throws an exception whenever it comes across constants of a type that can't be mapped using current database provider.</span></span> <span data-ttu-id="9cf37-143">常見原因和其解決方案如下：</span><span class="sxs-lookup"><span data-stu-id="9cf37-143">Common causes and their solutions are as follows:</span></span>

- <span data-ttu-id="9cf37-144">**使用實例方法** ：在用戶端投影中使用實例方法時，運算式樹狀架構會包含實例的常數。</span><span class="sxs-lookup"><span data-stu-id="9cf37-144">**Using an instance method** : When using instance methods in a client projection, the expression tree contains a constant of the instance.</span></span> <span data-ttu-id="9cf37-145">如果您的方法未使用實例中的任何資料，請考慮將方法設為靜態。</span><span class="sxs-lookup"><span data-stu-id="9cf37-145">If your method doesn't use any data from the instance, consider making the method static.</span></span> <span data-ttu-id="9cf37-146">如果您需要方法主體中的實例資料，請將特定資料當作引數傳遞給方法。</span><span class="sxs-lookup"><span data-stu-id="9cf37-146">If you need instance data in the method body, then pass the specific data as an argument to the method.</span></span>
- <span data-ttu-id="9cf37-147">**將常數引數傳遞給方法** ：這種情況通常會 `this` 在用戶端方法的引數中使用。</span><span class="sxs-lookup"><span data-stu-id="9cf37-147">**Passing constant arguments to method** : This case arises generally by using `this` in an argument to client method.</span></span> <span data-ttu-id="9cf37-148">請考慮將引數分割成多個純量引數（可由資料庫提供者對應）。</span><span class="sxs-lookup"><span data-stu-id="9cf37-148">Consider splitting the argument in to multiple scalar arguments, which can be mapped by the database provider.</span></span>
- <span data-ttu-id="9cf37-149">**其他常數** ：如果常數是在其他任何情況下，您可以評估是否需要常數來處理。</span><span class="sxs-lookup"><span data-stu-id="9cf37-149">**Other constants** : If a constant is come across in any other case, then you can evaluate whether the constant is needed in processing.</span></span> <span data-ttu-id="9cf37-150">如果必須有常數，或如果您無法使用上述案例中的解決方案，請建立本機變數來儲存值，並在查詢中使用區域變數。</span><span class="sxs-lookup"><span data-stu-id="9cf37-150">If it's necessary to have the constant, or if you can't use a solution from the above cases, then create a local variable to store the value and use local variable in the query.</span></span> <span data-ttu-id="9cf37-151">EF Core 會將本機變數轉換成參數。</span><span class="sxs-lookup"><span data-stu-id="9cf37-151">EF Core will convert the local variable into a parameter.</span></span>

## <a name="previous-versions"></a><span data-ttu-id="9cf37-152">舊版</span><span class="sxs-lookup"><span data-stu-id="9cf37-152">Previous versions</span></span>

<span data-ttu-id="9cf37-153">下一節適用于3.0 之前的 EF Core 版本。</span><span class="sxs-lookup"><span data-stu-id="9cf37-153">The following section applies to EF Core versions before 3.0.</span></span>

<span data-ttu-id="9cf37-154">較舊的 EF Core 版本在查詢的任何部分中支援用戶端評估，而不只是最上層的投射。</span><span class="sxs-lookup"><span data-stu-id="9cf37-154">Older EF Core versions supported client evaluation in any part of the query--not just the top-level projection.</span></span> <span data-ttu-id="9cf37-155">這就是為什麼類似于未 [受支援用戶端評估](#unsupported-client-evaluation) 章節的查詢會正確運作。</span><span class="sxs-lookup"><span data-stu-id="9cf37-155">That's why queries similar to one posted under the [Unsupported client evaluation](#unsupported-client-evaluation) section worked correctly.</span></span> <span data-ttu-id="9cf37-156">由於這種行為可能會導致未察覺的效能問題，EF Core 記錄用戶端評估警告。</span><span class="sxs-lookup"><span data-stu-id="9cf37-156">Since this behavior could cause unnoticed performance issues, EF Core logged a client evaluation warning.</span></span> <span data-ttu-id="9cf37-157">如需有關如何查看記錄輸出的詳細資訊，請參閱 [記錄](xref:core/logging-events-diagnostics/index)。</span><span class="sxs-lookup"><span data-stu-id="9cf37-157">For more information on viewing logging output, see [Logging](xref:core/logging-events-diagnostics/index).</span></span>

<span data-ttu-id="9cf37-158">（選擇性） EF Core 可讓您變更預設行為，以在進行用戶端評估時擲回例外狀況或不執行任何動作， (除了投影) 中的。</span><span class="sxs-lookup"><span data-stu-id="9cf37-158">Optionally EF Core allowed you to change the default behavior to either throw an exception or do nothing when doing client evaluation (except for in the projection).</span></span> <span data-ttu-id="9cf37-159">例外狀況擲回行為會使它類似于3.0 中的行為。</span><span class="sxs-lookup"><span data-stu-id="9cf37-159">The exception throwing behavior would make it similar to the behavior in 3.0.</span></span> <span data-ttu-id="9cf37-160">若要變更此行為，您必須在設定內容的選項時（通常是在中）設定警告， `DbContext.OnConfiguring` `Startup.cs` 如果您使用 ASP.NET Core 則需要設定。</span><span class="sxs-lookup"><span data-stu-id="9cf37-160">To change the behavior, you need to configure warnings while setting up the options for your context - typically in `DbContext.OnConfiguring`, or in `Startup.cs` if you're using ASP.NET Core.</span></span>

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=EFQuerying;Trusted_Connection=True;")
        .ConfigureWarnings(warnings => warnings.Throw(RelationalEventId.QueryClientEvaluationWarning));
}
```
